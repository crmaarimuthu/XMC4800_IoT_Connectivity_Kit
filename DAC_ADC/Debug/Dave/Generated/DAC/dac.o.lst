   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "dac.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.XMC_DAC_EnableSimultaneousDataMode,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	XMC_DAC_EnableSimultaneousDataMode:
  25              	.LFB133:
  26              	 .file 1 "C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc/xmc_dac.h"
   1:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
   2:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @file xmc_dac.h
   3:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @date 2012-12-16
   4:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
   5:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @cond
   6:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *****************************************************************************
   7:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMClib v2.2.0 - XMC Peripheral Driver Library
   8:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
   9:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  10:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * All rights reserved.
  11:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  12:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Boost Software License - Version 1.0 - August 17th, 2003
  13:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  14:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Permission is hereby granted, free of charge, to any person or organization
  15:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * obtaining a copy of the software and accompanying documentation covered by
  16:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * this license (the "Software") to use, reproduce, display, distribute,
  17:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * execute, and transmit the Software, and to prepare derivative works of the
  18:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Software, and to permit third-parties to whom the Software is furnished to
  19:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * do so, all subject to the following:
  20:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  21:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The copyright notices in the Software and this entire statement, including
  22:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * the above license grant, this restriction and the following disclaimer,
  23:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * must be included in all copies of the Software, in whole or in part, and
  24:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * all derivative works of the Software, unless such copies or derivative
  25:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * works are solely in the form of machine-executable object code generated by
  26:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * a source language processor.
  27:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  28:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  29:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  30:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  31:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  32:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  33:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  34:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * DEALINGS IN THE SOFTWARE.
  35:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  36:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * To improve the quality of the software, users are encouraged to share
  37:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * modifications, enhancements or bug fixes with Infineon Technologies AG
  38:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * at XMCSupport@infineon.com.
  39:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *****************************************************************************
  40:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  41:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Change History
  42:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * --------------
  43:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  44:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 2015-02-18:
  45:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *     - Initial version
  46:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  47:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 2015-02-20:
  48:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *     - Driver description added
  49:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  50:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 2015-06-19:
  51:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  52:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  53:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 2015-08-31:
  54:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *     - Help document updated
  55:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  56:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 2019-12-16:
  57:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *     - Fix including xmc_common.h following the convention: angle brackets are used for standard 
  58:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  59:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @endcond
  60:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  61:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
  62:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
  63:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #ifndef XMC_DAC_H
  64:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_H
  65:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
  66:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /*******************************************************************************
  67:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * HEADER FILES
  68:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *******************************************************************************/
  69:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
  70:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #include "xmc_common.h"
  71:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
  72:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /* DAC peripheral is not available on XMC1X devices. */
  73:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #if defined(DAC)
  74:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
  75:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
  76:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @addtogroup XMClib
  77:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @{
  78:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
  79:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
  80:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
  81:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @addtogroup DAC
  82:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @{
  83:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  84:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @brief Digital to Analog Converter (DAC) driver for XMC 4000 microcontroller family. <br>
  85:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  86:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * DAC driver uses DAC peripheral to convert digital value to analog value. XMC4000 microcontroller
  87:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * and maximum conversion rate of 2MHz with full accuracy and 5MHz with reduced accuracy.
  88:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * It consists of inbuilt pattern generator, ramp generator and noise generator modes. Additionally
  89:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * in single value mode and in data mode.
  90:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * It has DMA handling capability to generate custom waveforms in data mode without CPU interventio
  91:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
  92:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * DAC driver features:
  93:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * -#  Configuration structure XMC_DAC_CH_CONFIG_t and initialization function XMC_DAC_CH_Init() to
  94:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * -#  Pattern Generator Mode:
  95:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 	- DAC is configured in pattern generator mode using XMC_DAC_CH_StartPatternMode()
  96:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 	- XMC_DAC_CH_SetPattern() is used to set the waveform pattern values in pattern register for on
  97:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 	- Allows to change the trigger frequency using XMC_DAC_CH_SetPatternFrequency()
  98:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * -#  Single Value Mode:
  99:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 	- DAC is configured in single value mode using XMC_DAC_CH_StartSingleValueMode()
 100:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 	- Allows to change the trigger frequency using XMC_DAC_CH_SetFrequency()
 101:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * -# Data Mode:
 102:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 	- DAC is configured in data mode using XMC_DAC_CH_StartDataMode()
 103:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 	- Allows to change the trigger frequency using XMC_DAC_CH_SetFrequency()
 104:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * -# Ramp Mode:
 105:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *  - DAC is configured in ramp generator mode using XMC_DAC_CH_StartRampMode()
 106:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *  - Allows to change the trigger frequency using XMC_DAC_CH_SetRampFrequency()
 107:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *  - Allows to set the start and stop values of the ramp using XMC_DAC_CH_SetRampStart() and XMC_D
 108:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * -# Noise Mode:
 109:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 	- DAC is configured in noise mode using XMC_DAC_CH_StartNoiseMode()
 110:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * 	- Allows to change the trigger frequency using XMC_DAC_CH_SetFrequency()
 111:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * -# Allows to change the scale, offset dynamically using XMC_DAC_CH_SetOutputScale() and XMC_DAC_
 112:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * -# Allows to select one of the eight possible trigger sources using XMC_DAC_CH_SetTrigger()
 113:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * -# 2 DAC channels can be used in synchronization in single value mode and data mode to generate 
 114:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 115:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 116:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /*******************************************************************************
 117:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * MACROS
 118:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *******************************************************************************/
 119:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 120:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC0 ((XMC_DAC_t *)DAC_BASE)         /**< DAC module register base */
 121:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 122:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_DACCFG_NEGATE_Msk (0x10000000UL) /*< DAC negation enable mask in XMC44 device */
 123:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_NO_CHANNELS (2U)                 /**< DAC maximum channels */
 124:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_SAMPLES_PER_PERIOD (32U)         /**< DAC samples per period in pattern mode */
 125:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 126:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_PATTERN_TRIANGLE  {0U, 4U, 8U, 12U, 16U, 19U, 23U, 27U, 31U} /**< First quarter Tri
 127:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_PATTERN_SINE      {0U, 6U, 12U, 17U, 22U, 26U, 29U, 30U, 31U} /**< First quarter Si
 128:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_PATTERN_RECTANGLE {31U, 31U, 31U, 31U, 31U, 31U, 31U, 31U, 31U} /**< First quarter 
 129:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 130:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_IS_DAC_VALID(PTR)            ((PTR) == XMC_DAC0)
 131:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_IS_CHANNEL_VALID(CH)         (CH < XMC_DAC_NO_CHANNELS)
 132:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_IS_TRIGGER_VALID(TRIGGER)    ((TRIGGER == XMC_DAC_CH_TRIGGER_INTERNAL) ||\
 133:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (TRIGGER == XMC_DAC_CH_TRIGGER_EXTERNAL_CCU80_SR1) ||
 134:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (TRIGGER == XMC_DAC_CH_TRIGGER_EXTERNAL_CCU40_SR1) ||
 135:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (TRIGGER == XMC_DAC_CH_TRIGGER_EXTERNAL_CCU41_SR1) ||
 136:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (TRIGGER == XMC_DAC_CH_TRIGGER_EXTERNAL_P2_9) ||\
 137:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (TRIGGER == XMC_DAC_CH_TRIGGER_EXTERNAL_P2_8) ||\
 138:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (TRIGGER == XMC_DAC_CH_TRIGGER_EXTERNAL_U0C0_DX1INS) 
 139:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (TRIGGER == XMC_DAC_CH_TRIGGER_EXTERNAL_U1C0_DX1INS) 
 140:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (TRIGGER == XMC_DAC_CH_TRIGGER_SOFTWARE))
 141:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_IS_MODE_VALID(MODE)          ((MODE == XMC_DAC_CH_MODE_IDLE) ||\
 142:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (MODE == XMC_DAC_CH_MODE_SINGLE) ||\
 143:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (MODE == XMC_DAC_CH_MODE_DATA) ||\
 144:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (MODE == XMC_DAC_CH_MODE_PATTERN) ||\
 145:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (MODE == XMC_DAC_CH_MODE_NOISE) ||\
 146:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (MODE == XMC_DAC_CH_MODE_RAMP))
 147:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #define XMC_DAC_IS_OUTPUT_SCALE_VALID(SCALE) ((SCALE == XMC_DAC_CH_OUTPUT_SCALE_NONE) ||\
 148:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_MUL_2) ||\
 149:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_MUL_4) ||\
 150:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_MUL_8) ||\
 151:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_MUL_16) ||\
 152:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_MUL_32) ||\
 153:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_MUL_64) ||\
 154:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_MUL_128) ||\
 155:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_DIV_2) ||\
 156:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_DIV_4) ||\
 157:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_DIV_8) ||\
 158:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_DIV_16) ||\
 159:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_DIV_32) ||\
 160:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_DIV_64) ||\
 161:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                               (SCALE == XMC_DAC_CH_OUTPUT_SCALE_DIV_128))
 162:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 163:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 164:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /*******************************************************************************
 165:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * ENUMS
 166:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *******************************************************************************/
 167:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 168:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 169:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Return types of the API's
 170:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 171:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** typedef enum XMC_DAC_CH_STATUS
 172:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 173:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_STATUS_OK              = 0U, /**< Status is ok, no error detected */
 174:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_STATUS_ERROR           = 1U, /**< Error detected */
 175:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_STATUS_BUSY            = 2U, /**< DAC is busy */
 176:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_STATUS_ERROR_FREQ2LOW  = 3U, /**< Frequency can't be configured. Frequency is to low. 
 177:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_STATUS_ERROR_FREQ2HIGH = 4U  /**< Frequency can't be configured. Frequency is to high.
 178:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** } XMC_DAC_CH_STATUS_t;
 179:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 180:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 181:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Operating modes of DAC
 182:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 183:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** typedef enum XMC_DAC_CH_MODE
 184:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 185:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_MODE_IDLE    = 0x0U << DAC_DAC0CFG0_MODE_Pos,    /**< DAC is disabled */
 186:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_MODE_SINGLE  = 0x1U << DAC_DAC0CFG0_MODE_Pos,    /**< Single value mode - single data 
 187:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_MODE_DATA    = 0x2U << DAC_DAC0CFG0_MODE_Pos,    /**< Data mode - continuous data proc
 188:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_MODE_PATTERN = 0x3U << DAC_DAC0CFG0_MODE_Pos,    /**< Pattern mode - inbuilt pattern w
 189:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                                                                    Sine, Triangle, Rectangle */
 190:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_MODE_NOISE   = 0x4U << DAC_DAC0CFG0_MODE_Pos,    /**< Noise mode - pseudo-random noise
 191:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_MODE_RAMP    = 0x5U << DAC_DAC0CFG0_MODE_Pos     /**< Ramp mode - ramp generation */
 192:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** } XMC_DAC_CH_MODE_t;
 193:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 194:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 195:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Trigger sources for the data update
 196:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 197:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** typedef enum XMC_DAC_CH_TRIGGER
 198:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 199:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_TRIGGER_INTERNAL =
 200:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x0U << DAC_DAC0CFG1_TRIGMOD_Pos),                                      /**< Internal trigger 
 201:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_TRIGGER_EXTERNAL_CCU80_SR1 =
 202:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_TRIGMOD_Pos) | 0x0U,                               /**< External trigger 
 203:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_TRIGGER_EXTERNAL_CCU40_SR1 =
 204:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_TRIGMOD_Pos) | (0x2U << DAC_DAC0CFG1_TRIGSEL_Pos), /**< External trigger 
 205:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_TRIGGER_EXTERNAL_CCU41_SR1 =
 206:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_TRIGMOD_Pos) | (0x3U << DAC_DAC0CFG1_TRIGSEL_Pos), /**< External trigger 
 207:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_TRIGGER_EXTERNAL_P2_9 =
 208:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_TRIGMOD_Pos) | (0x4U << DAC_DAC0CFG1_TRIGSEL_Pos), /**< External trigger 
 209:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_TRIGGER_EXTERNAL_P2_8 =
 210:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_TRIGMOD_Pos) | (0x5U << DAC_DAC0CFG1_TRIGSEL_Pos), /**< External trigger 
 211:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_TRIGGER_EXTERNAL_U0C0_DX1INS =
 212:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_TRIGMOD_Pos) | (0x6U << DAC_DAC0CFG1_TRIGSEL_Pos), /**< External trigger 
 213:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_TRIGGER_EXTERNAL_U1C0_DX1INS =
 214:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_TRIGMOD_Pos) | (0x7U << DAC_DAC0CFG1_TRIGSEL_Pos), /**< External trigger 
 215:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_TRIGGER_SOFTWARE =
 216:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x2U << DAC_DAC0CFG1_TRIGMOD_Pos)                                       /**< Software trigger 
 217:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** } XMC_DAC_CH_TRIGGER_t;
 218:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 219:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 220:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Data type of the input data
 221:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 222:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** typedef enum XMC_DAC_CH_DATA_TYPE
 223:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 224:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_DATA_TYPE_UNSIGNED = 0U,  /**< input data is unsigned */
 225:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_DATA_TYPE_SIGNED = 1U     /**< input data is signed */
 226:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** } XMC_DAC_CH_DATA_TYPE_t;
 227:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 228:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 229:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Scaling of the input data
 230:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 231:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** typedef enum XMC_DAC_CH_OUTPUT_SCALE
 232:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 233:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_NONE =
 234:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     0x0U,                                                                   /**< No scaling */
 235:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_MUL_2 =
 236:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_MULDIV_Pos) | (0x1U << DAC_DAC0CFG1_SCALE_Pos),   /**< multiplied by 2 */
 237:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_MUL_4 =
 238:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_MULDIV_Pos) | (0x2U << DAC_DAC0CFG1_SCALE_Pos),   /**< multiplied by 4 */
 239:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_MUL_8 =
 240:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_MULDIV_Pos) | (0x3U << DAC_DAC0CFG1_SCALE_Pos),   /**< multiplied by 8 */
 241:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_MUL_16 =
 242:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_MULDIV_Pos) | (0x4U << DAC_DAC0CFG1_SCALE_Pos),   /**< multiplied by 16 *
 243:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_MUL_32 =
 244:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_MULDIV_Pos) | (0x5U << DAC_DAC0CFG1_SCALE_Pos),   /**< multiplied by 32 *
 245:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_MUL_64 =
 246:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_MULDIV_Pos) | (0x6U << DAC_DAC0CFG1_SCALE_Pos),   /**< multiplied by 64 *
 247:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_MUL_128 =
 248:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     (0x1U << DAC_DAC0CFG1_MULDIV_Pos) | (0x7U << DAC_DAC0CFG1_SCALE_Pos),   /**< multiplied by 128 
 249:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_DIV_2 =
 250:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     0x1U << DAC_DAC0CFG1_SCALE_Pos,                                         /**< divided by 2 */
 251:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_DIV_4 =
 252:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     0x2U << DAC_DAC0CFG1_SCALE_Pos,                                         /**< divided by 4 */
 253:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_DIV_8 =
 254:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     0x3U << DAC_DAC0CFG1_SCALE_Pos,                                         /**< divided by 8 */
 255:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_DIV_16 =
 256:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     0x4U << DAC_DAC0CFG1_SCALE_Pos,                                         /**< divided by 16 */
 257:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_DIV_32 =
 258:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     0x5U << DAC_DAC0CFG1_SCALE_Pos,                                         /**< divided by 32 */
 259:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_DIV_64 =
 260:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     0x6U << DAC_DAC0CFG1_SCALE_Pos,                                         /**< divided by 64 */
 261:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_SCALE_DIV_128 =
 262:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     0x7U << DAC_DAC0CFG1_SCALE_Pos                                          /**< divided by 128 */
 263:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** } XMC_DAC_CH_OUTPUT_SCALE_t;
 264:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 265:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 266:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Negation of input data (applicable only for XMC44 device)
 267:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 268:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** typedef enum XMC_DAC_CH_OUTPUT_NEGATION
 269:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 270:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_NEGATION_DISABLED = 0U,                   /**< XMC_DAC_CH_OUTPUT_NEGATION_DISAB
 271:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_OUTPUT_NEGATION_ENABLED = 1U                     /**< XMC_DAC_CH_OUTPUT_NEGATION_ENABL
 272:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** } XMC_DAC_CH_OUTPUT_NEGATION_t;
 273:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 274:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 275:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Output sign signal for the Pattern Generation Mode
 276:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 277:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** typedef enum XMC_DAC_CH_PATTERN_SIGN_OUTPUT
 278:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 279:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_PATTERN_SIGN_OUTPUT_DISABLED = 0U,  /**< Sign output signal generation is disabled */
 280:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_DAC_CH_PATTERN_SIGN_OUTPUT_ENABLED = 1U    /**< Sign output signal generation is enabled */
 281:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** } XMC_DAC_CH_PATTERN_SIGN_OUTPUT_t;
 282:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 283:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /*******************************************************************************
 284:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * DATA STRUCTURES
 285:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *******************************************************************************/
 286:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 287:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * DAC peripheral registers configuration.
 288:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 289:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** typedef struct
 290:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 291:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   __I  uint32_t  ID;
 292:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 293:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   struct
 294:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   {
 295:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     __IO uint32_t low;
 296:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     __IO uint32_t high;
 297:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   } DACCFG[XMC_DAC_NO_CHANNELS];
 298:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 299:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   __IO uint32_t DACDATA[XMC_DAC_NO_CHANNELS];
 300:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   __IO uint32_t DAC01DATA;
 301:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 302:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   struct
 303:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   {
 304:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     __IO uint32_t low;
 305:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     __IO uint32_t high;
 306:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   } DACPAT[XMC_DAC_NO_CHANNELS];
 307:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 308:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** } XMC_DAC_t;
 309:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 310:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /*Anonymous structure/union guard start*/
 311:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #if defined(__CC_ARM)
 312:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #pragma push
 313:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #pragma anon_unions
 314:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #elif defined(__TASKING__)
 315:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #pragma warning 586
 316:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #endif
 317:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 318:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 319:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Channel related configuration
 320:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 321:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** typedef struct XMC_DAC_CH_CONFIG
 322:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 323:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   union
 324:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   {
 325:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     struct
 326:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     {
 327:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****       uint32_t : 23;               /**< Not used bits */
 328:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****       uint32_t data_type: 1;       /**< input data type - unsigned / signed */
 329:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****       uint32_t : 4;                /**< Not used bits */
 330:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****       uint32_t output_negation: 1; /**< Negation of the output waveform enabled/disabled */
 331:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****       uint32_t : 3;
 332:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     };
 333:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     uint32_t cfg0;
 334:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   };
 335:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   union
 336:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   {
 337:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     struct
 338:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     {
 339:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****       uint32_t output_scale: 4; /**< Scale value of type XMC_DAC_CH_OUTPUT_SCALE_t. It includes sca
 340:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****       uint32_t output_offset: 8; /**< offset value */
 341:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****       uint32_t : 20;
 342:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     };
 343:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     uint32_t cfg1;
 344:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   };
 345:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** } XMC_DAC_CH_CONFIG_t;
 346:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /*Anonymous structure/union guard end*/
 347:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #if defined(__CC_ARM)
 348:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #pragma pop
 349:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #elif defined(__TASKING__)
 350:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #pragma warning restore
 351:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #endif
 352:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /*******************************************************************************
 353:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * API PROTOTYPES
 354:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *******************************************************************************/
 355:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 356:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #ifdef __cplusplus
 357:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** extern "C" {
 358:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** #endif
 359:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 360:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 361:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 362:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 363:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 364:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 365:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 366:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Enables DAC clock and releases DAC reset.<br>
 367:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 368:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 369:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Enabling DAC is the first step of DAC initialisation. This API is called by XMC_DAC_CH_Init().
 370:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * DAC clock is enabled by setting \a DAC bit of \a CGATCLR1 register. DAC reset is released by set
 371:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 372:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 373:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 374:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_IsEnabled(), XMC_DAC_Disable(), XMC_DAC_CH_Init()\n\n\n
 375:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 376:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 377:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** void XMC_DAC_Enable(XMC_DAC_t *const dac);
 378:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 379:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 380:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 381:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 382:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 383:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 384:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 385:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Disables DAC clock and resets DAC.
 386:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 387:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 388:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * DAC clock is disabled by setting \a DAC bit of \a CGATSET1 register. DAC is reset by setting \a 
 389:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 390:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 391:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_IsEnabled(), XMC_DAC_Enable()\n\n\n
 392:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 393:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 394:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** void XMC_DAC_Disable(XMC_DAC_t *const dac);
 395:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 396:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 397:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 398:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 399:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return bool<br>
 400:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * true  - if DAC is enabled<br>
 401:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * false - if DAC is disabled
 402:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 403:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 404:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Returns the state of the DAC.
 405:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 406:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 407:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * DAC enabled status is determined by referring to \a DACRS bit of \a PRSTAT1 register.
 408:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 409:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 410:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_Enable(), XMC_DAC_Disable()\n\n\n
 411:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 412:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 413:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** bool XMC_DAC_IsEnabled(const XMC_DAC_t *const dac);
 414:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 415:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 416:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 417:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 418:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 419:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 420:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 421:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * DAC switches to Simultaneous data mode from Independent data mode.
 422:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 423:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 424:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Independent data mode is the default data mode.
 425:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Simultaneous data mode is enabled by setting \a DATMOD bit of \a DAC0CFG1 register.
 426:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 427:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 428:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Set channel 0 and channel 1 to Data mode before calling this API.
 429:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 430:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 431:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_StartSingleValueMode(), XMC_DAC_CH_StartDataMode(), XMC_DAC_SimultaneousWrite(), XMC_
 432:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 433:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 434:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_EnableSimultaneousDataMode(XMC_DAC_t *const dac)
 435:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
  27              	 .loc 1 435 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 83B0     	 sub sp,sp,#12
  37              	.LCFI1:
  38              	 .cfi_def_cfa_offset 16
  39 0004 00AF     	 add r7,sp,#0
  40              	.LCFI2:
  41              	 .cfi_def_cfa_register 7
  42 0006 7860     	 str r0,[r7,#4]
 436:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_EnableSimultaneousDataMode: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(
 437:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 438:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[0].high |= DAC_DAC0CFG1_DATMOD_Msk;
  43              	 .loc 1 438 0
  44 0008 7B68     	 ldr r3,[r7,#4]
  45 000a 9B68     	 ldr r3,[r3,#8]
  46 000c 43F40042 	 orr r2,r3,#32768
  47 0010 7B68     	 ldr r3,[r7,#4]
  48 0012 9A60     	 str r2,[r3,#8]
 439:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
  49              	 .loc 1 439 0
  50 0014 0C37     	 adds r7,r7,#12
  51              	.LCFI3:
  52              	 .cfi_def_cfa_offset 4
  53 0016 BD46     	 mov sp,r7
  54              	.LCFI4:
  55              	 .cfi_def_cfa_register 13
  56              	 
  57 0018 5DF8047B 	 ldr r7,[sp],#4
  58              	.LCFI5:
  59              	 .cfi_restore 7
  60              	 .cfi_def_cfa_offset 0
  61 001c 7047     	 bx lr
  62              	 .cfi_endproc
  63              	.LFE133:
  65 001e 00BF     	 .section .text.XMC_DAC_SimultaneousWrite,"ax",%progbits
  66              	 .align 2
  67              	 .thumb
  68              	 .thumb_func
  70              	XMC_DAC_SimultaneousWrite:
  71              	.LFB135:
 440:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 441:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 442:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 443:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 444:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 445:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 446:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 447:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * DAC switches to independent data mode from simultaneous Data mode.
 448:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 449:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 450:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Independent data mode is the default data mode.
 451:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Simultaneous data mode is disabled by clearing \a DATMOD bit of \a DAC0CFG1 register.
 452:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 453:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 454:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_StartDataMode(), XMC_DAC_EnableSimultaneousDataMode()\n\n\n
 455:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 456:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 457:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_DisableSimultaneousDataMode(XMC_DAC_t *const dac)
 458:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 459:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_DisableSimultaneousDataMode: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID
 460:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 461:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[0].high &= ~DAC_DAC0CFG1_DATMOD_Msk;
 462:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 463:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 464:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 465:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 466:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param data0 Data for DAC channel 0 [0-4095]
 467:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param data1 Data for DAC channel 1 [0-4095]
 468:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 469:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 470:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 471:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 472:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The data (\e data0 & \e data1) to be converted by channel 0 & channel 1 are updated to \a DATA1 
 473:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * data0 and data1 have the range of [0-4095].
 474:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 475:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 476:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Channel 0 and Channel 1 should be set to simultaneous data mode before calling this API.
 477:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 478:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 479:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_EnableSimultaneousDataMode()\n\n\n
 480:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 481:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 482:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_SimultaneousWrite(XMC_DAC_t *const dac, const uint16_t data0, const ui
 483:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
  72              	 .loc 1 483 0
  73              	 .cfi_startproc
  74              	 
  75              	 
  76              	 
  77 0000 80B4     	 push {r7}
  78              	.LCFI6:
  79              	 .cfi_def_cfa_offset 4
  80              	 .cfi_offset 7,-4
  81 0002 83B0     	 sub sp,sp,#12
  82              	.LCFI7:
  83              	 .cfi_def_cfa_offset 16
  84 0004 00AF     	 add r7,sp,#0
  85              	.LCFI8:
  86              	 .cfi_def_cfa_register 7
  87 0006 7860     	 str r0,[r7,#4]
  88 0008 0B46     	 mov r3,r1
  89 000a 7B80     	 strh r3,[r7,#2]
  90 000c 1346     	 mov r3,r2
  91 000e 3B80     	 strh r3,[r7]
 484:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_SimultaneousWrite: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
 485:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 486:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DAC01DATA = (data0 << DAC_DAC01DATA_DATA0_Pos) | (data1 << DAC_DAC01DATA_DATA1_Pos);
  92              	 .loc 1 486 0
  93 0010 7A88     	 ldrh r2,[r7,#2]
  94 0012 3B88     	 ldrh r3,[r7]
  95 0014 1B04     	 lsls r3,r3,#16
  96 0016 1343     	 orrs r3,r3,r2
  97 0018 1A46     	 mov r2,r3
  98 001a 7B68     	 ldr r3,[r7,#4]
  99 001c DA61     	 str r2,[r3,#28]
 487:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 100              	 .loc 1 487 0
 101 001e 0C37     	 adds r7,r7,#12
 102              	.LCFI9:
 103              	 .cfi_def_cfa_offset 4
 104 0020 BD46     	 mov sp,r7
 105              	.LCFI10:
 106              	 .cfi_def_cfa_register 13
 107              	 
 108 0022 5DF8047B 	 ldr r7,[sp],#4
 109              	.LCFI11:
 110              	 .cfi_restore 7
 111              	 .cfi_def_cfa_offset 0
 112 0026 7047     	 bx lr
 113              	 .cfi_endproc
 114              	.LFE135:
 116              	 .section .text.XMC_DAC_CH_Write,"ax",%progbits
 117              	 .align 2
 118              	 .thumb
 119              	 .thumb_func
 121              	XMC_DAC_CH_Write:
 122              	.LFB139:
 488:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 489:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 490:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 491:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 492:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param config Pointer to the DAC channel configuration structure
 493:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 494:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 495:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 496:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 497:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Initialises and configures the DAC \e channel with the configuration date pointed by \e config.
 498:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 499:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 500:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * DAC channel is initialised by configuring the registers \a DAC0CFG0 and \a DAC0CFG1 registers (f
 501:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * It enables the channel output by calling XMC_DAC_CH_EnableOutput().
 502:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 503:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 504:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** void XMC_DAC_CH_Init(XMC_DAC_t *const dac, const uint8_t channel, const XMC_DAC_CH_CONFIG_t *const 
 505:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 506:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 507:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 508:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 509:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 510:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 511:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 512:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 513:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Channel \a channel output is enabled by setting the \a ANAEN bit of \a DAC0CFG1 register (for ch
 514:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 515:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><BR>
 516:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \a tSTARTUP time for DAC analog output starts after the \a ANAEN bit is set to one.
 517:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * After the expiry of the startup time the default value is driven to DAC output and a new value c
 518:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 519:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 520:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_DisableOutput(), XMC_DAC_CH_IsOutputEnabled()\n\n\n
 521:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 522:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 523:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_EnableOutput(XMC_DAC_t *const dac, const uint8_t channel)
 524:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 525:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_EnableOutput: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
 526:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_EnableOutput: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(cha
 527:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 528:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].high |= DAC_DAC0CFG1_ANAEN_Msk;
 529:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 530:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 531:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 532:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 533:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 534:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 535:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 536:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 537:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 538:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Channel \a channel output is disabled by clearing the \a ANAEN bit of \a DAC0CFG1 register (for 
 539:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 540:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 541:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * A call to this API stops driving the converted digital input to its output.
 542:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 543:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 544:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_EnableOutput(), XMC_DAC_CH_IsOutputEnabled()\n\n\n
 545:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 546:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 547:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_DisableOutput(XMC_DAC_t *const dac, const uint8_t channel)
 548:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 549:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_DisableOutput: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
 550:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_DisableOutput: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(ch
 551:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 552:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].high &= ~DAC_DAC0CFG1_ANAEN_Msk;
 553:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 554:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 555:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 556:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 557:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 558:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 559:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return bool <BR>
 560:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * true  - if analog output is enabled <BR>
 561:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * false - if analog output is disabled <BR>
 562:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 563:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 564:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Returns the status of DAC analog output.
 565:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 566:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 567:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Channel \a channel output enabled or disabled is determined by reading the \a ANAEN bit of \a DA
 568:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 569:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 570:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_EnableOutput(), XMC_DAC_CH_DisableOutput()\n\n\n
 571:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 572:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 573:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE bool XMC_DAC_CH_IsOutputEnabled(const XMC_DAC_t *const dac, const uint8_t channel)
 574:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 575:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_IsOutputEnabled: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
 576:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_IsOutputEnabled: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(
 577:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 578:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   return (bool)(dac->DACCFG[channel].high & DAC_DAC0CFG1_ANAEN_Msk);
 579:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 580:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 581:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 582:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 583:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 584:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param data Data to be written  [0-4095]
 585:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 586:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 587:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 588:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 589:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Writes the \e data to the \e channel's DATA register.
 590:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 591:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 592:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The \e data is then converted and driven to the output.
 593:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * If the trigger is set, On a trigger event the data in DATA register is converted and driven to \
 594:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Data \a data is written to the \a channel by loading \a data to \a DATA0 bit-field of \a DAC0DAT
 595:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * data has the range of [0-4095].
 596:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 597:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 598:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The API can be used for Single Value Mode, Data Mode (Individual) & Ramp Mode.
 599:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call XMC_DAC_CH_EnableOutput() API to enable analog output.
 600:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 601:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 602:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_StartSingleValueMode(), XMC_DAC_CH_StartDataMode(), XMC_DAC_CH_StartRampMode()\n\n\n
 603:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 604:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 605:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_Write(XMC_DAC_t *const dac, const uint8_t channel, const uint16_t d
 606:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 123              	 .loc 1 606 0
 124              	 .cfi_startproc
 125              	 
 126              	 
 127              	 
 128 0000 80B4     	 push {r7}
 129              	.LCFI12:
 130              	 .cfi_def_cfa_offset 4
 131              	 .cfi_offset 7,-4
 132 0002 83B0     	 sub sp,sp,#12
 133              	.LCFI13:
 134              	 .cfi_def_cfa_offset 16
 135 0004 00AF     	 add r7,sp,#0
 136              	.LCFI14:
 137              	 .cfi_def_cfa_register 7
 138 0006 7860     	 str r0,[r7,#4]
 139 0008 0B46     	 mov r3,r1
 140 000a FB70     	 strb r3,[r7,#3]
 141 000c 1346     	 mov r3,r2
 142 000e 3B80     	 strh r3,[r7]
 607:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_Write: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
 608:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_Write: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(channel));
 609:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 610:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACDATA[channel] = data;
 143              	 .loc 1 610 0
 144 0010 FB78     	 ldrb r3,[r7,#3]
 145 0012 3A88     	 ldrh r2,[r7]
 146 0014 7968     	 ldr r1,[r7,#4]
 147 0016 0433     	 adds r3,r3,#4
 148 0018 9B00     	 lsls r3,r3,#2
 149 001a 0B44     	 add r3,r3,r1
 150 001c 5A60     	 str r2,[r3,#4]
 611:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 151              	 .loc 1 611 0
 152 001e 0C37     	 adds r7,r7,#12
 153              	.LCFI15:
 154              	 .cfi_def_cfa_offset 4
 155 0020 BD46     	 mov sp,r7
 156              	.LCFI16:
 157              	 .cfi_def_cfa_register 13
 158              	 
 159 0022 5DF8047B 	 ldr r7,[sp],#4
 160              	.LCFI17:
 161              	 .cfi_restore 7
 162              	 .cfi_def_cfa_offset 0
 163 0026 7047     	 bx lr
 164              	 .cfi_endproc
 165              	.LFE139:
 167              	 .section .text.XMC_DAC_CH_SetRampStart,"ax",%progbits
 168              	 .align 2
 169              	 .thumb
 170              	 .thumb_func
 172              	XMC_DAC_CH_SetRampStart:
 173              	.LFB142:
 612:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 613:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 614:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 615:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 616:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 617:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 618:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 619:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 620:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the \e channel to Single Value Mode by calling XMC_DAC_CH_SetMode().
 621:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 622:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 623:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call XMC_DAC_CH_Write() API to write the data.
 624:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 625:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 626:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_Write()\n\n\n
 627:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 628:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 629:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** XMC_DAC_CH_STATUS_t XMC_DAC_CH_StartSingleValueMode(XMC_DAC_t *const dac, const uint8_t channel);
 630:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 631:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 632:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 633:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 634:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param trigger Data points update trigger
 635:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param frequency Waveform frequency [Hz]
 636:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 637:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return XMC_DAC_CH_STATUS_t status
 638:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 639:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 640:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the \e channel to Data mode. Trigger and frequency are configured.
 641:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 642:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 643:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call XMC_DAC_CH_Write() API to write the data. Call XMC_DAC_EnableSimultaneousDataMode() to swit
 644:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 645:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 646:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_Init(), XMC_DAC_CH_Write(), XMC_DAC_EnableSimultaneousDataMode() \n\n\n
 647:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 648:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 649:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** XMC_DAC_CH_STATUS_t XMC_DAC_CH_StartDataMode(XMC_DAC_t *const dac,
 650:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint8_t channel,
 651:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const XMC_DAC_CH_TRIGGER_t trigger,
 652:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint32_t frequency);
 653:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 654:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 655:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 656:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 657:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param start Start point of the ramp [0-4095]
 658:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param stop Stop point of the ramp [0-4095]
 659:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param trigger Data points update trigger
 660:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param frequency Ramp frequency in [Hz]
 661:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 662:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return XMC_DAC_CH_STATUS_t status
 663:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 664:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 665:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the \e channel to Ramp mode. Trigger, frequency, start and stop values are configured.
 666:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * On a \e trigger ramp values are converted and driven to \e channel output.
 667:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Start and stop have the range of [0-4095]. Stop should be equal or greater than start.
 668:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 669:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 670:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * If the ramp counter reaches its \e stop value, it restarts from the \e start value with the next
 671:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 672:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 673:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_Init(), XMC_DAC_CH_GetRampStart(), XMC_DAC_CH_GetRampStop() \n\n\n
 674:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 675:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 676:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** XMC_DAC_CH_STATUS_t XMC_DAC_CH_StartRampMode(XMC_DAC_t *const dac,
 677:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint8_t channel,
 678:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint16_t start,
 679:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint16_t stop,
 680:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const XMC_DAC_CH_TRIGGER_t trigger,
 681:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint32_t frequency);
 682:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 683:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 684:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 685:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 686:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param pattern Data table of a pattern
 687:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param sign_output Sign information of the waveform
 688:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param trigger Data points update trigger
 689:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param frequency Waveform frequency in [Hz]
 690:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 691:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return XMC_DAC_CH_STATUS_t status
 692:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 693:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 694:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the \e channel to Pattern mode. Trigger, frequency, sign output and data are configured.
 695:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * On a \e trigger, the \e pattern values are converted and driven to \e channel output.
 696:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 697:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 698:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_Init(), XMC_DAC_CH_DisablePatternSignOutput() \n\n\n
 699:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 700:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 701:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** XMC_DAC_CH_STATUS_t XMC_DAC_CH_StartPatternMode(XMC_DAC_t *const dac,
 702:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint8_t channel,
 703:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint8_t *const pattern,
 704:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const XMC_DAC_CH_PATTERN_SIGN_OUTPUT_t sign_output,
 705:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const XMC_DAC_CH_TRIGGER_t trigger,
 706:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint32_t frequency);
 707:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 708:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 709:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 710:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 711:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param trigger Data points update trigger
 712:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param frequency Waveform frequency in [Hz]
 713:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 714:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return XMC_DAC_CH_STATUS_t status
 715:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 716:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 717:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the \e channel to Noise mode. Trigger and frequency are configured.
 718:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * On a \e trigger the DAC starts converting and drives to \e channel output.
 719:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 720:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 721:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_Init()\n\n\n
 722:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 723:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 724:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** XMC_DAC_CH_STATUS_t XMC_DAC_CH_StartNoiseMode(XMC_DAC_t *const dac,
 725:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint8_t channel,
 726:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const XMC_DAC_CH_TRIGGER_t trigger,
 727:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint32_t frequency);
 728:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 729:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 730:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 731:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 732:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param pattern Pointer to the data table
 733:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 734:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 735:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 736:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 737:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The data for the Pattern mode is written to the \a DAC0PATL and \a DAC0PATH registers.
 738:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The API is called by XMC_DAC_CH_StartPatternMode().
 739:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 740:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 741:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call this API if the \a channel is set to Pattern mode.
 742:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 743:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 744:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_EnablePatternSignOutput(), XMC_DAC_CH_DisablePatternSignOutput()\n\n\n
 745:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 746:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 747:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** void XMC_DAC_CH_SetPattern(XMC_DAC_t *const dac, const uint8_t channel, const uint8_t *const patter
 748:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 749:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 750:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 751:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 752:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 753:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 754:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 755:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 756:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Enables the output sign information for Pattern Mode.
 757:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 758:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 759:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sign output is enabled by setting \a SIGNEN bit of \a DAC0CFG0 register (for channel 0) / DAC1CF
 760:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 761:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 762:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call this API if the \e channel is set to Pattern mode.
 763:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 764:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 765:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_StartPatternMode(), XMC_DAC_CH_DisablePatternSignOutput()\n\n\n
 766:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 767:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 768:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_EnablePatternSignOutput(XMC_DAC_t *const dac,
 769:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint8_t channel)
 770:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 771:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_EnablePatternSignOutput: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(
 772:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_EnablePatternSignOutput: channel parameter not valid\n", XMC_DAC_IS_CHANNE
 773:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 774:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].low |= DAC_DAC0CFG0_SIGNEN_Msk;
 775:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 776:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 777:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 778:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 779:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 780:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 781:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 782:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 783:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 784:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Disables output sign information for Pattern Mode.
 785:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 786:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 787:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sign output is disabled by clearing \a SIGNEN bit of \a DAC0CFG0 register (for channel 0) / DAC1
 788:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 789:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 790:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call this API if the \e channel is set to Pattern mode.
 791:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 792:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 793:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_StartPatternMode(), XMC_DAC_CH_EnablePatternSignOutput()\n\n\n
 794:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 795:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 796:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_DisablePatternSignOutput(XMC_DAC_t *const dac,
 797:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint8_t channel)
 798:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 799:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_DisablePatternSignOutput: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID
 800:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_DisablePatternSignOutput: channel parameter not valid\n", XMC_DAC_IS_CHANN
 801:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 802:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].low &= ~DAC_DAC0CFG0_SIGNEN_Msk;
 803:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 804:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 805:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 806:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 807:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 808:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param start Ramp start point [0-4095]
 809:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 810:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 811:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 812:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 813:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the ramp start value by writing to the register \a DAC0DATA (for \e channel 0) or \a DAC1DA
 814:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * If the ramp counter reaches its stop value, it restarts from the \a start value with the next tr
 815:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Ensure \e start value is lower than the stop value.
 816:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 817:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 818:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call this API if the \a channel is set to Ramp mode.
 819:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Start value is a 12 bit data.
 820:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 821:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 822:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_GetRampStart(), XMC_DAC_CH_GetRampStop(), XMC_DAC_CH_SetRampStop()\n\n\n
 823:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 824:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 825:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_SetRampStart(XMC_DAC_t *const dac, const uint8_t channel, const uin
 826:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 174              	 .loc 1 826 0
 175              	 .cfi_startproc
 176              	 
 177              	 
 178              	 
 179 0000 80B4     	 push {r7}
 180              	.LCFI18:
 181              	 .cfi_def_cfa_offset 4
 182              	 .cfi_offset 7,-4
 183 0002 83B0     	 sub sp,sp,#12
 184              	.LCFI19:
 185              	 .cfi_def_cfa_offset 16
 186 0004 00AF     	 add r7,sp,#0
 187              	.LCFI20:
 188              	 .cfi_def_cfa_register 7
 189 0006 7860     	 str r0,[r7,#4]
 190 0008 0B46     	 mov r3,r1
 191 000a FB70     	 strb r3,[r7,#3]
 192 000c 1346     	 mov r3,r2
 193 000e 3B80     	 strh r3,[r7]
 827:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetRampStart: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
 828:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetRampStart: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(cha
 829:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 830:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACDATA[channel] = start;
 194              	 .loc 1 830 0
 195 0010 FB78     	 ldrb r3,[r7,#3]
 196 0012 3A88     	 ldrh r2,[r7]
 197 0014 7968     	 ldr r1,[r7,#4]
 198 0016 0433     	 adds r3,r3,#4
 199 0018 9B00     	 lsls r3,r3,#2
 200 001a 0B44     	 add r3,r3,r1
 201 001c 5A60     	 str r2,[r3,#4]
 831:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 202              	 .loc 1 831 0
 203 001e 0C37     	 adds r7,r7,#12
 204              	.LCFI21:
 205              	 .cfi_def_cfa_offset 4
 206 0020 BD46     	 mov sp,r7
 207              	.LCFI22:
 208              	 .cfi_def_cfa_register 13
 209              	 
 210 0022 5DF8047B 	 ldr r7,[sp],#4
 211              	.LCFI23:
 212              	 .cfi_restore 7
 213              	 .cfi_def_cfa_offset 0
 214 0026 7047     	 bx lr
 215              	 .cfi_endproc
 216              	.LFE142:
 218              	 .section .text.XMC_DAC_CH_SetRampStop,"ax",%progbits
 219              	 .align 2
 220              	 .thumb
 221              	 .thumb_func
 223              	XMC_DAC_CH_SetRampStop:
 224              	.LFB144:
 832:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 833:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 834:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 835:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 836:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 837:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return uint16_t
 838:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 839:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 840:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Gets the ramp start value by reading \a DATA0 bit-field of \a DAC0DATA register (for channel 0) 
 841:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * If the ramp counter reaches its stop value, it restarts from the start value with the next trigg
 842:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 843:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 844:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call this API if the \e channel is set to Ramp mode.
 845:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 846:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 847:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_SetRampStart(), XMC_DAC_CH_StartRampMode(), XMC_DAC_CH_GetRampStop(), XMC_DAC_CH_SetR
 848:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 849:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 850:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE uint16_t XMC_DAC_CH_GetRampStart(XMC_DAC_t *const dac, const uint8_t channel)
 851:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 852:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_GetRampStart: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
 853:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_GetRampStart: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(cha
 854:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 855:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   return (uint16_t)(dac->DACDATA[channel]);
 856:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 857:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 858:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 859:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 860:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 861:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param stop Ramp stop point [0-4095]
 862:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 863:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 864:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 865:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 866:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the ramp stop value by writing to the bit-field \a DATA0 (for \e channel 0) or \a DATA1 (fo
 867:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * If the ramp counter reaches its \a stop value, it restarts from the start value with the next tr
 868:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Ensure \e stop value is higher than the start value.
 869:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 870:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 871:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call this API if the \e channel is set to Ramp mode.
 872:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Stop value is a 12 bit data.
 873:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 874:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 875:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_GetRampStop(), XMC_DAC_CH_SetRampStart()\n\n\n
 876:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 877:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 878:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_SetRampStop(XMC_DAC_t *const dac, const uint8_t channel, const uint
 879:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 225              	 .loc 1 879 0
 226              	 .cfi_startproc
 227              	 
 228              	 
 229              	 
 230 0000 80B4     	 push {r7}
 231              	.LCFI24:
 232              	 .cfi_def_cfa_offset 4
 233              	 .cfi_offset 7,-4
 234 0002 83B0     	 sub sp,sp,#12
 235              	.LCFI25:
 236              	 .cfi_def_cfa_offset 16
 237 0004 00AF     	 add r7,sp,#0
 238              	.LCFI26:
 239              	 .cfi_def_cfa_register 7
 240 0006 7860     	 str r0,[r7,#4]
 241 0008 0B46     	 mov r3,r1
 242 000a FB70     	 strb r3,[r7,#3]
 243 000c 1346     	 mov r3,r2
 244 000e 3B80     	 strh r3,[r7]
 880:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetRampStop: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
 881:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetRampStop: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(chan
 882:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 883:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DAC01DATA = (dac->DAC01DATA & ~(DAC_DAC01DATA_DATA0_Msk << (channel * DAC_DAC01DATA_DATA1_Po
 245              	 .loc 1 883 0
 246 0010 7B68     	 ldr r3,[r7,#4]
 247 0012 DA69     	 ldr r2,[r3,#28]
 248 0014 FB78     	 ldrb r3,[r7,#3]
 249 0016 1B01     	 lsls r3,r3,#4
 250 0018 1946     	 mov r1,r3
 251 001a 40F6FF73 	 movw r3,#4095
 252 001e 8B40     	 lsls r3,r3,r1
 253 0020 DB43     	 mvns r3,r3
 254 0022 1340     	 ands r3,r3,r2
 884:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                    (stop << (channel * DAC_DAC01DATA_DATA1_Pos));
 255              	 .loc 1 884 0
 256 0024 3A88     	 ldrh r2,[r7]
 257 0026 F978     	 ldrb r1,[r7,#3]
 258 0028 0901     	 lsls r1,r1,#4
 259 002a 8A40     	 lsls r2,r2,r1
 883:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                    (stop << (channel * DAC_DAC01DATA_DATA1_Pos));
 260              	 .loc 1 883 0
 261 002c 1A43     	 orrs r2,r2,r3
 262 002e 7B68     	 ldr r3,[r7,#4]
 263 0030 DA61     	 str r2,[r3,#28]
 885:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 264              	 .loc 1 885 0
 265 0032 0C37     	 adds r7,r7,#12
 266              	.LCFI27:
 267              	 .cfi_def_cfa_offset 4
 268 0034 BD46     	 mov sp,r7
 269              	.LCFI28:
 270              	 .cfi_def_cfa_register 13
 271              	 
 272 0036 5DF8047B 	 ldr r7,[sp],#4
 273              	.LCFI29:
 274              	 .cfi_restore 7
 275              	 .cfi_def_cfa_offset 0
 276 003a 7047     	 bx lr
 277              	 .cfi_endproc
 278              	.LFE144:
 280              	 .section .text.XMC_DAC_CH_SetMode,"ax",%progbits
 281              	 .align 2
 282              	 .thumb
 283              	 .thumb_func
 285              	XMC_DAC_CH_SetMode:
 286              	.LFB148:
 886:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 887:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 888:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 889:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 890:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 891:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return uint16_t
 892:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 893:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 894:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Gets the ramp stop value by reading \a DATA0 bit-field of \a DAC01DATA register (for channel 0) 
 895:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * If the ramp counter reaches its stop value, it restarts from the start value with the next trigg
 896:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 897:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 898:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call this API if the \e channel is set to Ramp mode.
 899:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 900:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 901:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_SetRampStop(), XMC_DAC_CH_StartRampMode(), XMC_DAC_CH_GetRampStart()\n\n\n
 902:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 903:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 904:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE uint16_t XMC_DAC_CH_GetRampStop(XMC_DAC_t *const dac, const uint8_t channel)
 905:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 906:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_GetRampStop: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
 907:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_GetRampStop: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(chan
 908:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 909:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   return ((dac->DAC01DATA >> (channel * DAC_DAC01DATA_DATA1_Pos)) & DAC_DAC01DATA_DATA0_Msk);
 910:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 911:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 912:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 913:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 914:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 915:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param trigger Trigger source
 916:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 917:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
 918:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 919:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 920:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Selects the \e trigger source for the \e channel by configuring the bits TRIGSEL & TRIGMOD of CF
 921:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 922:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 923:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Channel \a channel trigger source is selected by \a TRIGSEL bit-field of \a DAC0CFG1 register (f
 924:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 925:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 926:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_SetTrigger(XMC_DAC_t *const dac, const uint8_t channel, const XMC_D
 927:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 928:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetTrigger: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
 929:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetTrigger: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(chann
 930:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetTrigger: trigger parameter not valid\n", XMC_DAC_IS_TRIGGER_VALID(trigg
 931:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 932:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].high = (dac->DACCFG[channel].high & ~(DAC_DAC0CFG1_TRIGSEL_Msk | DAC_DAC0CFG
 933:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                               trigger;
 934:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 935:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 936:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 937:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 938:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 939:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param frequency Waveform frequency in [Hz]
 940:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 941:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return XMC_DAC_CH_STATUS_t
 942:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 943:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 944:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the \e frequency of DAC channel.
 945:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 946:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 947:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The value \e frequency acts as clock divider. The smallest \e frequency divider value is 16.
 948:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * A valid \e frequency value should be within the range XMC_DAC_MIN_FREQ_DIVIDER to XMC_DAC_MAX_FR
 949:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Frequency \a frequency is configured by setting \a FREQ bit-field of \a DAC0CFG0 register (for c
 950:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 951:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 952:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call this API only for Single value mode, Data mode and Noise mode.
 953:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call XMC_DAC_CH_SetRampFrequency() in case of Ramp mode and XMC_DAC_CH_SetPatternFrequency() in 
 954:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 955:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 956:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_SetRampFrequency(), XMC_DAC_CH_SetPatternFrequency()\n\n\n
 957:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 958:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 959:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** XMC_DAC_CH_STATUS_t XMC_DAC_CH_SetFrequency(XMC_DAC_t *const dac, const uint8_t channel, const uint
 960:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 961:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 962:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 963:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 964:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param frequency [Hz]
 965:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 966:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return XMC_DAC_CH_STATUS_t
 967:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 968:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 969:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the \e frequency of DAC channel by calling XMC_DAC_CH_SetFrequency().
 970:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 971:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 972:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * For the Ramp mode, the \a frequency of operation depends on the total number of sample points (\
 973:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Frequency \e frequency is multiplied by the total number of sample points, so that each trigger 
 974:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 975:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 976:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call this API only if the \a channel is set to Ramp mode.
 977:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 978:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
 979:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_StartRampMode()\n\n\n
 980:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 981:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
 982:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** XMC_DAC_CH_STATUS_t XMC_DAC_CH_SetRampFrequency(XMC_DAC_t *const dac, const uint8_t channel, const 
 983:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
 984:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
 985:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
 986:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
 987:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param frequency in [Hz]
 988:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 989:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return XMC_DAC_CH_STATUS_t
 990:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 991:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
 992:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the \e frequency of DAC channel by calling XMC_DAC_CH_SetFrequency().
 993:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 994:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
 995:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * For the Pattern mode, the \a frequency of operation depends on the total number of sample points
 996:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Frequency \e frequency is multiplied by the total number of sample points, so that each trigger 
 997:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
 998:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
 999:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Call this API only if the \a channel is set to Pattern mode.
1000:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1001:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
1002:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_StartPatternMode()\n\n\n
1003:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1004:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1005:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE XMC_DAC_CH_STATUS_t XMC_DAC_CH_SetPatternFrequency(XMC_DAC_t *const dac,
1006:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint8_t channel,
1007:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****     const uint32_t frequency)
1008:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
1009:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetPatternFrequency: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac)
1010:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetPatternFrequency: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VA
1011:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1012:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   return XMC_DAC_CH_SetFrequency(dac, channel, frequency * XMC_DAC_SAMPLES_PER_PERIOD);
1013:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
1014:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1015:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
1016:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
1017:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
1018:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param mode DAC operation mode
1019:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1020:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
1021:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1022:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
1023:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the operating \e mode for the \e channel by setting the \a MODE bit-field of \a DAC0CFG0 re
1024:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Different modes of DAC operation are defined by enum XMC_DAC_CH_MODE_t.
1025:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1026:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1027:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_SetMode(XMC_DAC_t *const dac, const uint8_t channel, const XMC_DAC_
1028:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 287              	 .loc 1 1028 0
 288              	 .cfi_startproc
 289              	 
 290              	 
 291              	 
 292 0000 80B4     	 push {r7}
 293              	.LCFI30:
 294              	 .cfi_def_cfa_offset 4
 295              	 .cfi_offset 7,-4
 296 0002 85B0     	 sub sp,sp,#20
 297              	.LCFI31:
 298              	 .cfi_def_cfa_offset 24
 299 0004 00AF     	 add r7,sp,#0
 300              	.LCFI32:
 301              	 .cfi_def_cfa_register 7
 302 0006 F860     	 str r0,[r7,#12]
 303 0008 0B46     	 mov r3,r1
 304 000a 7A60     	 str r2,[r7,#4]
 305 000c FB72     	 strb r3,[r7,#11]
1029:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetMode: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
1030:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetMode: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(channel)
1031:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetMode: trigger parameter not valid\n", XMC_DAC_IS_MODE_VALID(mode));
1032:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1033:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].low = (dac->DACCFG[channel].low & ~DAC_DAC0CFG0_MODE_Msk) |
 306              	 .loc 1 1033 0
 307 000e F87A     	 ldrb r0,[r7,#11]
 308 0010 FB7A     	 ldrb r3,[r7,#11]
 309 0012 FA68     	 ldr r2,[r7,#12]
 310 0014 DB00     	 lsls r3,r3,#3
 311 0016 1344     	 add r3,r3,r2
 312 0018 5B68     	 ldr r3,[r3,#4]
 313 001a 23F4E002 	 bic r2,r3,#7340032
 314 001e 7B68     	 ldr r3,[r7,#4]
 315 0020 1A43     	 orrs r2,r2,r3
 316 0022 F968     	 ldr r1,[r7,#12]
 317 0024 C300     	 lsls r3,r0,#3
 318 0026 0B44     	 add r3,r3,r1
 319 0028 5A60     	 str r2,[r3,#4]
1034:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                              mode;
1035:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 320              	 .loc 1 1035 0
 321 002a 1437     	 adds r7,r7,#20
 322              	.LCFI33:
 323              	 .cfi_def_cfa_offset 4
 324 002c BD46     	 mov sp,r7
 325              	.LCFI34:
 326              	 .cfi_def_cfa_register 13
 327              	 
 328 002e 5DF8047B 	 ldr r7,[sp],#4
 329              	.LCFI35:
 330              	 .cfi_restore 7
 331              	 .cfi_def_cfa_offset 0
 332 0032 7047     	 bx lr
 333              	 .cfi_endproc
 334              	.LFE148:
 336              	 .section .text.XMC_DAC_CH_EnableEvent,"ax",%progbits
 337              	 .align 2
 338              	 .thumb
 339              	 .thumb_func
 341              	XMC_DAC_CH_EnableEvent:
 342              	.LFB152:
1036:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1037:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
1038:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
1039:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
1040:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1041:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
1042:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1043:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
1044:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the \e channel's data to signed type by setting \a SIGN bit of \a DAC0CFG0 register (for ch
1045:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The data for the conversion would then be treated as signed data type.
1046:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1047:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
1048:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Offset and scaling can be applied to the data by calling XMC_DAC_CH_SetOutputOffset(), XMC_DAC_C
1049:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1050:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
1051:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_SetUnsignedDataType()\n\n\n
1052:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1053:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1054:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_SetSignedDataType(XMC_DAC_t *const dac, const uint8_t channel)
1055:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
1056:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetSignedDataType: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
1057:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetSignedDataType: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALI
1058:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1059:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].low |= (DAC_DAC0CFG0_SIGN_Msk);
1060:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
1061:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1062:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
1063:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
1064:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
1065:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1066:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
1067:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1068:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
1069:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the \e channel's data to unsigned type by clearing \a SIGN bit of \a DAC0CFG0 register (for
1070:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The data for the conversion would then be treated as unsigned data type.
1071:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1072:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
1073:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Offset and scaling can be applied to the data by calling XMC_DAC_CH_SetOutputOffset(), XMC_DAC_C
1074:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1075:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
1076:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_SetSignedDataType()\n\n\n
1077:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1078:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1079:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_SetUnsignedDataType(XMC_DAC_t *const dac, const uint8_t channel)
1080:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
1081:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetUnsignedDataType: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac)
1082:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetUnsignedDataType: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VA
1083:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1084:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].low &= ~(DAC_DAC0CFG0_SIGN_Msk);
1085:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
1086:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1087:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
1088:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
1089:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
1090:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1091:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
1092:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1093:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
1094:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * A call to this API generates a trigger pulse by setting \a SWTRIG bit of \a DAC0CFG1 register (f
1095:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * provided the \a TRIGMOD bit of CFG register is set to \a XMC_DAC_CH_TRIGGER_SOFTWARE.
1096:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1097:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
1098:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * If the \e channel is set to simultaneous data mode, SWTRIG bit of \e channel 1 is not valid.
1099:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Only \a SWTRIG bit of channel 0 is used for channel 1.
1100:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1101:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
1102:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_SetTrigger(), XMC_DAC_CH_EnableEvent()\n\n\n
1103:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1104:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1105:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_SoftwareTrigger(XMC_DAC_t *const dac, const uint8_t channel)
1106:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
1107:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SoftwareTrigger: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
1108:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SoftwareTrigger: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(
1109:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1110:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].high |= DAC_DAC0CFG1_SWTRIG_Msk;
1111:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
1112:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1113:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
1114:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
1115:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
1116:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1117:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
1118:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1119:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
1120:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Enables service request by setting \a SREN bit of \a DAC0CFG0 register (for channel 0) / \a DAC1
1121:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Trigger signal is generated upon conversion of each data.
1122:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1123:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
1124:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The service request signal can be connected to NVIC, DMA.\n
1125:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1126:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
1127:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_DisableEvent()\n\n\n
1128:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1129:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1130:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_EnableEvent(XMC_DAC_t *const dac, const uint8_t channel)
1131:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 343              	 .loc 1 1131 0
 344              	 .cfi_startproc
 345              	 
 346              	 
 347              	 
 348 0000 80B4     	 push {r7}
 349              	.LCFI36:
 350              	 .cfi_def_cfa_offset 4
 351              	 .cfi_offset 7,-4
 352 0002 83B0     	 sub sp,sp,#12
 353              	.LCFI37:
 354              	 .cfi_def_cfa_offset 16
 355 0004 00AF     	 add r7,sp,#0
 356              	.LCFI38:
 357              	 .cfi_def_cfa_register 7
 358 0006 7860     	 str r0,[r7,#4]
 359 0008 0B46     	 mov r3,r1
 360 000a FB70     	 strb r3,[r7,#3]
1132:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_EnableEvent: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
1133:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_EnableEvent: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(chan
1134:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1135:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].low |= DAC_DAC0CFG0_SREN_Msk;
 361              	 .loc 1 1135 0
 362 000c F878     	 ldrb r0,[r7,#3]
 363 000e FB78     	 ldrb r3,[r7,#3]
 364 0010 7A68     	 ldr r2,[r7,#4]
 365 0012 DB00     	 lsls r3,r3,#3
 366 0014 1344     	 add r3,r3,r2
 367 0016 5B68     	 ldr r3,[r3,#4]
 368 0018 43F08042 	 orr r2,r3,#1073741824
 369 001c 7968     	 ldr r1,[r7,#4]
 370 001e C300     	 lsls r3,r0,#3
 371 0020 0B44     	 add r3,r3,r1
 372 0022 5A60     	 str r2,[r3,#4]
1136:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 373              	 .loc 1 1136 0
 374 0024 0C37     	 adds r7,r7,#12
 375              	.LCFI39:
 376              	 .cfi_def_cfa_offset 4
 377 0026 BD46     	 mov sp,r7
 378              	.LCFI40:
 379              	 .cfi_def_cfa_register 13
 380              	 
 381 0028 5DF8047B 	 ldr r7,[sp],#4
 382              	.LCFI41:
 383              	 .cfi_restore 7
 384              	 .cfi_def_cfa_offset 0
 385 002c 7047     	 bx lr
 386              	 .cfi_endproc
 387              	.LFE152:
 389 002e 00BF     	 .section .text.XMC_DAC_CH_SetOutputOffset,"ax",%progbits
 390              	 .align 2
 391              	 .thumb
 392              	 .thumb_func
 394              	XMC_DAC_CH_SetOutputOffset:
 395              	.LFB154:
1137:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1138:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
1139:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
1140:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
1141:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1142:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
1143:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1144:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
1145:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Disables service request by clearing \a SREN bit of \a DAC0CFG0 register (for channel 0) / \a DA
1146:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1147:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
1148:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_EnableEvent()\n\n\n
1149:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1150:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1151:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_DisableEvent(XMC_DAC_t *const dac, const uint8_t channel)
1152:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
1153:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_DisableEvent: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
1154:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_DisableEvent: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(cha
1155:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1156:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].low &= ~DAC_DAC0CFG0_SREN_Msk;
1157:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
1158:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1159:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
1160:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
1161:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
1162:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param offset
1163:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1164:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
1165:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1166:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
1167:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Sets the offset value.\n
1168:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Offset range:0 - 255\n
1169:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * interpreted as : -128 to 127 (twos complement) in signed mode and 0 to 255 in unsigned mode.
1170:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1171:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
1172:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Scaling can be applied to the output data after adding the \e offset value.
1173:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1174:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
1175:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Channel \a channel \a offset value is loaded to the bit-field \a DAC0CFG1 register (for channel 
1176:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1177:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
1178:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_SetOutputScale()\n\n\n
1179:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1180:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1181:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_SetOutputOffset(XMC_DAC_t *const dac, const uint8_t channel, const 
1182:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 396              	 .loc 1 1182 0
 397              	 .cfi_startproc
 398              	 
 399              	 
 400              	 
 401 0000 80B4     	 push {r7}
 402              	.LCFI42:
 403              	 .cfi_def_cfa_offset 4
 404              	 .cfi_offset 7,-4
 405 0002 83B0     	 sub sp,sp,#12
 406              	.LCFI43:
 407              	 .cfi_def_cfa_offset 16
 408 0004 00AF     	 add r7,sp,#0
 409              	.LCFI44:
 410              	 .cfi_def_cfa_register 7
 411 0006 7860     	 str r0,[r7,#4]
 412 0008 0B46     	 mov r3,r1
 413 000a FB70     	 strb r3,[r7,#3]
 414 000c 1346     	 mov r3,r2
 415 000e BB70     	 strb r3,[r7,#2]
1183:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetOutputOffset: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
1184:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetOutputOffset: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(
1185:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1186:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].high = (dac->DACCFG[channel].high & ~DAC_DAC0CFG1_OFFS_Msk) |
 416              	 .loc 1 1186 0
 417 0010 F878     	 ldrb r0,[r7,#3]
 418 0012 FB78     	 ldrb r3,[r7,#3]
 419 0014 7A68     	 ldr r2,[r7,#4]
 420 0016 DB00     	 lsls r3,r3,#3
 421 0018 1344     	 add r3,r3,r2
 422 001a 9B68     	 ldr r3,[r3,#8]
 423 001c 23F47F63 	 bic r3,r3,#4080
1187:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                               offset << DAC_DAC0CFG1_OFFS_Pos;
 424              	 .loc 1 1187 0
 425 0020 BA78     	 ldrb r2,[r7,#2]
 426 0022 1201     	 lsls r2,r2,#4
1186:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                               offset << DAC_DAC0CFG1_OFFS_Pos;
 427              	 .loc 1 1186 0
 428 0024 1A43     	 orrs r2,r2,r3
 429 0026 7968     	 ldr r1,[r7,#4]
 430 0028 C300     	 lsls r3,r0,#3
 431 002a 0B44     	 add r3,r3,r1
 432 002c 9A60     	 str r2,[r3,#8]
1188:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 433              	 .loc 1 1188 0
 434 002e 0C37     	 adds r7,r7,#12
 435              	.LCFI45:
 436              	 .cfi_def_cfa_offset 4
 437 0030 BD46     	 mov sp,r7
 438              	.LCFI46:
 439              	 .cfi_def_cfa_register 13
 440              	 
 441 0032 5DF8047B 	 ldr r7,[sp],#4
 442              	.LCFI47:
 443              	 .cfi_restore 7
 444              	 .cfi_def_cfa_offset 0
 445 0036 7047     	 bx lr
 446              	 .cfi_endproc
 447              	.LFE154:
 449              	 .section .text.XMC_DAC_CH_SetOutputScale,"ax",%progbits
 450              	 .align 2
 451              	 .thumb
 452              	 .thumb_func
 454              	XMC_DAC_CH_SetOutputScale:
 455              	.LFB155:
1189:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1190:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
1191:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
1192:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
1193:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param scale Input data scaling
1194:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1195:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return None
1196:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1197:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
1198:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Data of the \e channel is scaled.
1199:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1200:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
1201:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The data can either be scaled up-scaled (multiplied), down-scaled (divided) or no scaling (as is
1202:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Scaling is configured by setting bit-fields \a MULDIV and \a SCALE of \a DAC0CFG1 register (for 
1203:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1204:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
1205:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_GetOutputScale()\n\n\n
1206:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1207:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1208:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_SetOutputScale(XMC_DAC_t *const dac, const uint8_t channel, const X
1209:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 456              	 .loc 1 1209 0
 457              	 .cfi_startproc
 458              	 
 459              	 
 460              	 
 461 0000 80B4     	 push {r7}
 462              	.LCFI48:
 463              	 .cfi_def_cfa_offset 4
 464              	 .cfi_offset 7,-4
 465 0002 83B0     	 sub sp,sp,#12
 466              	.LCFI49:
 467              	 .cfi_def_cfa_offset 16
 468 0004 00AF     	 add r7,sp,#0
 469              	.LCFI50:
 470              	 .cfi_def_cfa_register 7
 471 0006 7860     	 str r0,[r7,#4]
 472 0008 0B46     	 mov r3,r1
 473 000a FB70     	 strb r3,[r7,#3]
 474 000c 1346     	 mov r3,r2
 475 000e BB70     	 strb r3,[r7,#2]
1210:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetOutputScale: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
1211:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetOutputScale: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(c
1212:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_SetOutputScale: scale parameter not valid\n", XMC_DAC_IS_OUTPUT_SCALE_VALI
1213:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1214:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].high = (dac->DACCFG[channel].high & ~(DAC_DAC0CFG1_MULDIV_Msk | DAC_DAC0CFG1
 476              	 .loc 1 1214 0
 477 0010 F878     	 ldrb r0,[r7,#3]
 478 0012 FB78     	 ldrb r3,[r7,#3]
 479 0014 7A68     	 ldr r2,[r7,#4]
 480 0016 DB00     	 lsls r3,r3,#3
 481 0018 1344     	 add r3,r3,r2
 482 001a 9B68     	 ldr r3,[r3,#8]
 483 001c 23F00F02 	 bic r2,r3,#15
 484 0020 BB78     	 ldrb r3,[r7,#2]
 485 0022 1A43     	 orrs r2,r2,r3
 486 0024 7968     	 ldr r1,[r7,#4]
 487 0026 C300     	 lsls r3,r0,#3
 488 0028 0B44     	 add r3,r3,r1
 489 002a 9A60     	 str r2,[r3,#8]
1215:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****                               scale;
1216:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 490              	 .loc 1 1216 0
 491 002c 0C37     	 adds r7,r7,#12
 492              	.LCFI51:
 493              	 .cfi_def_cfa_offset 4
 494 002e BD46     	 mov sp,r7
 495              	.LCFI52:
 496              	 .cfi_def_cfa_register 13
 497              	 
 498 0030 5DF8047B 	 ldr r7,[sp],#4
 499              	.LCFI53:
 500              	 .cfi_restore 7
 501              	 .cfi_def_cfa_offset 0
 502 0034 7047     	 bx lr
 503              	 .cfi_endproc
 504              	.LFE155:
 506 0036 00BF     	 .section .text.XMC_DAC_CH_GetOutputScale,"ax",%progbits
 507              	 .align 2
 508              	 .thumb
 509              	 .thumb_func
 511              	XMC_DAC_CH_GetOutputScale:
 512              	.LFB156:
1217:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1218:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
1219:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
1220:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
1221:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1222:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @return XMC_DAC_CH_OUTPUT_SCALE_t
1223:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1224:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
1225:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Returns scaling information for the data.
1226:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * The input data could be either up-scaled (multiplied), down-scaled (divided) or without scaling 
1227:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Scaling factor is determined by reading bit-fields \a MULDIV and \a SCALE of \a DAC0CFG1 registe
1228:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1229:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
1230:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_SetOutputScale()\n\n\n
1231:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1232:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1233:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE XMC_DAC_CH_OUTPUT_SCALE_t XMC_DAC_CH_GetOutputScale(XMC_DAC_t *const dac, const uin
1234:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 513              	 .loc 1 1234 0
 514              	 .cfi_startproc
 515              	 
 516              	 
 517              	 
 518 0000 80B4     	 push {r7}
 519              	.LCFI54:
 520              	 .cfi_def_cfa_offset 4
 521              	 .cfi_offset 7,-4
 522 0002 83B0     	 sub sp,sp,#12
 523              	.LCFI55:
 524              	 .cfi_def_cfa_offset 16
 525 0004 00AF     	 add r7,sp,#0
 526              	.LCFI56:
 527              	 .cfi_def_cfa_register 7
 528 0006 7860     	 str r0,[r7,#4]
 529 0008 0B46     	 mov r3,r1
 530 000a FB70     	 strb r3,[r7,#3]
1235:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_GetOutputScale: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac));
1236:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_GetOutputScale: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_VALID(c
1237:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1238:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   return (XMC_DAC_CH_OUTPUT_SCALE_t)(dac->DACCFG[channel].high & (DAC_DAC0CFG1_MULDIV_Msk | DAC_DAC
 531              	 .loc 1 1238 0
 532 000c FB78     	 ldrb r3,[r7,#3]
 533 000e 7A68     	 ldr r2,[r7,#4]
 534 0010 DB00     	 lsls r3,r3,#3
 535 0012 1344     	 add r3,r3,r2
 536 0014 9B68     	 ldr r3,[r3,#8]
 537 0016 DBB2     	 uxtb r3,r3
 538 0018 03F00F03 	 and r3,r3,#15
 539 001c DBB2     	 uxtb r3,r3
1239:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 540              	 .loc 1 1239 0
 541 001e 1846     	 mov r0,r3
 542 0020 0C37     	 adds r7,r7,#12
 543              	.LCFI57:
 544              	 .cfi_def_cfa_offset 4
 545 0022 BD46     	 mov sp,r7
 546              	.LCFI58:
 547              	 .cfi_def_cfa_register 13
 548              	 
 549 0024 5DF8047B 	 ldr r7,[sp],#4
 550              	.LCFI59:
 551              	 .cfi_restore 7
 552              	 .cfi_def_cfa_offset 0
 553 0028 7047     	 bx lr
 554              	 .cfi_endproc
 555              	.LFE156:
 557 002a 00BF     	 .section .text.XMC_DAC_CH_EnableOutputNegation,"ax",%progbits
 558              	 .align 2
 559              	 .thumb
 560              	 .thumb_func
 562              	XMC_DAC_CH_EnableOutputNegation:
 563              	.LFB157:
1240:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1241:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
1242:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
1243:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
1244:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1245:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
1246:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Enables output negation.
1247:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1248:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
1249:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * By negating the DAC value is converted to its two's complement values.
1250:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Can be used in Ramp mode to generate negative ramp.
1251:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Negation in enabled by setting \a NEGATE bit of \a DAC0CFG0 register (for channel 0) / \a DAC1CF
1252:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1253:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
1254:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Negation feature is not applicable for XMC45 devices. Calling this API in XMC45 devices doesn't 
1255:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1256:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
1257:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_DisableOutputNegation(), XMC_DAC_CH_StartRampMode()\n\n\n
1258:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1259:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1260:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_EnableOutputNegation(XMC_DAC_t *const dac, const uint8_t channel)
1261:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 564              	 .loc 1 1261 0
 565              	 .cfi_startproc
 566              	 
 567              	 
 568              	 
 569 0000 80B4     	 push {r7}
 570              	.LCFI60:
 571              	 .cfi_def_cfa_offset 4
 572              	 .cfi_offset 7,-4
 573 0002 83B0     	 sub sp,sp,#12
 574              	.LCFI61:
 575              	 .cfi_def_cfa_offset 16
 576 0004 00AF     	 add r7,sp,#0
 577              	.LCFI62:
 578              	 .cfi_def_cfa_register 7
 579 0006 7860     	 str r0,[r7,#4]
 580 0008 0B46     	 mov r3,r1
 581 000a FB70     	 strb r3,[r7,#3]
1262:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_EnableOutputNegation: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(dac
1263:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_EnableOutputNegation: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_V
1264:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1265:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].low |= XMC_DAC_DACCFG_NEGATE_Msk;
 582              	 .loc 1 1265 0
 583 000c F878     	 ldrb r0,[r7,#3]
 584 000e FB78     	 ldrb r3,[r7,#3]
 585 0010 7A68     	 ldr r2,[r7,#4]
 586 0012 DB00     	 lsls r3,r3,#3
 587 0014 1344     	 add r3,r3,r2
 588 0016 5B68     	 ldr r3,[r3,#4]
 589 0018 43F08052 	 orr r2,r3,#268435456
 590 001c 7968     	 ldr r1,[r7,#4]
 591 001e C300     	 lsls r3,r0,#3
 592 0020 0B44     	 add r3,r3,r1
 593 0022 5A60     	 str r2,[r3,#4]
1266:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 594              	 .loc 1 1266 0
 595 0024 0C37     	 adds r7,r7,#12
 596              	.LCFI63:
 597              	 .cfi_def_cfa_offset 4
 598 0026 BD46     	 mov sp,r7
 599              	.LCFI64:
 600              	 .cfi_def_cfa_register 13
 601              	 
 602 0028 5DF8047B 	 ldr r7,[sp],#4
 603              	.LCFI65:
 604              	 .cfi_restore 7
 605              	 .cfi_def_cfa_offset 0
 606 002c 7047     	 bx lr
 607              	 .cfi_endproc
 608              	.LFE157:
 610 002e 00BF     	 .section .text.XMC_DAC_CH_DisableOutputNegation,"ax",%progbits
 611              	 .align 2
 612              	 .thumb
 613              	 .thumb_func
 615              	XMC_DAC_CH_DisableOutputNegation:
 616              	.LFB158:
1267:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1268:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** /**
1269:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param dac Pointer to an instance of DAC module
1270:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * @param channel DAC channel number
1271:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1272:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Description:</b><br>
1273:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Disables output negation.
1274:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1275:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par
1276:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Negation is disabled by clearing \a NEGATE bit of \a DAC0CFG0 register (for channel 0) / \a DAC1
1277:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1278:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Note:</b><br>
1279:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * Negation feature is not applicable for XMC45 devices. Calling this API in XMC45 devices doesn't 
1280:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1281:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * \par<b>Related APIs:</b><BR>
1282:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  * XMC_DAC_CH_EnableOutputNegation()\n\n\n
1283:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  *
1284:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****  */
1285:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** __STATIC_INLINE void XMC_DAC_CH_DisableOutputNegation(XMC_DAC_t *const dac, const uint8_t channel)
1286:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** {
 617              	 .loc 1 1286 0
 618              	 .cfi_startproc
 619              	 
 620              	 
 621              	 
 622 0000 80B4     	 push {r7}
 623              	.LCFI66:
 624              	 .cfi_def_cfa_offset 4
 625              	 .cfi_offset 7,-4
 626 0002 83B0     	 sub sp,sp,#12
 627              	.LCFI67:
 628              	 .cfi_def_cfa_offset 16
 629 0004 00AF     	 add r7,sp,#0
 630              	.LCFI68:
 631              	 .cfi_def_cfa_register 7
 632 0006 7860     	 str r0,[r7,#4]
 633 0008 0B46     	 mov r3,r1
 634 000a FB70     	 strb r3,[r7,#3]
1287:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_DisableOutputNegation: dac parameter not valid\n", XMC_DAC_IS_DAC_VALID(da
1288:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   XMC_ASSERT("XMC_DAC_CH_DisableOutputNegation: channel parameter not valid\n", XMC_DAC_IS_CHANNEL_
1289:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** 
1290:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h ****   dac->DACCFG[channel].low &= ~XMC_DAC_DACCFG_NEGATE_Msk;
 635              	 .loc 1 1290 0
 636 000c F878     	 ldrb r0,[r7,#3]
 637 000e FB78     	 ldrb r3,[r7,#3]
 638 0010 7A68     	 ldr r2,[r7,#4]
 639 0012 DB00     	 lsls r3,r3,#3
 640 0014 1344     	 add r3,r3,r2
 641 0016 5B68     	 ldr r3,[r3,#4]
 642 0018 23F08052 	 bic r2,r3,#268435456
 643 001c 7968     	 ldr r1,[r7,#4]
 644 001e C300     	 lsls r3,r0,#3
 645 0020 0B44     	 add r3,r3,r1
 646 0022 5A60     	 str r2,[r3,#4]
1291:C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc\xmc_dac.h **** }
 647              	 .loc 1 1291 0
 648 0024 0C37     	 adds r7,r7,#12
 649              	.LCFI69:
 650              	 .cfi_def_cfa_offset 4
 651 0026 BD46     	 mov sp,r7
 652              	.LCFI70:
 653              	 .cfi_def_cfa_register 13
 654              	 
 655 0028 5DF8047B 	 ldr r7,[sp],#4
 656              	.LCFI71:
 657              	 .cfi_restore 7
 658              	 .cfi_def_cfa_offset 0
 659 002c 7047     	 bx lr
 660              	 .cfi_endproc
 661              	.LFE158:
 663 002e 00BF     	 .section .text.DAC_Ramp_ScaleUp,"ax",%progbits
 664              	 .align 2
 665              	 .global DAC_Ramp_ScaleUp
 666              	 .thumb
 667              	 .thumb_func
 669              	DAC_Ramp_ScaleUp:
 670              	.LFB223:
 671              	 .file 2 "../Dave/Generated/DAC/dac.c"
   1:../Dave/Generated/DAC/dac.c **** /**
   2:../Dave/Generated/DAC/dac.c ****  * @file dac.c
   3:../Dave/Generated/DAC/dac.c ****  * @date 2016-07-08
   4:../Dave/Generated/DAC/dac.c ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   5:../Dave/Generated/DAC/dac.c ****  * @cond
   6:../Dave/Generated/DAC/dac.c ****  **************************************************************************************************
   7:../Dave/Generated/DAC/dac.c ****  * DAC v4.0.18 - Generates Pattern, Noise and Ramp waveform. It can be used for single value and da
   8:../Dave/Generated/DAC/dac.c ****  *
   9:../Dave/Generated/DAC/dac.c ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  10:../Dave/Generated/DAC/dac.c ****  * All rights reserved.
  11:../Dave/Generated/DAC/dac.c ****  *
  12:../Dave/Generated/DAC/dac.c ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:../Dave/Generated/DAC/dac.c ****  * following conditions are met:
  14:../Dave/Generated/DAC/dac.c ****  *
  15:../Dave/Generated/DAC/dac.c ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  16:../Dave/Generated/DAC/dac.c ****  *   disclaimer.
  17:../Dave/Generated/DAC/dac.c ****  *
  18:../Dave/Generated/DAC/dac.c ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  19:../Dave/Generated/DAC/dac.c ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  20:../Dave/Generated/DAC/dac.c ****  *
  21:../Dave/Generated/DAC/dac.c ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  22:../Dave/Generated/DAC/dac.c ****  *   products derived from this software without specific prior written permission.
  23:../Dave/Generated/DAC/dac.c ****  *
  24:../Dave/Generated/DAC/dac.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:../Dave/Generated/DAC/dac.c ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:../Dave/Generated/DAC/dac.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:../Dave/Generated/DAC/dac.c ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:../Dave/Generated/DAC/dac.c ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:../Dave/Generated/DAC/dac.c ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:../Dave/Generated/DAC/dac.c ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31:../Dave/Generated/DAC/dac.c ****  *
  32:../Dave/Generated/DAC/dac.c ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:../Dave/Generated/DAC/dac.c ****  * with Infineon Technologies AG (dave@infineon.com).
  34:../Dave/Generated/DAC/dac.c ****  **************************************************************************************************
  35:../Dave/Generated/DAC/dac.c ****  *
  36:../Dave/Generated/DAC/dac.c ****  * Change History
  37:../Dave/Generated/DAC/dac.c ****  * --------------
  38:../Dave/Generated/DAC/dac.c ****  *
  39:../Dave/Generated/DAC/dac.c ****  * 2015-02-20:
  40:../Dave/Generated/DAC/dac.c ****  *     - Initial version
  41:../Dave/Generated/DAC/dac.c ****  *
  42:../Dave/Generated/DAC/dac.c ****  * 2015-06-20:
  43:../Dave/Generated/DAC/dac.c ****  *     - Single value mode service request option is given only when synchronize with clock option 
  44:../Dave/Generated/DAC/dac.c ****  *
  45:../Dave/Generated/DAC/dac.c ****  * 2015-09-02:
  46:../Dave/Generated/DAC/dac.c ****  *     - Included XMC42 and XMC48 condition for negate feature
  47:../Dave/Generated/DAC/dac.c ****  *
  48:../Dave/Generated/DAC/dac.c ****  * 2015-12-15:
  49:../Dave/Generated/DAC/dac.c ****  *     - ANALOG_IO APP Init function call added
  50:../Dave/Generated/DAC/dac.c ****  * 2016-07-08:
  51:../Dave/Generated/DAC/dac.c ****  *     - Fixed incorrect case for an included header.<br>
  52:../Dave/Generated/DAC/dac.c ****  *
  53:../Dave/Generated/DAC/dac.c ****  * @endcond
  54:../Dave/Generated/DAC/dac.c ****  *
  55:../Dave/Generated/DAC/dac.c ****  */
  56:../Dave/Generated/DAC/dac.c **** /**************************************************************************************************
  57:../Dave/Generated/DAC/dac.c ****  * HEADER FILES
  58:../Dave/Generated/DAC/dac.c ****  **************************************************************************************************
  59:../Dave/Generated/DAC/dac.c **** #include "dac.h"
  60:../Dave/Generated/DAC/dac.c **** 
  61:../Dave/Generated/DAC/dac.c **** /**************************************************************************************************
  62:../Dave/Generated/DAC/dac.c ****  * MACROS
  63:../Dave/Generated/DAC/dac.c ****  **************************************************************************************************
  64:../Dave/Generated/DAC/dac.c **** 
  65:../Dave/Generated/DAC/dac.c **** /**************************************************************************************************
  66:../Dave/Generated/DAC/dac.c ****  * LOCAL DATA
  67:../Dave/Generated/DAC/dac.c ****  **************************************************************************************************
  68:../Dave/Generated/DAC/dac.c **** 
  69:../Dave/Generated/DAC/dac.c **** /**************************************************************************************************
  70:../Dave/Generated/DAC/dac.c ****  * LOCAL ROUTINES
  71:../Dave/Generated/DAC/dac.c ****  **************************************************************************************************
  72:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_Ramp_ScaleUp(const DAC_t * const HandlePtr,
  73:../Dave/Generated/DAC/dac.c **** uint16_t start_ramp,uint16_t stop_ramp,uint32_t frequency_Hz);
  74:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_Ramp_ScaleDown(const DAC_t * const HandlePtr,
  75:../Dave/Generated/DAC/dac.c **** uint16_t start_ramp,uint16_t stop_ramp,uint32_t clk_divider);
  76:../Dave/Generated/DAC/dac.c **** void DAC_Ramp_StartStopConfigure(const DAC_t * const HandlePtr,uint16_t start_ramp,uint16_t stop_ra
  77:../Dave/Generated/DAC/dac.c **** /* This API will configure DAC mode depends upon the user configuration */
  78:../Dave/Generated/DAC/dac.c **** XMC_DAC_CH_STATUS_t DAC_ModeConfig(const DAC_t * const HandlePtr);
  79:../Dave/Generated/DAC/dac.c **** 
  80:../Dave/Generated/DAC/dac.c **** /**************************************************************************************************
  81:../Dave/Generated/DAC/dac.c **** * API IMPLEMENTATION
  82:../Dave/Generated/DAC/dac.c **** ***************************************************************************************************
  83:../Dave/Generated/DAC/dac.c **** /*
  84:../Dave/Generated/DAC/dac.c ****  * This API will set Ramp frequency by reducing wave points by scale up operation.
  85:../Dave/Generated/DAC/dac.c **** */
  86:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_Ramp_ScaleUp(const DAC_t * const HandlePtr,
  87:../Dave/Generated/DAC/dac.c **** uint16_t start_ramp,uint16_t stop_ramp,uint32_t frequency_Hz)
  88:../Dave/Generated/DAC/dac.c **** {
 672              	 .loc 2 88 0
 673              	 .cfi_startproc
 674              	 
 675              	 
 676 0000 80B5     	 push {r7,lr}
 677              	.LCFI72:
 678              	 .cfi_def_cfa_offset 8
 679              	 .cfi_offset 7,-8
 680              	 .cfi_offset 14,-4
 681 0002 8AB0     	 sub sp,sp,#40
 682              	.LCFI73:
 683              	 .cfi_def_cfa_offset 48
 684 0004 00AF     	 add r7,sp,#0
 685              	.LCFI74:
 686              	 .cfi_def_cfa_register 7
 687 0006 F860     	 str r0,[r7,#12]
 688 0008 7B60     	 str r3,[r7,#4]
 689 000a 0B46     	 mov r3,r1
 690 000c 7B81     	 strh r3,[r7,#10]
 691 000e 1346     	 mov r3,r2
 692 0010 3B81     	 strh r3,[r7,#8]
  89:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status = DAC_STATUS_SUCCESS;
 693              	 .loc 2 89 0
 694 0012 0023     	 movs r3,#0
 695 0014 87F82730 	 strb r3,[r7,#39]
  90:../Dave/Generated/DAC/dac.c ****   uint8_t shift_count = 0U;
 696              	 .loc 2 90 0
 697 0018 0023     	 movs r3,#0
 698 001a 87F82630 	 strb r3,[r7,#38]
  91:../Dave/Generated/DAC/dac.c ****   uint16_t temp_steps = (uint16_t)((stop_ramp - start_ramp) + 1U);
 699              	 .loc 2 91 0
 700 001e 3A89     	 ldrh r2,[r7,#8]
 701 0020 7B89     	 ldrh r3,[r7,#10]
 702 0022 D31A     	 subs r3,r2,r3
 703 0024 9BB2     	 uxth r3,r3
 704 0026 0133     	 adds r3,r3,#1
 705 0028 BB84     	 strh r3,[r7,#36]
  92:../Dave/Generated/DAC/dac.c ****   uint32_t peripheral_clock_freq_Hz = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
 706              	 .loc 2 92 0
 707 002a FFF7FEFF 	 bl XMC_SCU_CLOCK_GetPeripheralClockFrequency
 708 002e F861     	 str r0,[r7,#28]
  93:../Dave/Generated/DAC/dac.c ****   uint32_t temp_cal_freq = frequency_Hz * temp_steps;
 709              	 .loc 2 93 0
 710 0030 BB8C     	 ldrh r3,[r7,#36]
 711 0032 7A68     	 ldr r2,[r7,#4]
 712 0034 02FB03F3 	 mul r3,r2,r3
 713 0038 3B62     	 str r3,[r7,#32]
  94:../Dave/Generated/DAC/dac.c ****   uint32_t clk_divider;
  95:../Dave/Generated/DAC/dac.c ****   XMC_DAC_CH_OUTPUT_SCALE_t scale = XMC_DAC_CH_OUTPUT_SCALE_NONE;
 714              	 .loc 2 95 0
 715 003a 0023     	 movs r3,#0
 716 003c FB76     	 strb r3,[r7,#27]
  96:../Dave/Generated/DAC/dac.c **** 
  97:../Dave/Generated/DAC/dac.c ****   while((temp_cal_freq > DAC_MAX_FREQUENCY) && (status != DAC_STATUS_API_FAIL))
 717              	 .loc 2 97 0
 718 003e 40E0     	 b .L15
 719              	.L23:
  98:../Dave/Generated/DAC/dac.c ****   {
  99:../Dave/Generated/DAC/dac.c ****     if( DAC_RAMP_MIN_STEPS > temp_steps )
 720              	 .loc 2 99 0
 721 0040 BB8C     	 ldrh r3,[r7,#36]
 722 0042 022B     	 cmp r3,#2
 723 0044 03D8     	 bhi .L16
 100:../Dave/Generated/DAC/dac.c ****     {
 101:../Dave/Generated/DAC/dac.c ****       /* Frequency can't be configured */
 102:../Dave/Generated/DAC/dac.c ****       status = DAC_STATUS_API_FAIL;
 724              	 .loc 2 102 0
 725 0046 0223     	 movs r3,#2
 726 0048 87F82730 	 strb r3,[r7,#39]
 727 004c 39E0     	 b .L15
 728              	.L16:
 103:../Dave/Generated/DAC/dac.c ****     }
 104:../Dave/Generated/DAC/dac.c ****     else
 105:../Dave/Generated/DAC/dac.c ****     {
 106:../Dave/Generated/DAC/dac.c ****       if(shift_count < DAC_MAX_SCALE_SHIFT )
 729              	 .loc 2 106 0
 730 004e 97F82630 	 ldrb r3,[r7,#38]
 731 0052 062B     	 cmp r3,#6
 732 0054 32D8     	 bhi .L17
 107:../Dave/Generated/DAC/dac.c ****       {
 108:../Dave/Generated/DAC/dac.c ****         /* Decrease scaling factor and re-calculate start and stop ramp */
 109:../Dave/Generated/DAC/dac.c ****         stop_ramp = stop_ramp >> 1U;
 733              	 .loc 2 109 0
 734 0056 3B89     	 ldrh r3,[r7,#8]
 735 0058 5B08     	 lsrs r3,r3,#1
 736 005a 3B81     	 strh r3,[r7,#8]
 110:../Dave/Generated/DAC/dac.c ****         start_ramp = start_ramp >> 1U;
 737              	 .loc 2 110 0
 738 005c 7B89     	 ldrh r3,[r7,#10]
 739 005e 5B08     	 lsrs r3,r3,#1
 740 0060 7B81     	 strh r3,[r7,#10]
 111:../Dave/Generated/DAC/dac.c ****         shift_count++;
 741              	 .loc 2 111 0
 742 0062 97F82630 	 ldrb r3,[r7,#38]
 743 0066 0133     	 adds r3,r3,#1
 744 0068 87F82630 	 strb r3,[r7,#38]
 112:../Dave/Generated/DAC/dac.c **** 
 113:../Dave/Generated/DAC/dac.c ****         /* re-calculate clock divider based on change in steps */
 114:../Dave/Generated/DAC/dac.c ****         temp_steps = (uint16_t)((stop_ramp - start_ramp) + 1U);
 745              	 .loc 2 114 0
 746 006c 3A89     	 ldrh r2,[r7,#8]
 747 006e 7B89     	 ldrh r3,[r7,#10]
 748 0070 D31A     	 subs r3,r2,r3
 749 0072 9BB2     	 uxth r3,r3
 750 0074 0133     	 adds r3,r3,#1
 751 0076 BB84     	 strh r3,[r7,#36]
 115:../Dave/Generated/DAC/dac.c ****         if(stop_ramp == start_ramp)
 752              	 .loc 2 115 0
 753 0078 3A89     	 ldrh r2,[r7,#8]
 754 007a 7B89     	 ldrh r3,[r7,#10]
 755 007c 9A42     	 cmp r2,r3
 756 007e 03D1     	 bne .L18
 116:../Dave/Generated/DAC/dac.c ****         {
 117:../Dave/Generated/DAC/dac.c ****           status = DAC_STATUS_API_FAIL;
 757              	 .loc 2 117 0
 758 0080 0223     	 movs r3,#2
 759 0082 87F82730 	 strb r3,[r7,#39]
 760 0086 1CE0     	 b .L15
 761              	.L18:
 118:../Dave/Generated/DAC/dac.c ****         }
 119:../Dave/Generated/DAC/dac.c ****         else
 120:../Dave/Generated/DAC/dac.c ****         {
 121:../Dave/Generated/DAC/dac.c ****           clk_divider = (uint32_t)(peripheral_clock_freq_Hz /
 122:../Dave/Generated/DAC/dac.c ****                                   (temp_steps * frequency_Hz));
 762              	 .loc 2 122 0
 763 0088 BB8C     	 ldrh r3,[r7,#36]
 764 008a 7A68     	 ldr r2,[r7,#4]
 765 008c 02FB03F3 	 mul r3,r2,r3
 121:../Dave/Generated/DAC/dac.c ****                                   (temp_steps * frequency_Hz));
 766              	 .loc 2 121 0
 767 0090 FA69     	 ldr r2,[r7,#28]
 768 0092 B2FBF3F3 	 udiv r3,r2,r3
 769 0096 7B61     	 str r3,[r7,#20]
 123:../Dave/Generated/DAC/dac.c ****           if(clk_divider != 0U)
 770              	 .loc 2 123 0
 771 0098 7B69     	 ldr r3,[r7,#20]
 772 009a 002B     	 cmp r3,#0
 773 009c 05D0     	 beq .L20
 124:../Dave/Generated/DAC/dac.c ****           {
 125:../Dave/Generated/DAC/dac.c ****             temp_cal_freq = (uint32_t)(peripheral_clock_freq_Hz / clk_divider);
 774              	 .loc 2 125 0
 775 009e FA69     	 ldr r2,[r7,#28]
 776 00a0 7B69     	 ldr r3,[r7,#20]
 777 00a2 B2FBF3F3 	 udiv r3,r2,r3
 778 00a6 3B62     	 str r3,[r7,#32]
 779 00a8 01E0     	 b .L21
 780              	.L20:
 126:../Dave/Generated/DAC/dac.c ****           }
 127:../Dave/Generated/DAC/dac.c ****           else
 128:../Dave/Generated/DAC/dac.c ****           {
 129:../Dave/Generated/DAC/dac.c ****             temp_cal_freq = peripheral_clock_freq_Hz;
 781              	 .loc 2 129 0
 782 00aa FB69     	 ldr r3,[r7,#28]
 783 00ac 3B62     	 str r3,[r7,#32]
 784              	.L21:
 130:../Dave/Generated/DAC/dac.c ****           }
 131:../Dave/Generated/DAC/dac.c ****           if(temp_cal_freq < 1U)
 785              	 .loc 2 131 0
 786 00ae 3B6A     	 ldr r3,[r7,#32]
 787 00b0 002B     	 cmp r3,#0
 788 00b2 06D1     	 bne .L15
 132:../Dave/Generated/DAC/dac.c ****           {
 133:../Dave/Generated/DAC/dac.c ****             status = DAC_STATUS_API_FAIL;
 789              	 .loc 2 133 0
 790 00b4 0223     	 movs r3,#2
 791 00b6 87F82730 	 strb r3,[r7,#39]
 792 00ba 02E0     	 b .L15
 793              	.L17:
 134:../Dave/Generated/DAC/dac.c ****           }
 135:../Dave/Generated/DAC/dac.c ****         }
 136:../Dave/Generated/DAC/dac.c ****       }
 137:../Dave/Generated/DAC/dac.c ****       else
 138:../Dave/Generated/DAC/dac.c ****       {
 139:../Dave/Generated/DAC/dac.c ****         /* Frequency Can't be configurable */
 140:../Dave/Generated/DAC/dac.c ****         status = DAC_STATUS_API_FAIL;
 794              	 .loc 2 140 0
 795 00bc 0223     	 movs r3,#2
 796 00be 87F82730 	 strb r3,[r7,#39]
 797              	.L15:
  97:../Dave/Generated/DAC/dac.c ****   {
 798              	 .loc 2 97 0
 799 00c2 3B6A     	 ldr r3,[r7,#32]
 800 00c4 1B4A     	 ldr r2,.L27
 801 00c6 9342     	 cmp r3,r2
 802 00c8 03D9     	 bls .L22
  97:../Dave/Generated/DAC/dac.c ****   {
 803              	 .loc 2 97 0 is_stmt 0 discriminator 1
 804 00ca 97F82730 	 ldrb r3,[r7,#39]
 805 00ce 022B     	 cmp r3,#2
 806 00d0 B6D1     	 bne .L23
 807              	.L22:
 141:../Dave/Generated/DAC/dac.c ****       }
 142:../Dave/Generated/DAC/dac.c ****     }
 143:../Dave/Generated/DAC/dac.c ****   }
 144:../Dave/Generated/DAC/dac.c **** 
 145:../Dave/Generated/DAC/dac.c ****   if(DAC_STATUS_API_FAIL != status)
 808              	 .loc 2 145 0 is_stmt 1
 809 00d2 97F82730 	 ldrb r3,[r7,#39]
 810 00d6 022B     	 cmp r3,#2
 811 00d8 26D0     	 beq .L24
 146:../Dave/Generated/DAC/dac.c ****   {
 147:../Dave/Generated/DAC/dac.c ****     DAC_Ramp_StartStopConfigure(HandlePtr,start_ramp,stop_ramp);
 812              	 .loc 2 147 0
 813 00da 7A89     	 ldrh r2,[r7,#10]
 814 00dc 3B89     	 ldrh r3,[r7,#8]
 815 00de F868     	 ldr r0,[r7,#12]
 816 00e0 1146     	 mov r1,r2
 817 00e2 1A46     	 mov r2,r3
 818 00e4 FFF7FEFF 	 bl DAC_Ramp_StartStopConfigure
 148:../Dave/Generated/DAC/dac.c ****     if(shift_count > 0U)
 819              	 .loc 2 148 0
 820 00e8 97F82630 	 ldrb r3,[r7,#38]
 821 00ec 002B     	 cmp r3,#0
 822 00ee 0ED0     	 beq .L25
 149:../Dave/Generated/DAC/dac.c ****     {
 150:../Dave/Generated/DAC/dac.c ****       /* Scaling required */
 151:../Dave/Generated/DAC/dac.c ****       scale = (XMC_DAC_CH_OUTPUT_SCALE_t)((uint32_t)XMC_DAC_CH_OUTPUT_SCALE_MUL_2 +
 823              	 .loc 2 151 0
 824 00f0 97F82630 	 ldrb r3,[r7,#38]
 825 00f4 0833     	 adds r3,r3,#8
 826 00f6 FB76     	 strb r3,[r7,#27]
 152:../Dave/Generated/DAC/dac.c ****               (shift_count - (uint32_t)1));
 153:../Dave/Generated/DAC/dac.c ****       XMC_DAC_CH_SetOutputScale(HandlePtr->dac_module_ptr, HandlePtr->dac_ch,scale);
 827              	 .loc 2 153 0
 828 00f8 FB68     	 ldr r3,[r7,#12]
 829 00fa 1968     	 ldr r1,[r3]
 830 00fc FB68     	 ldr r3,[r7,#12]
 831 00fe 93F82620 	 ldrb r2,[r3,#38]
 832 0102 FB7E     	 ldrb r3,[r7,#27]
 833 0104 0846     	 mov r0,r1
 834 0106 1146     	 mov r1,r2
 835 0108 1A46     	 mov r2,r3
 836 010a FFF7FEFF 	 bl XMC_DAC_CH_SetOutputScale
 837              	.L25:
 154:../Dave/Generated/DAC/dac.c ****     }
 155:../Dave/Generated/DAC/dac.c ****     status = (DAC_STATUS_t)XMC_DAC_CH_SetFrequency(HandlePtr->dac_module_ptr,
 838              	 .loc 2 155 0
 839 010e FB68     	 ldr r3,[r7,#12]
 840 0110 1A68     	 ldr r2,[r3]
 841 0112 FB68     	 ldr r3,[r7,#12]
 842 0114 93F82630 	 ldrb r3,[r3,#38]
 843 0118 1046     	 mov r0,r2
 844 011a 1946     	 mov r1,r3
 845 011c 3A6A     	 ldr r2,[r7,#32]
 846 011e FFF7FEFF 	 bl XMC_DAC_CH_SetFrequency
 847 0122 0346     	 mov r3,r0
 848 0124 87F82730 	 strb r3,[r7,#39]
 849              	.L24:
 156:../Dave/Generated/DAC/dac.c ****               HandlePtr->dac_ch,temp_cal_freq);
 157:../Dave/Generated/DAC/dac.c ****   }
 158:../Dave/Generated/DAC/dac.c ****   return status;
 850              	 .loc 2 158 0
 851 0128 97F82730 	 ldrb r3,[r7,#39]
 159:../Dave/Generated/DAC/dac.c **** }
 852              	 .loc 2 159 0
 853 012c 1846     	 mov r0,r3
 854 012e 2837     	 adds r7,r7,#40
 855              	.LCFI75:
 856              	 .cfi_def_cfa_offset 8
 857 0130 BD46     	 mov sp,r7
 858              	.LCFI76:
 859              	 .cfi_def_cfa_register 13
 860              	 
 861 0132 80BD     	 pop {r7,pc}
 862              	.L28:
 863              	 .align 2
 864              	.L27:
 865 0134 80841E00 	 .word 2000000
 866              	 .cfi_endproc
 867              	.LFE223:
 869              	 .section .text.DAC_Ramp_ScaleDown,"ax",%progbits
 870              	 .align 2
 871              	 .global DAC_Ramp_ScaleDown
 872              	 .thumb
 873              	 .thumb_func
 875              	DAC_Ramp_ScaleDown:
 876              	.LFB224:
 160:../Dave/Generated/DAC/dac.c **** 
 161:../Dave/Generated/DAC/dac.c **** /*
 162:../Dave/Generated/DAC/dac.c ****  * This API will set Ramp frequency by increasing wave points by scale down operation.
 163:../Dave/Generated/DAC/dac.c **** */
 164:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_Ramp_ScaleDown(const DAC_t * const HandlePtr,
 165:../Dave/Generated/DAC/dac.c **** uint16_t start_ramp,uint16_t stop_ramp,uint32_t frequency_Hz)
 166:../Dave/Generated/DAC/dac.c **** {
 877              	 .loc 2 166 0
 878              	 .cfi_startproc
 879              	 
 880              	 
 881 0000 80B5     	 push {r7,lr}
 882              	.LCFI77:
 883              	 .cfi_def_cfa_offset 8
 884              	 .cfi_offset 7,-8
 885              	 .cfi_offset 14,-4
 886 0002 8AB0     	 sub sp,sp,#40
 887              	.LCFI78:
 888              	 .cfi_def_cfa_offset 48
 889 0004 00AF     	 add r7,sp,#0
 890              	.LCFI79:
 891              	 .cfi_def_cfa_register 7
 892 0006 F860     	 str r0,[r7,#12]
 893 0008 7B60     	 str r3,[r7,#4]
 894 000a 0B46     	 mov r3,r1
 895 000c 7B81     	 strh r3,[r7,#10]
 896 000e 1346     	 mov r3,r2
 897 0010 3B81     	 strh r3,[r7,#8]
 167:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status = DAC_STATUS_SUCCESS;
 898              	 .loc 2 167 0
 899 0012 0023     	 movs r3,#0
 900 0014 87F82730 	 strb r3,[r7,#39]
 168:../Dave/Generated/DAC/dac.c ****   uint8_t shift_count = 0U;
 901              	 .loc 2 168 0
 902 0018 0023     	 movs r3,#0
 903 001a 87F82630 	 strb r3,[r7,#38]
 169:../Dave/Generated/DAC/dac.c ****   uint16_t temp_steps = (uint16_t)((stop_ramp - start_ramp) + 1U);
 904              	 .loc 2 169 0
 905 001e 3A89     	 ldrh r2,[r7,#8]
 906 0020 7B89     	 ldrh r3,[r7,#10]
 907 0022 D31A     	 subs r3,r2,r3
 908 0024 9BB2     	 uxth r3,r3
 909 0026 0133     	 adds r3,r3,#1
 910 0028 BB84     	 strh r3,[r7,#36]
 170:../Dave/Generated/DAC/dac.c ****   uint32_t peripheral_clock_freq_Hz = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
 911              	 .loc 2 170 0
 912 002a FFF7FEFF 	 bl XMC_SCU_CLOCK_GetPeripheralClockFrequency
 913 002e B861     	 str r0,[r7,#24]
 171:../Dave/Generated/DAC/dac.c ****   uint32_t clk_divider = (uint32_t)(peripheral_clock_freq_Hz / (temp_steps * frequency_Hz));
 914              	 .loc 2 171 0
 915 0030 BB8C     	 ldrh r3,[r7,#36]
 916 0032 7A68     	 ldr r2,[r7,#4]
 917 0034 02FB03F3 	 mul r3,r2,r3
 918 0038 BA69     	 ldr r2,[r7,#24]
 919 003a B2FBF3F3 	 udiv r3,r2,r3
 920 003e 3B62     	 str r3,[r7,#32]
 172:../Dave/Generated/DAC/dac.c ****   uint32_t temp_cal_freq = frequency_Hz * temp_steps;
 921              	 .loc 2 172 0
 922 0040 BB8C     	 ldrh r3,[r7,#36]
 923 0042 7A68     	 ldr r2,[r7,#4]
 924 0044 02FB03F3 	 mul r3,r2,r3
 925 0048 FB61     	 str r3,[r7,#28]
 173:../Dave/Generated/DAC/dac.c ****   XMC_DAC_CH_OUTPUT_SCALE_t scale = XMC_DAC_CH_OUTPUT_SCALE_NONE;
 926              	 .loc 2 173 0
 927 004a 0023     	 movs r3,#0
 928 004c FB75     	 strb r3,[r7,#23]
 174:../Dave/Generated/DAC/dac.c **** 
 175:../Dave/Generated/DAC/dac.c ****   while((clk_divider > DAC_MAX_CLK_DIV) && (status != DAC_STATUS_API_FAIL))
 929              	 .loc 2 175 0
 930 004e 49E0     	 b .L30
 931              	.L38:
 176:../Dave/Generated/DAC/dac.c ****   {
 177:../Dave/Generated/DAC/dac.c ****     if( DAC_RAMP_MAX_STEPS < temp_steps )
 932              	 .loc 2 177 0
 933 0050 BB8C     	 ldrh r3,[r7,#36]
 934 0052 B3F5805F 	 cmp r3,#4096
 935 0056 03D3     	 bcc .L31
 178:../Dave/Generated/DAC/dac.c ****     {
 179:../Dave/Generated/DAC/dac.c ****       /* Frequency can't be configured */
 180:../Dave/Generated/DAC/dac.c ****       status = DAC_STATUS_API_FAIL;
 936              	 .loc 2 180 0
 937 0058 0223     	 movs r3,#2
 938 005a 87F82730 	 strb r3,[r7,#39]
 939 005e 41E0     	 b .L30
 940              	.L31:
 181:../Dave/Generated/DAC/dac.c ****     }
 182:../Dave/Generated/DAC/dac.c ****     else
 183:../Dave/Generated/DAC/dac.c ****     {
 184:../Dave/Generated/DAC/dac.c ****       if(shift_count < DAC_MAX_SCALE_SHIFT )
 941              	 .loc 2 184 0
 942 0060 97F82630 	 ldrb r3,[r7,#38]
 943 0064 062B     	 cmp r3,#6
 944 0066 3AD8     	 bhi .L32
 185:../Dave/Generated/DAC/dac.c ****       {
 186:../Dave/Generated/DAC/dac.c ****         /* Increase scaling factor and re-calculate start and stop ramp */
 187:../Dave/Generated/DAC/dac.c ****         stop_ramp = (uint16_t)(stop_ramp << 1U);
 945              	 .loc 2 187 0
 946 0068 3B89     	 ldrh r3,[r7,#8]
 947 006a 5B00     	 lsls r3,r3,#1
 948 006c 3B81     	 strh r3,[r7,#8]
 188:../Dave/Generated/DAC/dac.c ****         start_ramp = (uint16_t)(start_ramp << 1U);
 949              	 .loc 2 188 0
 950 006e 7B89     	 ldrh r3,[r7,#10]
 951 0070 5B00     	 lsls r3,r3,#1
 952 0072 7B81     	 strh r3,[r7,#10]
 189:../Dave/Generated/DAC/dac.c ****         temp_steps = (uint16_t)((stop_ramp - start_ramp) + 1U);
 953              	 .loc 2 189 0
 954 0074 3A89     	 ldrh r2,[r7,#8]
 955 0076 7B89     	 ldrh r3,[r7,#10]
 956 0078 D31A     	 subs r3,r2,r3
 957 007a 9BB2     	 uxth r3,r3
 958 007c 0133     	 adds r3,r3,#1
 959 007e BB84     	 strh r3,[r7,#36]
 190:../Dave/Generated/DAC/dac.c ****         if((stop_ramp <= DAC_RAMP_MAX_STEPS) && (start_ramp <= DAC_RAMP_MAX_STEPS) &&
 960              	 .loc 2 190 0
 961 0080 3B89     	 ldrh r3,[r7,#8]
 962 0082 B3F5805F 	 cmp r3,#4096
 963 0086 26D2     	 bcs .L33
 964              	 .loc 2 190 0 is_stmt 0 discriminator 1
 965 0088 7B89     	 ldrh r3,[r7,#10]
 966 008a B3F5805F 	 cmp r3,#4096
 967 008e 22D2     	 bcs .L33
 968              	 .loc 2 190 0 discriminator 2
 969 0090 3A89     	 ldrh r2,[r7,#8]
 970 0092 7B89     	 ldrh r3,[r7,#10]
 971 0094 9A42     	 cmp r2,r3
 972 0096 1ED0     	 beq .L33
 191:../Dave/Generated/DAC/dac.c ****                                                             (stop_ramp != start_ramp))
 192:../Dave/Generated/DAC/dac.c ****         {
 193:../Dave/Generated/DAC/dac.c ****           shift_count++;
 973              	 .loc 2 193 0 is_stmt 1
 974 0098 97F82630 	 ldrb r3,[r7,#38]
 975 009c 0133     	 adds r3,r3,#1
 976 009e 87F82630 	 strb r3,[r7,#38]
 194:../Dave/Generated/DAC/dac.c ****           /* re-calculate clock divider based on change in steps */
 195:../Dave/Generated/DAC/dac.c ****           clk_divider = (uint32_t)(peripheral_clock_freq_Hz / (temp_steps * frequency_Hz));
 977              	 .loc 2 195 0
 978 00a2 BB8C     	 ldrh r3,[r7,#36]
 979 00a4 7A68     	 ldr r2,[r7,#4]
 980 00a6 02FB03F3 	 mul r3,r2,r3
 981 00aa BA69     	 ldr r2,[r7,#24]
 982 00ac B2FBF3F3 	 udiv r3,r2,r3
 983 00b0 3B62     	 str r3,[r7,#32]
 196:../Dave/Generated/DAC/dac.c ****           if(clk_divider == 0U)
 984              	 .loc 2 196 0
 985 00b2 3B6A     	 ldr r3,[r7,#32]
 986 00b4 002B     	 cmp r3,#0
 987 00b6 01D1     	 bne .L34
 197:../Dave/Generated/DAC/dac.c ****           {
 198:../Dave/Generated/DAC/dac.c ****             clk_divider = 1U;
 988              	 .loc 2 198 0
 989 00b8 0123     	 movs r3,#1
 990 00ba 3B62     	 str r3,[r7,#32]
 991              	.L34:
 199:../Dave/Generated/DAC/dac.c ****           }
 200:../Dave/Generated/DAC/dac.c ****           temp_cal_freq = (uint32_t)(peripheral_clock_freq_Hz / clk_divider);
 992              	 .loc 2 200 0
 993 00bc BA69     	 ldr r2,[r7,#24]
 994 00be 3B6A     	 ldr r3,[r7,#32]
 995 00c0 B2FBF3F3 	 udiv r3,r2,r3
 996 00c4 FB61     	 str r3,[r7,#28]
 201:../Dave/Generated/DAC/dac.c ****           if(temp_cal_freq < 1U)
 997              	 .loc 2 201 0
 998 00c6 FB69     	 ldr r3,[r7,#28]
 999 00c8 002B     	 cmp r3,#0
 1000 00ca 03D1     	 bne .L35
 202:../Dave/Generated/DAC/dac.c ****           {
 203:../Dave/Generated/DAC/dac.c ****             status = DAC_STATUS_API_FAIL;
 1001              	 .loc 2 203 0
 1002 00cc 0223     	 movs r3,#2
 1003 00ce 87F82730 	 strb r3,[r7,#39]
 201:../Dave/Generated/DAC/dac.c ****           if(temp_cal_freq < 1U)
 1004              	 .loc 2 201 0
 1005 00d2 03E0     	 b .L36
 1006              	.L35:
 1007 00d4 02E0     	 b .L36
 1008              	.L33:
 204:../Dave/Generated/DAC/dac.c ****           }
 205:../Dave/Generated/DAC/dac.c ****         }
 206:../Dave/Generated/DAC/dac.c ****         else
 207:../Dave/Generated/DAC/dac.c ****         {
 208:../Dave/Generated/DAC/dac.c ****           status = DAC_STATUS_API_FAIL;
 1009              	 .loc 2 208 0
 1010 00d6 0223     	 movs r3,#2
 1011 00d8 87F82730 	 strb r3,[r7,#39]
 1012              	.L36:
 1013 00dc 02E0     	 b .L30
 1014              	.L32:
 209:../Dave/Generated/DAC/dac.c ****         }
 210:../Dave/Generated/DAC/dac.c ****       }
 211:../Dave/Generated/DAC/dac.c ****       else
 212:../Dave/Generated/DAC/dac.c ****       {
 213:../Dave/Generated/DAC/dac.c ****         /* Frequency Can't be configurable */
 214:../Dave/Generated/DAC/dac.c ****         status = DAC_STATUS_API_FAIL;
 1015              	 .loc 2 214 0
 1016 00de 0223     	 movs r3,#2
 1017 00e0 87F82730 	 strb r3,[r7,#39]
 1018              	.L30:
 175:../Dave/Generated/DAC/dac.c ****   {
 1019              	 .loc 2 175 0
 1020 00e4 3B6A     	 ldr r3,[r7,#32]
 1021 00e6 B3F5801F 	 cmp r3,#1048576
 1022 00ea 03D3     	 bcc .L37
 175:../Dave/Generated/DAC/dac.c ****   {
 1023              	 .loc 2 175 0 is_stmt 0 discriminator 1
 1024 00ec 97F82730 	 ldrb r3,[r7,#39]
 1025 00f0 022B     	 cmp r3,#2
 1026 00f2 ADD1     	 bne .L38
 1027              	.L37:
 215:../Dave/Generated/DAC/dac.c ****       }
 216:../Dave/Generated/DAC/dac.c ****     }
 217:../Dave/Generated/DAC/dac.c ****   }
 218:../Dave/Generated/DAC/dac.c ****     
 219:../Dave/Generated/DAC/dac.c ****   if(DAC_STATUS_API_FAIL != status)
 1028              	 .loc 2 219 0 is_stmt 1
 1029 00f4 97F82730 	 ldrb r3,[r7,#39]
 1030 00f8 022B     	 cmp r3,#2
 1031 00fa 25D0     	 beq .L39
 220:../Dave/Generated/DAC/dac.c ****   {
 221:../Dave/Generated/DAC/dac.c ****     DAC_Ramp_StartStopConfigure(HandlePtr,start_ramp,stop_ramp);
 1032              	 .loc 2 221 0
 1033 00fc 7A89     	 ldrh r2,[r7,#10]
 1034 00fe 3B89     	 ldrh r3,[r7,#8]
 1035 0100 F868     	 ldr r0,[r7,#12]
 1036 0102 1146     	 mov r1,r2
 1037 0104 1A46     	 mov r2,r3
 1038 0106 FFF7FEFF 	 bl DAC_Ramp_StartStopConfigure
 222:../Dave/Generated/DAC/dac.c ****     if(shift_count > 0U)
 1039              	 .loc 2 222 0
 1040 010a 97F82630 	 ldrb r3,[r7,#38]
 1041 010e 002B     	 cmp r3,#0
 1042 0110 0DD0     	 beq .L40
 223:../Dave/Generated/DAC/dac.c ****     {
 224:../Dave/Generated/DAC/dac.c ****       /* Scaling required */
 225:../Dave/Generated/DAC/dac.c ****       scale = (XMC_DAC_CH_OUTPUT_SCALE_t)((uint32_t)XMC_DAC_CH_OUTPUT_SCALE_DIV_2 +
 1043              	 .loc 2 225 0
 1044 0112 97F82630 	 ldrb r3,[r7,#38]
 1045 0116 FB75     	 strb r3,[r7,#23]
 226:../Dave/Generated/DAC/dac.c ****                                                         (shift_count - (uint32_t)1));
 227:../Dave/Generated/DAC/dac.c ****       XMC_DAC_CH_SetOutputScale(HandlePtr->dac_module_ptr, HandlePtr->dac_ch,scale);
 1046              	 .loc 2 227 0
 1047 0118 FB68     	 ldr r3,[r7,#12]
 1048 011a 1968     	 ldr r1,[r3]
 1049 011c FB68     	 ldr r3,[r7,#12]
 1050 011e 93F82620 	 ldrb r2,[r3,#38]
 1051 0122 FB7D     	 ldrb r3,[r7,#23]
 1052 0124 0846     	 mov r0,r1
 1053 0126 1146     	 mov r1,r2
 1054 0128 1A46     	 mov r2,r3
 1055 012a FFF7FEFF 	 bl XMC_DAC_CH_SetOutputScale
 1056              	.L40:
 228:../Dave/Generated/DAC/dac.c ****     }
 229:../Dave/Generated/DAC/dac.c ****     status = (DAC_STATUS_t)XMC_DAC_CH_SetFrequency(HandlePtr->dac_module_ptr,
 1057              	 .loc 2 229 0
 1058 012e FB68     	 ldr r3,[r7,#12]
 1059 0130 1A68     	 ldr r2,[r3]
 1060 0132 FB68     	 ldr r3,[r7,#12]
 1061 0134 93F82630 	 ldrb r3,[r3,#38]
 1062 0138 1046     	 mov r0,r2
 1063 013a 1946     	 mov r1,r3
 1064 013c FA69     	 ldr r2,[r7,#28]
 1065 013e FFF7FEFF 	 bl XMC_DAC_CH_SetFrequency
 1066 0142 0346     	 mov r3,r0
 1067 0144 87F82730 	 strb r3,[r7,#39]
 1068              	.L39:
 230:../Dave/Generated/DAC/dac.c ****                                                    HandlePtr->dac_ch,temp_cal_freq);
 231:../Dave/Generated/DAC/dac.c ****   }
 232:../Dave/Generated/DAC/dac.c ****   return status;
 1069              	 .loc 2 232 0
 1070 0148 97F82730 	 ldrb r3,[r7,#39]
 233:../Dave/Generated/DAC/dac.c **** }
 1071              	 .loc 2 233 0
 1072 014c 1846     	 mov r0,r3
 1073 014e 2837     	 adds r7,r7,#40
 1074              	.LCFI80:
 1075              	 .cfi_def_cfa_offset 8
 1076 0150 BD46     	 mov sp,r7
 1077              	.LCFI81:
 1078              	 .cfi_def_cfa_register 13
 1079              	 
 1080 0152 80BD     	 pop {r7,pc}
 1081              	 .cfi_endproc
 1082              	.LFE224:
 1084              	 .section .text.DAC_Ramp_StartStopConfigure,"ax",%progbits
 1085              	 .align 2
 1086              	 .global DAC_Ramp_StartStopConfigure
 1087              	 .thumb
 1088              	 .thumb_func
 1090              	DAC_Ramp_StartStopConfigure:
 1091              	.LFB225:
 234:../Dave/Generated/DAC/dac.c **** 
 235:../Dave/Generated/DAC/dac.c **** /* This API will configure ramp start and stop values */
 236:../Dave/Generated/DAC/dac.c **** void DAC_Ramp_StartStopConfigure(const DAC_t * const HandlePtr,uint16_t start_ramp,uint16_t stop_ra
 237:../Dave/Generated/DAC/dac.c **** {
 1092              	 .loc 2 237 0
 1093              	 .cfi_startproc
 1094              	 
 1095              	 
 1096 0000 80B5     	 push {r7,lr}
 1097              	.LCFI82:
 1098              	 .cfi_def_cfa_offset 8
 1099              	 .cfi_offset 7,-8
 1100              	 .cfi_offset 14,-4
 1101 0002 84B0     	 sub sp,sp,#16
 1102              	.LCFI83:
 1103              	 .cfi_def_cfa_offset 24
 1104 0004 00AF     	 add r7,sp,#0
 1105              	.LCFI84:
 1106              	 .cfi_def_cfa_register 7
 1107 0006 7860     	 str r0,[r7,#4]
 1108 0008 0B46     	 mov r3,r1
 1109 000a 7B80     	 strh r3,[r7,#2]
 1110 000c 1346     	 mov r3,r2
 1111 000e 3B80     	 strh r3,[r7]
 238:../Dave/Generated/DAC/dac.c ****   uint16_t temp_start_ramp;
 239:../Dave/Generated/DAC/dac.c ****   if(HandlePtr->dac_ramp_start_mv > HandlePtr->dac_ramp_stop_mv)
 1112              	 .loc 2 239 0
 1113 0010 7B68     	 ldr r3,[r7,#4]
 1114 0012 1A8C     	 ldrh r2,[r3,#32]
 1115 0014 7B68     	 ldr r3,[r7,#4]
 1116 0016 5B8C     	 ldrh r3,[r3,#34]
 1117 0018 9A42     	 cmp r2,r3
 1118 001a 15D9     	 bls .L43
 240:../Dave/Generated/DAC/dac.c ****   {
 241:../Dave/Generated/DAC/dac.c ****     /* Shift start/stop for negative ramp */
 242:../Dave/Generated/DAC/dac.c ****     temp_start_ramp = start_ramp;
 1119              	 .loc 2 242 0
 1120 001c 7B88     	 ldrh r3,[r7,#2]
 1121 001e FB81     	 strh r3,[r7,#14]
 243:../Dave/Generated/DAC/dac.c ****     start_ramp = DAC_RAMP_MAX_STEPS - stop_ramp;
 1122              	 .loc 2 243 0
 1123 0020 3B88     	 ldrh r3,[r7]
 1124 0022 C3F57F63 	 rsb r3,r3,#4080
 1125 0026 0F33     	 adds r3,r3,#15
 1126 0028 7B80     	 strh r3,[r7,#2]
 244:../Dave/Generated/DAC/dac.c ****     stop_ramp  = DAC_RAMP_MAX_STEPS - temp_start_ramp;
 1127              	 .loc 2 244 0
 1128 002a FB89     	 ldrh r3,[r7,#14]
 1129 002c C3F57F63 	 rsb r3,r3,#4080
 1130 0030 0F33     	 adds r3,r3,#15
 1131 0032 3B80     	 strh r3,[r7]
 245:../Dave/Generated/DAC/dac.c ****     XMC_DAC_CH_EnableOutputNegation(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
 1132              	 .loc 2 245 0
 1133 0034 7B68     	 ldr r3,[r7,#4]
 1134 0036 1A68     	 ldr r2,[r3]
 1135 0038 7B68     	 ldr r3,[r7,#4]
 1136 003a 93F82630 	 ldrb r3,[r3,#38]
 1137 003e 1046     	 mov r0,r2
 1138 0040 1946     	 mov r1,r3
 1139 0042 FFF7FEFF 	 bl XMC_DAC_CH_EnableOutputNegation
 1140 0046 08E0     	 b .L44
 1141              	.L43:
 246:../Dave/Generated/DAC/dac.c ****   }
 247:../Dave/Generated/DAC/dac.c ****   else
 248:../Dave/Generated/DAC/dac.c ****   {
 249:../Dave/Generated/DAC/dac.c ****     XMC_DAC_CH_DisableOutputNegation(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
 1142              	 .loc 2 249 0
 1143 0048 7B68     	 ldr r3,[r7,#4]
 1144 004a 1A68     	 ldr r2,[r3]
 1145 004c 7B68     	 ldr r3,[r7,#4]
 1146 004e 93F82630 	 ldrb r3,[r3,#38]
 1147 0052 1046     	 mov r0,r2
 1148 0054 1946     	 mov r1,r3
 1149 0056 FFF7FEFF 	 bl XMC_DAC_CH_DisableOutputNegation
 1150              	.L44:
 250:../Dave/Generated/DAC/dac.c ****   }
 251:../Dave/Generated/DAC/dac.c ****   XMC_DAC_CH_SetRampStart(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, start_ramp);
 1151              	 .loc 2 251 0
 1152 005a 7B68     	 ldr r3,[r7,#4]
 1153 005c 1968     	 ldr r1,[r3]
 1154 005e 7B68     	 ldr r3,[r7,#4]
 1155 0060 93F82620 	 ldrb r2,[r3,#38]
 1156 0064 7B88     	 ldrh r3,[r7,#2]
 1157 0066 0846     	 mov r0,r1
 1158 0068 1146     	 mov r1,r2
 1159 006a 1A46     	 mov r2,r3
 1160 006c FFF7FEFF 	 bl XMC_DAC_CH_SetRampStart
 252:../Dave/Generated/DAC/dac.c ****   XMC_DAC_CH_SetRampStop(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, stop_ramp);
 1161              	 .loc 2 252 0
 1162 0070 7B68     	 ldr r3,[r7,#4]
 1163 0072 1968     	 ldr r1,[r3]
 1164 0074 7B68     	 ldr r3,[r7,#4]
 1165 0076 93F82620 	 ldrb r2,[r3,#38]
 1166 007a 3B88     	 ldrh r3,[r7]
 1167 007c 0846     	 mov r0,r1
 1168 007e 1146     	 mov r1,r2
 1169 0080 1A46     	 mov r2,r3
 1170 0082 FFF7FEFF 	 bl XMC_DAC_CH_SetRampStop
 253:../Dave/Generated/DAC/dac.c **** }
 1171              	 .loc 2 253 0
 1172 0086 1037     	 adds r7,r7,#16
 1173              	.LCFI85:
 1174              	 .cfi_def_cfa_offset 8
 1175 0088 BD46     	 mov sp,r7
 1176              	.LCFI86:
 1177              	 .cfi_def_cfa_register 13
 1178              	 
 1179 008a 80BD     	 pop {r7,pc}
 1180              	 .cfi_endproc
 1181              	.LFE225:
 1183              	 .section .text.DAC_ModeConfig,"ax",%progbits
 1184              	 .align 2
 1185              	 .global DAC_ModeConfig
 1186              	 .thumb
 1187              	 .thumb_func
 1189              	DAC_ModeConfig:
 1190              	.LFB226:
 254:../Dave/Generated/DAC/dac.c **** 
 255:../Dave/Generated/DAC/dac.c **** /* This API will configure DAC mode depends upon the user configuration */
 256:../Dave/Generated/DAC/dac.c **** XMC_DAC_CH_STATUS_t DAC_ModeConfig(const DAC_t * const HandlePtr)
 257:../Dave/Generated/DAC/dac.c **** {
 1191              	 .loc 2 257 0
 1192              	 .cfi_startproc
 1193              	 
 1194              	 
 1195 0000 B0B5     	 push {r4,r5,r7,lr}
 1196              	.LCFI87:
 1197              	 .cfi_def_cfa_offset 16
 1198              	 .cfi_offset 4,-16
 1199              	 .cfi_offset 5,-12
 1200              	 .cfi_offset 7,-8
 1201              	 .cfi_offset 14,-4
 1202 0002 86B0     	 sub sp,sp,#24
 1203              	.LCFI88:
 1204              	 .cfi_def_cfa_offset 40
 1205 0004 02AF     	 add r7,sp,#8
 1206              	.LCFI89:
 1207              	 .cfi_def_cfa 7,32
 1208 0006 7860     	 str r0,[r7,#4]
 258:../Dave/Generated/DAC/dac.c ****   XMC_DAC_CH_STATUS_t api_status = XMC_DAC_CH_STATUS_OK;
 1209              	 .loc 2 258 0
 1210 0008 0023     	 movs r3,#0
 1211 000a FB73     	 strb r3,[r7,#15]
 259:../Dave/Generated/DAC/dac.c ****   /* Initialize DAC configuration created by the user */
 260:../Dave/Generated/DAC/dac.c ****   if ( XMC_DAC_CH_MODE_PATTERN == HandlePtr->dac_mode )
 1212              	 .loc 2 260 0
 1213 000c 7B68     	 ldr r3,[r7,#4]
 1214 000e DB68     	 ldr r3,[r3,#12]
 1215 0010 B3F5401F 	 cmp r3,#3145728
 1216 0014 15D1     	 bne .L46
 261:../Dave/Generated/DAC/dac.c ****   {
 262:../Dave/Generated/DAC/dac.c ****     api_status = XMC_DAC_CH_StartPatternMode(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,
 1217              	 .loc 2 262 0
 1218 0016 7B68     	 ldr r3,[r7,#4]
 1219 0018 1868     	 ldr r0,[r3]
 1220 001a 7B68     	 ldr r3,[r7,#4]
 1221 001c 93F82610 	 ldrb r1,[r3,#38]
 1222 0020 7B68     	 ldr r3,[r7,#4]
 1223 0022 9D6A     	 ldr r5,[r3,#40]
 1224 0024 7B68     	 ldr r3,[r7,#4]
 1225 0026 1C7D     	 ldrb r4,[r3,#20]
 1226 0028 7B68     	 ldr r3,[r7,#4]
 1227 002a 1A69     	 ldr r2,[r3,#16]
 1228 002c 7B68     	 ldr r3,[r7,#4]
 1229 002e 9B69     	 ldr r3,[r3,#24]
 1230 0030 0092     	 str r2,[sp]
 1231 0032 0193     	 str r3,[sp,#4]
 1232 0034 2A46     	 mov r2,r5
 1233 0036 2346     	 mov r3,r4
 1234 0038 FFF7FEFF 	 bl XMC_DAC_CH_StartPatternMode
 1235 003c 0346     	 mov r3,r0
 1236 003e FB73     	 strb r3,[r7,#15]
 1237 0040 85E0     	 b .L47
 1238              	.L46:
 263:../Dave/Generated/DAC/dac.c ****     HandlePtr->dac_pat_table_ptr,HandlePtr->dac_sign_output,
 264:../Dave/Generated/DAC/dac.c ****     HandlePtr->dac_input_trigger,HandlePtr->dac_frequency);
 265:../Dave/Generated/DAC/dac.c ****   }
 266:../Dave/Generated/DAC/dac.c ****   else if ( XMC_DAC_CH_MODE_SINGLE == HandlePtr->dac_mode )
 1239              	 .loc 2 266 0
 1240 0042 7B68     	 ldr r3,[r7,#4]
 1241 0044 DB68     	 ldr r3,[r3,#12]
 1242 0046 B3F5801F 	 cmp r3,#1048576
 1243 004a 15D1     	 bne .L48
 267:../Dave/Generated/DAC/dac.c ****   {
 268:../Dave/Generated/DAC/dac.c ****     api_status = XMC_DAC_CH_StartSingleValueMode(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
 1244              	 .loc 2 268 0
 1245 004c 7B68     	 ldr r3,[r7,#4]
 1246 004e 1A68     	 ldr r2,[r3]
 1247 0050 7B68     	 ldr r3,[r7,#4]
 1248 0052 93F82630 	 ldrb r3,[r3,#38]
 1249 0056 1046     	 mov r0,r2
 1250 0058 1946     	 mov r1,r3
 1251 005a FFF7FEFF 	 bl XMC_DAC_CH_StartSingleValueMode
 1252 005e 0346     	 mov r3,r0
 1253 0060 FB73     	 strb r3,[r7,#15]
 269:../Dave/Generated/DAC/dac.c ****     /*Initialized data register with zero */
 270:../Dave/Generated/DAC/dac.c ****     XMC_DAC_CH_Write(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,0U);
 1254              	 .loc 2 270 0
 1255 0062 7B68     	 ldr r3,[r7,#4]
 1256 0064 1A68     	 ldr r2,[r3]
 1257 0066 7B68     	 ldr r3,[r7,#4]
 1258 0068 93F82630 	 ldrb r3,[r3,#38]
 1259 006c 1046     	 mov r0,r2
 1260 006e 1946     	 mov r1,r3
 1261 0070 0022     	 movs r2,#0
 1262 0072 FFF7FEFF 	 bl XMC_DAC_CH_Write
 1263 0076 6AE0     	 b .L47
 1264              	.L48:
 271:../Dave/Generated/DAC/dac.c ****   }
 272:../Dave/Generated/DAC/dac.c ****   else if ( XMC_DAC_CH_MODE_DATA ==  HandlePtr->dac_mode )
 1265              	 .loc 2 272 0
 1266 0078 7B68     	 ldr r3,[r7,#4]
 1267 007a DB68     	 ldr r3,[r3,#12]
 1268 007c B3F5001F 	 cmp r3,#2097152
 1269 0080 25D1     	 bne .L49
 273:../Dave/Generated/DAC/dac.c ****   {
 274:../Dave/Generated/DAC/dac.c ****     api_status = XMC_DAC_CH_StartDataMode(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,
 1270              	 .loc 2 274 0
 1271 0082 7B68     	 ldr r3,[r7,#4]
 1272 0084 1868     	 ldr r0,[r3]
 1273 0086 7B68     	 ldr r3,[r7,#4]
 1274 0088 93F82610 	 ldrb r1,[r3,#38]
 1275 008c 7B68     	 ldr r3,[r7,#4]
 1276 008e 1A69     	 ldr r2,[r3,#16]
 1277 0090 7B68     	 ldr r3,[r7,#4]
 1278 0092 9B69     	 ldr r3,[r3,#24]
 1279 0094 FFF7FEFF 	 bl XMC_DAC_CH_StartDataMode
 1280 0098 0346     	 mov r3,r0
 1281 009a FB73     	 strb r3,[r7,#15]
 275:../Dave/Generated/DAC/dac.c ****     HandlePtr->dac_input_trigger,HandlePtr->dac_frequency);
 276:../Dave/Generated/DAC/dac.c ****     if(1U == HandlePtr->dac_service_request)
 1282              	 .loc 2 276 0
 1283 009c 7B68     	 ldr r3,[r7,#4]
 1284 009e 93F82430 	 ldrb r3,[r3,#36]
 1285 00a2 012B     	 cmp r3,#1
 1286 00a4 08D1     	 bne .L50
 277:../Dave/Generated/DAC/dac.c ****     {
 278:../Dave/Generated/DAC/dac.c ****       /* Enable Service Request */
 279:../Dave/Generated/DAC/dac.c ****       XMC_DAC_CH_EnableEvent(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
 1287              	 .loc 2 279 0
 1288 00a6 7B68     	 ldr r3,[r7,#4]
 1289 00a8 1A68     	 ldr r2,[r3]
 1290 00aa 7B68     	 ldr r3,[r7,#4]
 1291 00ac 93F82630 	 ldrb r3,[r3,#38]
 1292 00b0 1046     	 mov r0,r2
 1293 00b2 1946     	 mov r1,r3
 1294 00b4 FFF7FEFF 	 bl XMC_DAC_CH_EnableEvent
 1295              	.L50:
 280:../Dave/Generated/DAC/dac.c ****     }
 281:../Dave/Generated/DAC/dac.c **** 
 282:../Dave/Generated/DAC/dac.c ****     /*Initialized data register with zero */
 283:../Dave/Generated/DAC/dac.c ****     XMC_DAC_CH_Write(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,0U);
 1296              	 .loc 2 283 0
 1297 00b8 7B68     	 ldr r3,[r7,#4]
 1298 00ba 1A68     	 ldr r2,[r3]
 1299 00bc 7B68     	 ldr r3,[r7,#4]
 1300 00be 93F82630 	 ldrb r3,[r3,#38]
 1301 00c2 1046     	 mov r0,r2
 1302 00c4 1946     	 mov r1,r3
 1303 00c6 0022     	 movs r2,#0
 1304 00c8 FFF7FEFF 	 bl XMC_DAC_CH_Write
 1305 00cc 3FE0     	 b .L47
 1306              	.L49:
 284:../Dave/Generated/DAC/dac.c ****   }
 285:../Dave/Generated/DAC/dac.c ****   else if ( XMC_DAC_CH_MODE_RAMP == HandlePtr->dac_mode )
 1307              	 .loc 2 285 0
 1308 00ce 7B68     	 ldr r3,[r7,#4]
 1309 00d0 DB68     	 ldr r3,[r3,#12]
 1310 00d2 B3F5A00F 	 cmp r3,#5242880
 1311 00d6 25D1     	 bne .L51
 286:../Dave/Generated/DAC/dac.c ****   {
 287:../Dave/Generated/DAC/dac.c ****     api_status = XMC_DAC_CH_StartRampMode(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,
 1312              	 .loc 2 287 0
 1313 00d8 7B68     	 ldr r3,[r7,#4]
 1314 00da 1868     	 ldr r0,[r3]
 1315 00dc 7B68     	 ldr r3,[r7,#4]
 1316 00de 93F82610 	 ldrb r1,[r3,#38]
 1317 00e2 7B68     	 ldr r3,[r7,#4]
 1318 00e4 9D8B     	 ldrh r5,[r3,#28]
 1319 00e6 7B68     	 ldr r3,[r7,#4]
 1320 00e8 DC8B     	 ldrh r4,[r3,#30]
 1321 00ea 7B68     	 ldr r3,[r7,#4]
 1322 00ec 1A69     	 ldr r2,[r3,#16]
 1323 00ee 7B68     	 ldr r3,[r7,#4]
 1324 00f0 9B69     	 ldr r3,[r3,#24]
 1325 00f2 0092     	 str r2,[sp]
 1326 00f4 0193     	 str r3,[sp,#4]
 1327 00f6 2A46     	 mov r2,r5
 1328 00f8 2346     	 mov r3,r4
 1329 00fa FFF7FEFF 	 bl XMC_DAC_CH_StartRampMode
 1330 00fe 0346     	 mov r3,r0
 1331 0100 FB73     	 strb r3,[r7,#15]
 288:../Dave/Generated/DAC/dac.c ****     HandlePtr->dac_ramp_start,HandlePtr->dac_ramp_stop,
 289:../Dave/Generated/DAC/dac.c ****     HandlePtr->dac_input_trigger,HandlePtr->dac_frequency);
 290:../Dave/Generated/DAC/dac.c **** 
 291:../Dave/Generated/DAC/dac.c ****     XMC_DAC_CH_SetOutputScale(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,
 1332              	 .loc 2 291 0
 1333 0102 7B68     	 ldr r3,[r7,#4]
 1334 0104 1968     	 ldr r1,[r3]
 1335 0106 7B68     	 ldr r3,[r7,#4]
 1336 0108 93F82620 	 ldrb r2,[r3,#38]
 292:../Dave/Generated/DAC/dac.c ****                        (XMC_DAC_CH_OUTPUT_SCALE_t)HandlePtr->dac_config_ptr->output_scale);
 1337              	 .loc 2 292 0
 1338 010c 7B68     	 ldr r3,[r7,#4]
 1339 010e 5B68     	 ldr r3,[r3,#4]
 1340 0110 1B79     	 ldrb r3,[r3,#4]
 1341 0112 C3F30303 	 ubfx r3,r3,#0,#4
 1342 0116 DBB2     	 uxtb r3,r3
 291:../Dave/Generated/DAC/dac.c ****                        (XMC_DAC_CH_OUTPUT_SCALE_t)HandlePtr->dac_config_ptr->output_scale);
 1343              	 .loc 2 291 0
 1344 0118 0846     	 mov r0,r1
 1345 011a 1146     	 mov r1,r2
 1346 011c 1A46     	 mov r2,r3
 1347 011e FFF7FEFF 	 bl XMC_DAC_CH_SetOutputScale
 1348 0122 14E0     	 b .L47
 1349              	.L51:
 293:../Dave/Generated/DAC/dac.c ****   }
 294:../Dave/Generated/DAC/dac.c ****   else if ( XMC_DAC_CH_MODE_NOISE == HandlePtr->dac_mode )
 1350              	 .loc 2 294 0
 1351 0124 7B68     	 ldr r3,[r7,#4]
 1352 0126 DB68     	 ldr r3,[r3,#12]
 1353 0128 B3F5800F 	 cmp r3,#4194304
 1354 012c 0DD1     	 bne .L52
 295:../Dave/Generated/DAC/dac.c ****   {
 296:../Dave/Generated/DAC/dac.c ****     api_status = XMC_DAC_CH_StartNoiseMode(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,
 1355              	 .loc 2 296 0
 1356 012e 7B68     	 ldr r3,[r7,#4]
 1357 0130 1868     	 ldr r0,[r3]
 1358 0132 7B68     	 ldr r3,[r7,#4]
 1359 0134 93F82610 	 ldrb r1,[r3,#38]
 1360 0138 7B68     	 ldr r3,[r7,#4]
 1361 013a 1A69     	 ldr r2,[r3,#16]
 1362 013c 7B68     	 ldr r3,[r7,#4]
 1363 013e 9B69     	 ldr r3,[r3,#24]
 1364 0140 FFF7FEFF 	 bl XMC_DAC_CH_StartNoiseMode
 1365 0144 0346     	 mov r3,r0
 1366 0146 FB73     	 strb r3,[r7,#15]
 1367 0148 01E0     	 b .L47
 1368              	.L52:
 297:../Dave/Generated/DAC/dac.c ****     HandlePtr->dac_input_trigger,HandlePtr->dac_frequency);
 298:../Dave/Generated/DAC/dac.c ****   }
 299:../Dave/Generated/DAC/dac.c ****   else
 300:../Dave/Generated/DAC/dac.c ****   {
 301:../Dave/Generated/DAC/dac.c ****     /* DAC Mode Idle */
 302:../Dave/Generated/DAC/dac.c ****     api_status = XMC_DAC_CH_STATUS_OK;
 1369              	 .loc 2 302 0
 1370 014a 0023     	 movs r3,#0
 1371 014c FB73     	 strb r3,[r7,#15]
 1372              	.L47:
 303:../Dave/Generated/DAC/dac.c ****   }
 304:../Dave/Generated/DAC/dac.c ****   return api_status;
 1373              	 .loc 2 304 0
 1374 014e FB7B     	 ldrb r3,[r7,#15]
 305:../Dave/Generated/DAC/dac.c **** }
 1375              	 .loc 2 305 0
 1376 0150 1846     	 mov r0,r3
 1377 0152 1037     	 adds r7,r7,#16
 1378              	.LCFI90:
 1379              	 .cfi_def_cfa_offset 16
 1380 0154 BD46     	 mov sp,r7
 1381              	.LCFI91:
 1382              	 .cfi_def_cfa_register 13
 1383              	 
 1384 0156 B0BD     	 pop {r4,r5,r7,pc}
 1385              	 .cfi_endproc
 1386              	.LFE226:
 1388              	 .section .text.DAC_GetAppVersion,"ax",%progbits
 1389              	 .align 2
 1390              	 .global DAC_GetAppVersion
 1391              	 .thumb
 1392              	 .thumb_func
 1394              	DAC_GetAppVersion:
 1395              	.LFB227:
 306:../Dave/Generated/DAC/dac.c **** 
 307:../Dave/Generated/DAC/dac.c **** /* App API to retrieve the App version information */
 308:../Dave/Generated/DAC/dac.c **** DAVE_APP_VERSION_t DAC_GetAppVersion(void)
 309:../Dave/Generated/DAC/dac.c **** {
 1396              	 .loc 2 309 0
 1397              	 .cfi_startproc
 1398              	 
 1399              	 
 1400              	 
 1401 0000 80B4     	 push {r7}
 1402              	.LCFI92:
 1403              	 .cfi_def_cfa_offset 4
 1404              	 .cfi_offset 7,-4
 1405 0002 83B0     	 sub sp,sp,#12
 1406              	.LCFI93:
 1407              	 .cfi_def_cfa_offset 16
 1408 0004 00AF     	 add r7,sp,#0
 1409              	.LCFI94:
 1410              	 .cfi_def_cfa_register 7
 310:../Dave/Generated/DAC/dac.c ****   DAVE_APP_VERSION_t version;
 311:../Dave/Generated/DAC/dac.c **** 
 312:../Dave/Generated/DAC/dac.c ****   version.major = DAC_MAJOR_VERSION;
 1411              	 .loc 2 312 0
 1412 0006 0423     	 movs r3,#4
 1413 0008 3B70     	 strb r3,[r7]
 313:../Dave/Generated/DAC/dac.c ****   version.minor = DAC_MINOR_VERSION;
 1414              	 .loc 2 313 0
 1415 000a 0023     	 movs r3,#0
 1416 000c 7B70     	 strb r3,[r7,#1]
 314:../Dave/Generated/DAC/dac.c ****   version.patch = DAC_PATCH_VERSION;
 1417              	 .loc 2 314 0
 1418 000e 1223     	 movs r3,#18
 1419 0010 BB70     	 strb r3,[r7,#2]
 315:../Dave/Generated/DAC/dac.c **** 
 316:../Dave/Generated/DAC/dac.c ****   return version;
 1420              	 .loc 2 316 0
 1421 0012 3B1D     	 adds r3,r7,#4
 1422 0014 3A46     	 mov r2,r7
 1423 0016 1268     	 ldr r2,[r2]
 1424 0018 1146     	 mov r1,r2
 1425 001a 1980     	 strh r1,[r3]
 1426 001c 0233     	 adds r3,r3,#2
 1427 001e 120C     	 lsrs r2,r2,#16
 1428 0020 1A70     	 strb r2,[r3]
 1429 0022 0023     	 movs r3,#0
 1430 0024 3A79     	 ldrb r2,[r7,#4]
 1431 0026 62F30703 	 bfi r3,r2,#0,#8
 1432 002a 7A79     	 ldrb r2,[r7,#5]
 1433 002c 62F30F23 	 bfi r3,r2,#8,#8
 1434 0030 BA79     	 ldrb r2,[r7,#6]
 1435 0032 62F31743 	 bfi r3,r2,#16,#8
 317:../Dave/Generated/DAC/dac.c **** }
 1436              	 .loc 2 317 0
 1437 0036 1846     	 mov r0,r3
 1438 0038 0C37     	 adds r7,r7,#12
 1439              	.LCFI95:
 1440              	 .cfi_def_cfa_offset 4
 1441 003a BD46     	 mov sp,r7
 1442              	.LCFI96:
 1443              	 .cfi_def_cfa_register 13
 1444              	 
 1445 003c 5DF8047B 	 ldr r7,[sp],#4
 1446              	.LCFI97:
 1447              	 .cfi_restore 7
 1448              	 .cfi_def_cfa_offset 0
 1449 0040 7047     	 bx lr
 1450              	 .cfi_endproc
 1451              	.LFE227:
 1453 0042 00BF     	 .section .text.DAC_Init,"ax",%progbits
 1454              	 .align 2
 1455              	 .global DAC_Init
 1456              	 .thumb
 1457              	 .thumb_func
 1459              	DAC_Init:
 1460              	.LFB228:
 318:../Dave/Generated/DAC/dac.c **** 
 319:../Dave/Generated/DAC/dac.c **** /**
 320:../Dave/Generated/DAC/dac.c ****     * This function initializes DAC
 321:../Dave/Generated/DAC/dac.c ****     * peripheral as per the user configurations
 322:../Dave/Generated/DAC/dac.c **** */
 323:../Dave/Generated/DAC/dac.c **** 
 324:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_Init(const DAC_t * const HandlePtr)
 325:../Dave/Generated/DAC/dac.c **** {
 1461              	 .loc 2 325 0
 1462              	 .cfi_startproc
 1463              	 
 1464              	 
 1465 0000 80B5     	 push {r7,lr}
 1466              	.LCFI98:
 1467              	 .cfi_def_cfa_offset 8
 1468              	 .cfi_offset 7,-8
 1469              	 .cfi_offset 14,-4
 1470 0002 84B0     	 sub sp,sp,#16
 1471              	.LCFI99:
 1472              	 .cfi_def_cfa_offset 24
 1473 0004 00AF     	 add r7,sp,#0
 1474              	.LCFI100:
 1475              	 .cfi_def_cfa_register 7
 1476 0006 7860     	 str r0,[r7,#4]
 326:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status = DAC_STATUS_SUCCESS;
 1477              	 .loc 2 326 0
 1478 0008 0023     	 movs r3,#0
 1479 000a FB73     	 strb r3,[r7,#15]
 327:../Dave/Generated/DAC/dac.c ****   XMC_DAC_CH_STATUS_t api_status;
 328:../Dave/Generated/DAC/dac.c **** 
 329:../Dave/Generated/DAC/dac.c ****   /*Assert variables.*/
 330:../Dave/Generated/DAC/dac.c ****   XMC_ASSERT(" DAC_Init: Passing argument DAC HandlePtr of type DAC_t is Null",
 331:../Dave/Generated/DAC/dac.c ****              (HandlePtr != (DAC_t *)NULL));
 332:../Dave/Generated/DAC/dac.c **** 
 333:../Dave/Generated/DAC/dac.c ****   /* Enable DAC module */
 334:../Dave/Generated/DAC/dac.c ****   XMC_DAC_CH_Init(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,HandlePtr->dac_config_ptr);
 1480              	 .loc 2 334 0
 1481 000c 7B68     	 ldr r3,[r7,#4]
 1482 000e 1968     	 ldr r1,[r3]
 1483 0010 7B68     	 ldr r3,[r7,#4]
 1484 0012 93F82620 	 ldrb r2,[r3,#38]
 1485 0016 7B68     	 ldr r3,[r7,#4]
 1486 0018 5B68     	 ldr r3,[r3,#4]
 1487 001a 0846     	 mov r0,r1
 1488 001c 1146     	 mov r1,r2
 1489 001e 1A46     	 mov r2,r3
 1490 0020 FFF7FEFF 	 bl XMC_DAC_CH_Init
 335:../Dave/Generated/DAC/dac.c **** 
 336:../Dave/Generated/DAC/dac.c **** #if (DAC_ANALOG_IO_USED == 1U)
 337:../Dave/Generated/DAC/dac.c ****   /* ANALOG_IO initialization */
 338:../Dave/Generated/DAC/dac.c ****   status = (DAC_STATUS_t) ANALOG_IO_Init(HandlePtr->analog_io_config_ptr);
 1491              	 .loc 2 338 0
 1492 0024 7B68     	 ldr r3,[r7,#4]
 1493 0026 9B68     	 ldr r3,[r3,#8]
 1494 0028 1846     	 mov r0,r3
 1495 002a FFF7FEFF 	 bl ANALOG_IO_Init
 1496 002e 0346     	 mov r3,r0
 1497 0030 FB73     	 strb r3,[r7,#15]
 339:../Dave/Generated/DAC/dac.c **** #endif
 340:../Dave/Generated/DAC/dac.c **** 
 341:../Dave/Generated/DAC/dac.c ****   /* Configure DAC with user configured mode */
 342:../Dave/Generated/DAC/dac.c ****   api_status = DAC_ModeConfig(HandlePtr);
 1498              	 .loc 2 342 0
 1499 0032 7868     	 ldr r0,[r7,#4]
 1500 0034 FFF7FEFF 	 bl DAC_ModeConfig
 1501 0038 0346     	 mov r3,r0
 1502 003a BB73     	 strb r3,[r7,#14]
 343:../Dave/Generated/DAC/dac.c **** 
 344:../Dave/Generated/DAC/dac.c ****   /* Check if start after initialization is enabled */
 345:../Dave/Generated/DAC/dac.c ****   if(HandlePtr->dac_start_after_init == 0U)
 1503              	 .loc 2 345 0
 1504 003c 7B68     	 ldr r3,[r7,#4]
 1505 003e 93F82C30 	 ldrb r3,[r3,#44]
 1506 0042 002B     	 cmp r3,#0
 1507 0044 09D1     	 bne .L57
 346:../Dave/Generated/DAC/dac.c ****   {
 347:../Dave/Generated/DAC/dac.c ****     XMC_DAC_CH_SetMode(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, XMC_DAC_CH_MODE_IDLE);
 1508              	 .loc 2 347 0
 1509 0046 7B68     	 ldr r3,[r7,#4]
 1510 0048 1A68     	 ldr r2,[r3]
 1511 004a 7B68     	 ldr r3,[r7,#4]
 1512 004c 93F82630 	 ldrb r3,[r3,#38]
 1513 0050 1046     	 mov r0,r2
 1514 0052 1946     	 mov r1,r3
 1515 0054 0022     	 movs r2,#0
 1516 0056 FFF7FEFF 	 bl XMC_DAC_CH_SetMode
 1517              	.L57:
 348:../Dave/Generated/DAC/dac.c ****   }
 349:../Dave/Generated/DAC/dac.c **** 
 350:../Dave/Generated/DAC/dac.c ****   if(1U == HandlePtr->dac_coupled)
 1518              	 .loc 2 350 0
 1519 005a 7B68     	 ldr r3,[r7,#4]
 1520 005c 93F82530 	 ldrb r3,[r3,#37]
 1521 0060 012B     	 cmp r3,#1
 1522 0062 04D1     	 bne .L58
 351:../Dave/Generated/DAC/dac.c ****   {
 352:../Dave/Generated/DAC/dac.c ****     /* Enable Simultaneous Data Mode */
 353:../Dave/Generated/DAC/dac.c ****     XMC_DAC_EnableSimultaneousDataMode(HandlePtr->dac_module_ptr);
 1523              	 .loc 2 353 0
 1524 0064 7B68     	 ldr r3,[r7,#4]
 1525 0066 1B68     	 ldr r3,[r3]
 1526 0068 1846     	 mov r0,r3
 1527 006a FFF7FEFF 	 bl XMC_DAC_EnableSimultaneousDataMode
 1528              	.L58:
 354:../Dave/Generated/DAC/dac.c ****   }
 355:../Dave/Generated/DAC/dac.c **** 
 356:../Dave/Generated/DAC/dac.c ****   if(api_status != XMC_DAC_CH_STATUS_OK)
 1529              	 .loc 2 356 0
 1530 006e BB7B     	 ldrb r3,[r7,#14]
 1531 0070 002B     	 cmp r3,#0
 1532 0072 01D0     	 beq .L59
 357:../Dave/Generated/DAC/dac.c ****   {
 358:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_FAILURE;
 1533              	 .loc 2 358 0
 1534 0074 0123     	 movs r3,#1
 1535 0076 FB73     	 strb r3,[r7,#15]
 1536              	.L59:
 359:../Dave/Generated/DAC/dac.c ****   }
 360:../Dave/Generated/DAC/dac.c **** 
 361:../Dave/Generated/DAC/dac.c ****   return status;
 1537              	 .loc 2 361 0
 1538 0078 FB7B     	 ldrb r3,[r7,#15]
 362:../Dave/Generated/DAC/dac.c **** }
 1539              	 .loc 2 362 0
 1540 007a 1846     	 mov r0,r3
 1541 007c 1037     	 adds r7,r7,#16
 1542              	.LCFI101:
 1543              	 .cfi_def_cfa_offset 8
 1544 007e BD46     	 mov sp,r7
 1545              	.LCFI102:
 1546              	 .cfi_def_cfa_register 13
 1547              	 
 1548 0080 80BD     	 pop {r7,pc}
 1549              	 .cfi_endproc
 1550              	.LFE228:
 1552 0082 00BF     	 .section .text.DAC_Pattern_SetAmplitude,"ax",%progbits
 1553              	 .align 2
 1554              	 .global DAC_Pattern_SetAmplitude
 1555              	 .thumb
 1556              	 .thumb_func
 1558              	DAC_Pattern_SetAmplitude:
 1559              	.LFB229:
 363:../Dave/Generated/DAC/dac.c **** 
 364:../Dave/Generated/DAC/dac.c **** /*
 365:../Dave/Generated/DAC/dac.c ****   * This API will set the amplitude in Pattern Mode.
 366:../Dave/Generated/DAC/dac.c **** */
 367:../Dave/Generated/DAC/dac.c **** void DAC_Pattern_SetAmplitude(const DAC_t * const HandlePtr,DAC_VSS_t Amplitude)
 368:../Dave/Generated/DAC/dac.c **** {
 1560              	 .loc 2 368 0
 1561              	 .cfi_startproc
 1562              	 
 1563              	 
 1564 0000 80B5     	 push {r7,lr}
 1565              	.LCFI103:
 1566              	 .cfi_def_cfa_offset 8
 1567              	 .cfi_offset 7,-8
 1568              	 .cfi_offset 14,-4
 1569 0002 84B0     	 sub sp,sp,#16
 1570              	.LCFI104:
 1571              	 .cfi_def_cfa_offset 24
 1572 0004 00AF     	 add r7,sp,#0
 1573              	.LCFI105:
 1574              	 .cfi_def_cfa_register 7
 1575 0006 7860     	 str r0,[r7,#4]
 1576 0008 0B46     	 mov r3,r1
 1577 000a FB70     	 strb r3,[r7,#3]
 369:../Dave/Generated/DAC/dac.c ****   XMC_DAC_CH_OUTPUT_SCALE_t scale;
 370:../Dave/Generated/DAC/dac.c **** 
 371:../Dave/Generated/DAC/dac.c ****   if(Amplitude > DAC_VSS_0034_mV)
 1578              	 .loc 2 371 0
 1579 000c FB78     	 ldrb r3,[r7,#3]
 1580 000e 052B     	 cmp r3,#5
 1581 0010 03D9     	 bls .L62
 372:../Dave/Generated/DAC/dac.c ****   {
 373:../Dave/Generated/DAC/dac.c ****     /* If amplitude greater or equal to 34mV then scale Up */
 374:../Dave/Generated/DAC/dac.c ****     scale = (XMC_DAC_CH_OUTPUT_SCALE_t)((uint32_t)XMC_DAC_CH_OUTPUT_SCALE_MUL_2 +
 1582              	 .loc 2 374 0
 1583 0012 FB78     	 ldrb r3,[r7,#3]
 1584 0014 0333     	 adds r3,r3,#3
 1585 0016 FB73     	 strb r3,[r7,#15]
 1586 0018 09E0     	 b .L63
 1587              	.L62:
 375:../Dave/Generated/DAC/dac.c ****                                ((uint32_t)Amplitude - (uint32_t)DAC_VSS_0069_mV));
 376:../Dave/Generated/DAC/dac.c ****   }
 377:../Dave/Generated/DAC/dac.c ****   else if(Amplitude < DAC_VSS_0034_mV)
 1588              	 .loc 2 377 0
 1589 001a FB78     	 ldrb r3,[r7,#3]
 1590 001c 042B     	 cmp r3,#4
 1591 001e 04D8     	 bhi .L64
 378:../Dave/Generated/DAC/dac.c ****   {
 379:../Dave/Generated/DAC/dac.c ****     /* If amplitude less than 34mV then scale down */
 380:../Dave/Generated/DAC/dac.c ****     scale = (XMC_DAC_CH_OUTPUT_SCALE_t)((uint32_t)XMC_DAC_CH_OUTPUT_SCALE_DIV_2 +
 1592              	 .loc 2 380 0
 1593 0020 FB78     	 ldrb r3,[r7,#3]
 1594 0022 C3F10503 	 rsb r3,r3,#5
 1595 0026 FB73     	 strb r3,[r7,#15]
 1596 0028 01E0     	 b .L63
 1597              	.L64:
 381:../Dave/Generated/DAC/dac.c ****                               ((uint32_t)DAC_VSS_0017_mV - (uint32_t)Amplitude));
 382:../Dave/Generated/DAC/dac.c ****   }
 383:../Dave/Generated/DAC/dac.c ****   else
 384:../Dave/Generated/DAC/dac.c ****   {
 385:../Dave/Generated/DAC/dac.c ****     /* No scaling required */
 386:../Dave/Generated/DAC/dac.c ****     scale = XMC_DAC_CH_OUTPUT_SCALE_NONE;
 1598              	 .loc 2 386 0
 1599 002a 0023     	 movs r3,#0
 1600 002c FB73     	 strb r3,[r7,#15]
 1601              	.L63:
 387:../Dave/Generated/DAC/dac.c ****   }
 388:../Dave/Generated/DAC/dac.c **** 
 389:../Dave/Generated/DAC/dac.c ****   XMC_DAC_CH_SetOutputScale(HandlePtr->dac_module_ptr,HandlePtr->dac_ch, scale);
 1602              	 .loc 2 389 0
 1603 002e 7B68     	 ldr r3,[r7,#4]
 1604 0030 1968     	 ldr r1,[r3]
 1605 0032 7B68     	 ldr r3,[r7,#4]
 1606 0034 93F82620 	 ldrb r2,[r3,#38]
 1607 0038 FB7B     	 ldrb r3,[r7,#15]
 1608 003a 0846     	 mov r0,r1
 1609 003c 1146     	 mov r1,r2
 1610 003e 1A46     	 mov r2,r3
 1611 0040 FFF7FEFF 	 bl XMC_DAC_CH_SetOutputScale
 390:../Dave/Generated/DAC/dac.c **** }
 1612              	 .loc 2 390 0
 1613 0044 1037     	 adds r7,r7,#16
 1614              	.LCFI106:
 1615              	 .cfi_def_cfa_offset 8
 1616 0046 BD46     	 mov sp,r7
 1617              	.LCFI107:
 1618              	 .cfi_def_cfa_register 13
 1619              	 
 1620 0048 80BD     	 pop {r7,pc}
 1621              	 .cfi_endproc
 1622              	.LFE229:
 1624 004a 00BF     	 .section .text.DAC_Pattern_SetOffset,"ax",%progbits
 1625              	 .align 2
 1626              	 .global DAC_Pattern_SetOffset
 1627              	 .thumb
 1628              	 .thumb_func
 1630              	DAC_Pattern_SetOffset:
 1631              	.LFB230:
 391:../Dave/Generated/DAC/dac.c **** 
 392:../Dave/Generated/DAC/dac.c **** /*
 393:../Dave/Generated/DAC/dac.c ****   * This API will set offset in Pattern Mode.
 394:../Dave/Generated/DAC/dac.c **** */
 395:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_Pattern_SetOffset(const DAC_t * const HandlePtr,int16_t Dc_offset_mv)
 396:../Dave/Generated/DAC/dac.c **** {
 1632              	 .loc 2 396 0
 1633              	 .cfi_startproc
 1634              	 
 1635              	 
 1636 0000 80B5     	 push {r7,lr}
 1637              	.LCFI108:
 1638              	 .cfi_def_cfa_offset 8
 1639              	 .cfi_offset 7,-8
 1640              	 .cfi_offset 14,-4
 1641 0002 86B0     	 sub sp,sp,#24
 1642              	.LCFI109:
 1643              	 .cfi_def_cfa_offset 32
 1644 0004 00AF     	 add r7,sp,#0
 1645              	.LCFI110:
 1646              	 .cfi_def_cfa_register 7
 1647 0006 7860     	 str r0,[r7,#4]
 1648 0008 0B46     	 mov r3,r1
 1649 000a 7B80     	 strh r3,[r7,#2]
 397:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status;
 398:../Dave/Generated/DAC/dac.c ****   uint8_t u_offset;
 399:../Dave/Generated/DAC/dac.c ****   int16_t i_offset;
 400:../Dave/Generated/DAC/dac.c ****   uint16_t amplitude_in_mV;
 401:../Dave/Generated/DAC/dac.c ****   uint32_t scale;
 402:../Dave/Generated/DAC/dac.c **** 
 403:../Dave/Generated/DAC/dac.c ****   scale = (uint32_t)XMC_DAC_CH_GetOutputScale(HandlePtr->dac_module_ptr, HandlePtr->dac_ch);
 1650              	 .loc 2 403 0
 1651 000c 7B68     	 ldr r3,[r7,#4]
 1652 000e 1A68     	 ldr r2,[r3]
 1653 0010 7B68     	 ldr r3,[r7,#4]
 1654 0012 93F82630 	 ldrb r3,[r3,#38]
 1655 0016 1046     	 mov r0,r2
 1656 0018 1946     	 mov r1,r3
 1657 001a FFF7FEFF 	 bl XMC_DAC_CH_GetOutputScale
 1658 001e 0346     	 mov r3,r0
 1659 0020 FB60     	 str r3,[r7,#12]
 404:../Dave/Generated/DAC/dac.c ****   if(scale & DAC_DAC0CFG1_MULDIV_Msk)
 1660              	 .loc 2 404 0
 1661 0022 FB68     	 ldr r3,[r7,#12]
 1662 0024 03F00803 	 and r3,r3,#8
 1663 0028 002B     	 cmp r3,#0
 1664 002a 07D0     	 beq .L66
 405:../Dave/Generated/DAC/dac.c ****   {
 406:../Dave/Generated/DAC/dac.c ****     amplitude_in_mV = (uint16_t)((uint16_t)DAC_VSS_34_MV << (scale & DAC_DAC0CFG1_SCALE_Msk));
 1665              	 .loc 2 406 0
 1666 002c FB68     	 ldr r3,[r7,#12]
 1667 002e 03F00703 	 and r3,r3,#7
 1668 0032 2222     	 movs r2,#34
 1669 0034 02FA03F3 	 lsl r3,r2,r3
 1670 0038 7B82     	 strh r3,[r7,#18]
 1671 003a 06E0     	 b .L67
 1672              	.L66:
 407:../Dave/Generated/DAC/dac.c ****   }
 408:../Dave/Generated/DAC/dac.c ****   else
 409:../Dave/Generated/DAC/dac.c ****   {
 410:../Dave/Generated/DAC/dac.c ****     amplitude_in_mV = (uint16_t)((uint16_t)DAC_VSS_34_MV >> (scale & DAC_DAC0CFG1_SCALE_Msk));
 1673              	 .loc 2 410 0
 1674 003c FB68     	 ldr r3,[r7,#12]
 1675 003e 03F00703 	 and r3,r3,#7
 1676 0042 2222     	 movs r2,#34
 1677 0044 42FA03F3 	 asr r3,r2,r3
 1678 0048 7B82     	 strh r3,[r7,#18]
 1679              	.L67:
 411:../Dave/Generated/DAC/dac.c ****   }
 412:../Dave/Generated/DAC/dac.c **** 
 413:../Dave/Generated/DAC/dac.c ****   i_offset = (Dc_offset_mv - (int16_t)DAC_OFFSET_SIGN_mV);
 1680              	 .loc 2 413 0
 1681 004a 7B88     	 ldrh r3,[r7,#2]
 1682 004c A3F5AF63 	 sub r3,r3,#1400
 1683 0050 9BB2     	 uxth r3,r3
 1684 0052 BB82     	 strh r3,[r7,#20]
 414:../Dave/Generated/DAC/dac.c ****   i_offset = (int16_t)((i_offset * DAC_PATTERN_AMPLITUDE)/ (int16_t)amplitude_in_mV);
 1685              	 .loc 2 414 0
 1686 0054 B7F91420 	 ldrsh r2,[r7,#20]
 1687 0058 1346     	 mov r3,r2
 1688 005a 5B01     	 lsls r3,r3,#5
 1689 005c 9B1A     	 subs r3,r3,r2
 1690 005e 5B00     	 lsls r3,r3,#1
 1691 0060 1A46     	 mov r2,r3
 1692 0062 7B8A     	 ldrh r3,[r7,#18]
 1693 0064 1BB2     	 sxth r3,r3
 1694 0066 92FBF3F3 	 sdiv r3,r2,r3
 1695 006a BB82     	 strh r3,[r7,#20]
 415:../Dave/Generated/DAC/dac.c **** 
 416:../Dave/Generated/DAC/dac.c ****   if((i_offset > DAC_OFFSET_MAX_SIGN) || (i_offset < DAC_OFFSET_MIN_SIGN))
 1696              	 .loc 2 416 0
 1697 006c B7F91430 	 ldrsh r3,[r7,#20]
 1698 0070 7F2B     	 cmp r3,#127
 1699 0072 04DC     	 bgt .L68
 1700              	 .loc 2 416 0 is_stmt 0 discriminator 1
 1701 0074 B7F91430 	 ldrsh r3,[r7,#20]
 1702 0078 13F1800F 	 cmn r3,#128
 1703 007c 02DA     	 bge .L69
 1704              	.L68:
 417:../Dave/Generated/DAC/dac.c ****   {
 418:../Dave/Generated/DAC/dac.c ****     /* Offset not configurable */
 419:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_API_FAIL;
 1705              	 .loc 2 419 0 is_stmt 1
 1706 007e 0223     	 movs r3,#2
 1707 0080 FB75     	 strb r3,[r7,#23]
 1708 0082 26E0     	 b .L70
 1709              	.L69:
 420:../Dave/Generated/DAC/dac.c ****   }
 421:../Dave/Generated/DAC/dac.c ****   else
 422:../Dave/Generated/DAC/dac.c ****   {
 423:../Dave/Generated/DAC/dac.c ****     if(HandlePtr->dac_config_ptr->output_negation)
 1710              	 .loc 2 423 0
 1711 0084 7B68     	 ldr r3,[r7,#4]
 1712 0086 5B68     	 ldr r3,[r3,#4]
 1713 0088 DB78     	 ldrb r3,[r3,#3]
 1714 008a 03F01003 	 and r3,r3,#16
 1715 008e DBB2     	 uxtb r3,r3
 1716 0090 002B     	 cmp r3,#0
 1717 0092 03D0     	 beq .L71
 424:../Dave/Generated/DAC/dac.c ****     {
 425:../Dave/Generated/DAC/dac.c ****       /* compensation of inversion*/
 426:../Dave/Generated/DAC/dac.c ****       i_offset = -i_offset;
 1718              	 .loc 2 426 0
 1719 0094 BB8A     	 ldrh r3,[r7,#20]
 1720 0096 5B42     	 negs r3,r3
 1721 0098 9BB2     	 uxth r3,r3
 1722 009a BB82     	 strh r3,[r7,#20]
 1723              	.L71:
 427:../Dave/Generated/DAC/dac.c ****     }
 428:../Dave/Generated/DAC/dac.c ****     
 429:../Dave/Generated/DAC/dac.c ****     /* Convert int32_t to uint8_t */
 430:../Dave/Generated/DAC/dac.c ****     if(i_offset < 0)
 1724              	 .loc 2 430 0
 1725 009c B7F91430 	 ldrsh r3,[r7,#20]
 1726 00a0 002B     	 cmp r3,#0
 1727 00a2 07DA     	 bge .L72
 431:../Dave/Generated/DAC/dac.c ****     {
 432:../Dave/Generated/DAC/dac.c ****       i_offset = (0x100 + i_offset);
 1728              	 .loc 2 432 0
 1729 00a4 BB8A     	 ldrh r3,[r7,#20]
 1730 00a6 03F58073 	 add r3,r3,#256
 1731 00aa 9BB2     	 uxth r3,r3
 1732 00ac BB82     	 strh r3,[r7,#20]
 433:../Dave/Generated/DAC/dac.c ****       u_offset = (uint8_t)(i_offset);
 1733              	 .loc 2 433 0
 1734 00ae BB8A     	 ldrh r3,[r7,#20]
 1735 00b0 BB75     	 strb r3,[r7,#22]
 1736 00b2 01E0     	 b .L73
 1737              	.L72:
 434:../Dave/Generated/DAC/dac.c ****     }
 435:../Dave/Generated/DAC/dac.c ****     else
 436:../Dave/Generated/DAC/dac.c ****     {
 437:../Dave/Generated/DAC/dac.c ****       u_offset = (uint8_t)((uint8_t)(i_offset) & (uint8_t)0x0FF);
 1738              	 .loc 2 437 0
 1739 00b4 BB8A     	 ldrh r3,[r7,#20]
 1740 00b6 BB75     	 strb r3,[r7,#22]
 1741              	.L73:
 438:../Dave/Generated/DAC/dac.c ****     }
 439:../Dave/Generated/DAC/dac.c **** 
 440:../Dave/Generated/DAC/dac.c ****     XMC_DAC_CH_SetOutputOffset(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,u_offset);
 1742              	 .loc 2 440 0
 1743 00b8 7B68     	 ldr r3,[r7,#4]
 1744 00ba 1968     	 ldr r1,[r3]
 1745 00bc 7B68     	 ldr r3,[r7,#4]
 1746 00be 93F82620 	 ldrb r2,[r3,#38]
 1747 00c2 BB7D     	 ldrb r3,[r7,#22]
 1748 00c4 0846     	 mov r0,r1
 1749 00c6 1146     	 mov r1,r2
 1750 00c8 1A46     	 mov r2,r3
 1751 00ca FFF7FEFF 	 bl XMC_DAC_CH_SetOutputOffset
 441:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_SUCCESS;
 1752              	 .loc 2 441 0
 1753 00ce 0023     	 movs r3,#0
 1754 00d0 FB75     	 strb r3,[r7,#23]
 1755              	.L70:
 442:../Dave/Generated/DAC/dac.c ****   }
 443:../Dave/Generated/DAC/dac.c ****   return status;
 1756              	 .loc 2 443 0
 1757 00d2 FB7D     	 ldrb r3,[r7,#23]
 444:../Dave/Generated/DAC/dac.c **** }
 1758              	 .loc 2 444 0
 1759 00d4 1846     	 mov r0,r3
 1760 00d6 1837     	 adds r7,r7,#24
 1761              	.LCFI111:
 1762              	 .cfi_def_cfa_offset 8
 1763 00d8 BD46     	 mov sp,r7
 1764              	.LCFI112:
 1765              	 .cfi_def_cfa_register 13
 1766              	 
 1767 00da 80BD     	 pop {r7,pc}
 1768              	 .cfi_endproc
 1769              	.LFE230:
 1771              	 .section .text.DAC_SingleValue_SetValue_s16,"ax",%progbits
 1772              	 .align 2
 1773              	 .global DAC_SingleValue_SetValue_s16
 1774              	 .thumb
 1775              	 .thumb_func
 1777              	DAC_SingleValue_SetValue_s16:
 1778              	.LFB231:
 445:../Dave/Generated/DAC/dac.c **** 
 446:../Dave/Generated/DAC/dac.c **** /*
 447:../Dave/Generated/DAC/dac.c ****   * This API will set data value in Single Value Signed Mode.
 448:../Dave/Generated/DAC/dac.c **** */
 449:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_SingleValue_SetValue_s16(const DAC_t * const HandlePtr,int16_t Data)
 450:../Dave/Generated/DAC/dac.c **** {
 1779              	 .loc 2 450 0
 1780              	 .cfi_startproc
 1781              	 
 1782              	 
 1783 0000 80B5     	 push {r7,lr}
 1784              	.LCFI113:
 1785              	 .cfi_def_cfa_offset 8
 1786              	 .cfi_offset 7,-8
 1787              	 .cfi_offset 14,-4
 1788 0002 84B0     	 sub sp,sp,#16
 1789              	.LCFI114:
 1790              	 .cfi_def_cfa_offset 24
 1791 0004 00AF     	 add r7,sp,#0
 1792              	.LCFI115:
 1793              	 .cfi_def_cfa_register 7
 1794 0006 7860     	 str r0,[r7,#4]
 1795 0008 0B46     	 mov r3,r1
 1796 000a 7B80     	 strh r3,[r7,#2]
 451:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status;
 452:../Dave/Generated/DAC/dac.c ****   int16_t temp_data = 0;
 1797              	 .loc 2 452 0
 1798 000c 0023     	 movs r3,#0
 1799 000e BB81     	 strh r3,[r7,#12]
 453:../Dave/Generated/DAC/dac.c ****   if((DAC_DATA_VALUE_MAX_SIGN >= Data) && (DAC_DATA_VALUE_MIN_SIGN < Data))
 1800              	 .loc 2 453 0
 1801 0010 B7F90230 	 ldrsh r3,[r7,#2]
 1802 0014 B3F5006F 	 cmp r3,#2048
 1803 0018 1EDA     	 bge .L76
 1804              	 .loc 2 453 0 is_stmt 0 discriminator 1
 1805 001a B7F90230 	 ldrsh r3,[r7,#2]
 1806 001e 13F5006F 	 cmn r3,#2048
 1807 0022 19DD     	 ble .L76
 454:../Dave/Generated/DAC/dac.c ****   {
 455:../Dave/Generated/DAC/dac.c ****     if(Data < 0)
 1808              	 .loc 2 455 0 is_stmt 1
 1809 0024 B7F90230 	 ldrsh r3,[r7,#2]
 1810 0028 002B     	 cmp r3,#0
 1811 002a 05DA     	 bge .L77
 456:../Dave/Generated/DAC/dac.c ****     {
 457:../Dave/Generated/DAC/dac.c ****       temp_data = (0x1000 + Data);
 1812              	 .loc 2 457 0
 1813 002c 7B88     	 ldrh r3,[r7,#2]
 1814 002e 03F58053 	 add r3,r3,#4096
 1815 0032 9BB2     	 uxth r3,r3
 1816 0034 BB81     	 strh r3,[r7,#12]
 1817 0036 01E0     	 b .L78
 1818              	.L77:
 458:../Dave/Generated/DAC/dac.c ****     }
 459:../Dave/Generated/DAC/dac.c ****     else
 460:../Dave/Generated/DAC/dac.c ****     {
 461:../Dave/Generated/DAC/dac.c ****       temp_data = Data;
 1819              	 .loc 2 461 0
 1820 0038 7B88     	 ldrh r3,[r7,#2]
 1821 003a BB81     	 strh r3,[r7,#12]
 1822              	.L78:
 462:../Dave/Generated/DAC/dac.c ****     }
 463:../Dave/Generated/DAC/dac.c **** 
 464:../Dave/Generated/DAC/dac.c ****     /* Update Corresponding CH Data register */
 465:../Dave/Generated/DAC/dac.c ****     XMC_DAC_CH_Write(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,(uint16_t)temp_data);
 1823              	 .loc 2 465 0
 1824 003c 7B68     	 ldr r3,[r7,#4]
 1825 003e 1968     	 ldr r1,[r3]
 1826 0040 7B68     	 ldr r3,[r7,#4]
 1827 0042 93F82620 	 ldrb r2,[r3,#38]
 1828 0046 BB89     	 ldrh r3,[r7,#12]
 1829 0048 0846     	 mov r0,r1
 1830 004a 1146     	 mov r1,r2
 1831 004c 1A46     	 mov r2,r3
 1832 004e FFF7FEFF 	 bl XMC_DAC_CH_Write
 466:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_SUCCESS;
 1833              	 .loc 2 466 0
 1834 0052 0023     	 movs r3,#0
 1835 0054 FB73     	 strb r3,[r7,#15]
 1836 0056 01E0     	 b .L79
 1837              	.L76:
 467:../Dave/Generated/DAC/dac.c ****   }
 468:../Dave/Generated/DAC/dac.c ****   else
 469:../Dave/Generated/DAC/dac.c ****   {
 470:../Dave/Generated/DAC/dac.c ****     /* Data Values are out of range */
 471:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_API_FAIL;
 1838              	 .loc 2 471 0
 1839 0058 0223     	 movs r3,#2
 1840 005a FB73     	 strb r3,[r7,#15]
 1841              	.L79:
 472:../Dave/Generated/DAC/dac.c ****   }
 473:../Dave/Generated/DAC/dac.c ****   return status;
 1842              	 .loc 2 473 0
 1843 005c FB7B     	 ldrb r3,[r7,#15]
 474:../Dave/Generated/DAC/dac.c **** }
 1844              	 .loc 2 474 0
 1845 005e 1846     	 mov r0,r3
 1846 0060 1037     	 adds r7,r7,#16
 1847              	.LCFI116:
 1848              	 .cfi_def_cfa_offset 8
 1849 0062 BD46     	 mov sp,r7
 1850              	.LCFI117:
 1851              	 .cfi_def_cfa_register 13
 1852              	 
 1853 0064 80BD     	 pop {r7,pc}
 1854              	 .cfi_endproc
 1855              	.LFE231:
 1857 0066 00BF     	 .section .text.DAC_SingleValue_SetValue_s16_Coupled,"ax",%progbits
 1858              	 .align 2
 1859              	 .global DAC_SingleValue_SetValue_s16_Coupled
 1860              	 .thumb
 1861              	 .thumb_func
 1863              	DAC_SingleValue_SetValue_s16_Coupled:
 1864              	.LFB232:
 475:../Dave/Generated/DAC/dac.c **** 
 476:../Dave/Generated/DAC/dac.c **** /*
 477:../Dave/Generated/DAC/dac.c ****   * This API will set data value in Single Value Signed Mode when couple mode is selected.
 478:../Dave/Generated/DAC/dac.c **** */
 479:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_SingleValue_SetValue_s16_Coupled(const DAC_t * const HandlePtr,int16_t Data0, int1
 480:../Dave/Generated/DAC/dac.c **** {
 1865              	 .loc 2 480 0
 1866              	 .cfi_startproc
 1867              	 
 1868              	 
 1869 0000 80B5     	 push {r7,lr}
 1870              	.LCFI118:
 1871              	 .cfi_def_cfa_offset 8
 1872              	 .cfi_offset 7,-8
 1873              	 .cfi_offset 14,-4
 1874 0002 84B0     	 sub sp,sp,#16
 1875              	.LCFI119:
 1876              	 .cfi_def_cfa_offset 24
 1877 0004 00AF     	 add r7,sp,#0
 1878              	.LCFI120:
 1879              	 .cfi_def_cfa_register 7
 1880 0006 7860     	 str r0,[r7,#4]
 1881 0008 0B46     	 mov r3,r1
 1882 000a 7B80     	 strh r3,[r7,#2]
 1883 000c 1346     	 mov r3,r2
 1884 000e 3B80     	 strh r3,[r7]
 481:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status;
 482:../Dave/Generated/DAC/dac.c ****   int16_t temp_data0,temp_data1 = 0;
 1885              	 .loc 2 482 0
 1886 0010 0023     	 movs r3,#0
 1887 0012 7B81     	 strh r3,[r7,#10]
 483:../Dave/Generated/DAC/dac.c ****   if((DAC_DATA_VALUE_MAX_SIGN >= Data0) && (DAC_DATA_VALUE_MAX_SIGN >= Data1) &&
 1888              	 .loc 2 483 0
 1889 0014 B7F90230 	 ldrsh r3,[r7,#2]
 1890 0018 B3F5006F 	 cmp r3,#2048
 1891 001c 32DA     	 bge .L82
 1892              	 .loc 2 483 0 is_stmt 0 discriminator 1
 1893 001e B7F90030 	 ldrsh r3,[r7]
 1894 0022 B3F5006F 	 cmp r3,#2048
 1895 0026 2DDA     	 bge .L82
 1896              	 .loc 2 483 0 discriminator 2
 1897 0028 B7F90230 	 ldrsh r3,[r7,#2]
 1898 002c 13F5006F 	 cmn r3,#2048
 1899 0030 28DD     	 ble .L82
 484:../Dave/Generated/DAC/dac.c ****      (DAC_DATA_VALUE_MIN_SIGN < Data0) && (DAC_DATA_VALUE_MIN_SIGN < Data1))
 1900              	 .loc 2 484 0 is_stmt 1
 1901 0032 B7F90030 	 ldrsh r3,[r7]
 1902 0036 13F5006F 	 cmn r3,#2048
 1903 003a 23DD     	 ble .L82
 485:../Dave/Generated/DAC/dac.c ****   {
 486:../Dave/Generated/DAC/dac.c ****     if(Data0 < 0)
 1904              	 .loc 2 486 0
 1905 003c B7F90230 	 ldrsh r3,[r7,#2]
 1906 0040 002B     	 cmp r3,#0
 1907 0042 05DA     	 bge .L83
 487:../Dave/Generated/DAC/dac.c ****     {
 488:../Dave/Generated/DAC/dac.c ****       temp_data0 = (0x1000 + Data0);
 1908              	 .loc 2 488 0
 1909 0044 7B88     	 ldrh r3,[r7,#2]
 1910 0046 03F58053 	 add r3,r3,#4096
 1911 004a 9BB2     	 uxth r3,r3
 1912 004c BB81     	 strh r3,[r7,#12]
 1913 004e 01E0     	 b .L84
 1914              	.L83:
 489:../Dave/Generated/DAC/dac.c ****     }
 490:../Dave/Generated/DAC/dac.c ****     else
 491:../Dave/Generated/DAC/dac.c ****     {
 492:../Dave/Generated/DAC/dac.c ****       temp_data0 = Data0;
 1915              	 .loc 2 492 0
 1916 0050 7B88     	 ldrh r3,[r7,#2]
 1917 0052 BB81     	 strh r3,[r7,#12]
 1918              	.L84:
 493:../Dave/Generated/DAC/dac.c ****     }
 494:../Dave/Generated/DAC/dac.c **** 
 495:../Dave/Generated/DAC/dac.c ****     if(Data1 < 0)
 1919              	 .loc 2 495 0
 1920 0054 B7F90030 	 ldrsh r3,[r7]
 1921 0058 002B     	 cmp r3,#0
 1922 005a 05DA     	 bge .L85
 496:../Dave/Generated/DAC/dac.c ****     {
 497:../Dave/Generated/DAC/dac.c ****       temp_data1 = (0x1000 + Data1);
 1923              	 .loc 2 497 0
 1924 005c 3B88     	 ldrh r3,[r7]
 1925 005e 03F58053 	 add r3,r3,#4096
 1926 0062 9BB2     	 uxth r3,r3
 1927 0064 7B81     	 strh r3,[r7,#10]
 1928 0066 01E0     	 b .L86
 1929              	.L85:
 498:../Dave/Generated/DAC/dac.c ****     }
 499:../Dave/Generated/DAC/dac.c ****     else
 500:../Dave/Generated/DAC/dac.c ****     {
 501:../Dave/Generated/DAC/dac.c ****       temp_data1 = Data1;
 1930              	 .loc 2 501 0
 1931 0068 3B88     	 ldrh r3,[r7]
 1932 006a 7B81     	 strh r3,[r7,#10]
 1933              	.L86:
 502:../Dave/Generated/DAC/dac.c ****     }
 503:../Dave/Generated/DAC/dac.c ****     XMC_DAC_SimultaneousWrite(HandlePtr->dac_module_ptr,(uint16_t)temp_data0,(uint16_t)temp_data1);
 1934              	 .loc 2 503 0
 1935 006c 7B68     	 ldr r3,[r7,#4]
 1936 006e 1968     	 ldr r1,[r3]
 1937 0070 BA89     	 ldrh r2,[r7,#12]
 1938 0072 7B89     	 ldrh r3,[r7,#10]
 1939 0074 0846     	 mov r0,r1
 1940 0076 1146     	 mov r1,r2
 1941 0078 1A46     	 mov r2,r3
 1942 007a FFF7FEFF 	 bl XMC_DAC_SimultaneousWrite
 504:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_SUCCESS;
 1943              	 .loc 2 504 0
 1944 007e 0023     	 movs r3,#0
 1945 0080 FB73     	 strb r3,[r7,#15]
 1946 0082 01E0     	 b .L87
 1947              	.L82:
 505:../Dave/Generated/DAC/dac.c ****   }
 506:../Dave/Generated/DAC/dac.c ****   else
 507:../Dave/Generated/DAC/dac.c ****   {
 508:../Dave/Generated/DAC/dac.c ****     /* Data Values are out of range */
 509:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_API_FAIL;
 1948              	 .loc 2 509 0
 1949 0084 0223     	 movs r3,#2
 1950 0086 FB73     	 strb r3,[r7,#15]
 1951              	.L87:
 510:../Dave/Generated/DAC/dac.c ****   }
 511:../Dave/Generated/DAC/dac.c ****   return status;
 1952              	 .loc 2 511 0
 1953 0088 FB7B     	 ldrb r3,[r7,#15]
 512:../Dave/Generated/DAC/dac.c **** }
 1954              	 .loc 2 512 0
 1955 008a 1846     	 mov r0,r3
 1956 008c 1037     	 adds r7,r7,#16
 1957              	.LCFI121:
 1958              	 .cfi_def_cfa_offset 8
 1959 008e BD46     	 mov sp,r7
 1960              	.LCFI122:
 1961              	 .cfi_def_cfa_register 13
 1962              	 
 1963 0090 80BD     	 pop {r7,pc}
 1964              	 .cfi_endproc
 1965              	.LFE232:
 1967 0092 00BF     	 .section .text.DAC_SingleValue_SetValue_u16,"ax",%progbits
 1968              	 .align 2
 1969              	 .global DAC_SingleValue_SetValue_u16
 1970              	 .thumb
 1971              	 .thumb_func
 1973              	DAC_SingleValue_SetValue_u16:
 1974              	.LFB233:
 513:../Dave/Generated/DAC/dac.c **** 
 514:../Dave/Generated/DAC/dac.c **** /*
 515:../Dave/Generated/DAC/dac.c ****   * This API will set data value in Single Value in Unsigned Mode.
 516:../Dave/Generated/DAC/dac.c **** */
 517:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_SingleValue_SetValue_u16(const DAC_t * const HandlePtr,uint16_t Data)
 518:../Dave/Generated/DAC/dac.c **** {
 1975              	 .loc 2 518 0
 1976              	 .cfi_startproc
 1977              	 
 1978              	 
 1979 0000 80B5     	 push {r7,lr}
 1980              	.LCFI123:
 1981              	 .cfi_def_cfa_offset 8
 1982              	 .cfi_offset 7,-8
 1983              	 .cfi_offset 14,-4
 1984 0002 84B0     	 sub sp,sp,#16
 1985              	.LCFI124:
 1986              	 .cfi_def_cfa_offset 24
 1987 0004 00AF     	 add r7,sp,#0
 1988              	.LCFI125:
 1989              	 .cfi_def_cfa_register 7
 1990 0006 7860     	 str r0,[r7,#4]
 1991 0008 0B46     	 mov r3,r1
 1992 000a 7B80     	 strh r3,[r7,#2]
 519:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status;
 520:../Dave/Generated/DAC/dac.c ****   if(DAC_DATA_VALUE_MAX_USIGN >= Data)
 1993              	 .loc 2 520 0
 1994 000c 7B88     	 ldrh r3,[r7,#2]
 1995 000e B3F5805F 	 cmp r3,#4096
 1996 0012 0DD2     	 bcs .L90
 521:../Dave/Generated/DAC/dac.c ****   {
 522:../Dave/Generated/DAC/dac.c ****     /* Update Corresponding CH Data register */
 523:../Dave/Generated/DAC/dac.c ****     XMC_DAC_CH_Write(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,Data);
 1997              	 .loc 2 523 0
 1998 0014 7B68     	 ldr r3,[r7,#4]
 1999 0016 1968     	 ldr r1,[r3]
 2000 0018 7B68     	 ldr r3,[r7,#4]
 2001 001a 93F82620 	 ldrb r2,[r3,#38]
 2002 001e 7B88     	 ldrh r3,[r7,#2]
 2003 0020 0846     	 mov r0,r1
 2004 0022 1146     	 mov r1,r2
 2005 0024 1A46     	 mov r2,r3
 2006 0026 FFF7FEFF 	 bl XMC_DAC_CH_Write
 524:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_SUCCESS;
 2007              	 .loc 2 524 0
 2008 002a 0023     	 movs r3,#0
 2009 002c FB73     	 strb r3,[r7,#15]
 2010 002e 01E0     	 b .L91
 2011              	.L90:
 525:../Dave/Generated/DAC/dac.c ****   }
 526:../Dave/Generated/DAC/dac.c ****   else
 527:../Dave/Generated/DAC/dac.c ****   {
 528:../Dave/Generated/DAC/dac.c ****     /* Data Values are out of range */
 529:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_API_FAIL;
 2012              	 .loc 2 529 0
 2013 0030 0223     	 movs r3,#2
 2014 0032 FB73     	 strb r3,[r7,#15]
 2015              	.L91:
 530:../Dave/Generated/DAC/dac.c ****   }
 531:../Dave/Generated/DAC/dac.c ****   return status;
 2016              	 .loc 2 531 0
 2017 0034 FB7B     	 ldrb r3,[r7,#15]
 532:../Dave/Generated/DAC/dac.c **** }
 2018              	 .loc 2 532 0
 2019 0036 1846     	 mov r0,r3
 2020 0038 1037     	 adds r7,r7,#16
 2021              	.LCFI126:
 2022              	 .cfi_def_cfa_offset 8
 2023 003a BD46     	 mov sp,r7
 2024              	.LCFI127:
 2025              	 .cfi_def_cfa_register 13
 2026              	 
 2027 003c 80BD     	 pop {r7,pc}
 2028              	 .cfi_endproc
 2029              	.LFE233:
 2031 003e 00BF     	 .section .text.DAC_SingleValue_SetValue_u16_Coupled,"ax",%progbits
 2032              	 .align 2
 2033              	 .global DAC_SingleValue_SetValue_u16_Coupled
 2034              	 .thumb
 2035              	 .thumb_func
 2037              	DAC_SingleValue_SetValue_u16_Coupled:
 2038              	.LFB234:
 533:../Dave/Generated/DAC/dac.c **** 
 534:../Dave/Generated/DAC/dac.c **** /*
 535:../Dave/Generated/DAC/dac.c ****   * This API will set data value in Single Value in Unsigned Mode when couple mode is selected.
 536:../Dave/Generated/DAC/dac.c **** */
 537:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_SingleValue_SetValue_u16_Coupled(const DAC_t * const HandlePtr,uint16_t Data0, uin
 538:../Dave/Generated/DAC/dac.c **** {
 2039              	 .loc 2 538 0
 2040              	 .cfi_startproc
 2041              	 
 2042              	 
 2043 0000 80B5     	 push {r7,lr}
 2044              	.LCFI128:
 2045              	 .cfi_def_cfa_offset 8
 2046              	 .cfi_offset 7,-8
 2047              	 .cfi_offset 14,-4
 2048 0002 84B0     	 sub sp,sp,#16
 2049              	.LCFI129:
 2050              	 .cfi_def_cfa_offset 24
 2051 0004 00AF     	 add r7,sp,#0
 2052              	.LCFI130:
 2053              	 .cfi_def_cfa_register 7
 2054 0006 7860     	 str r0,[r7,#4]
 2055 0008 0B46     	 mov r3,r1
 2056 000a 7B80     	 strh r3,[r7,#2]
 2057 000c 1346     	 mov r3,r2
 2058 000e 3B80     	 strh r3,[r7]
 539:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status;
 540:../Dave/Generated/DAC/dac.c ****   if((DAC_DATA_VALUE_MAX_USIGN >= Data0) && (DAC_DATA_VALUE_MAX_USIGN >= Data1))
 2059              	 .loc 2 540 0
 2060 0010 7B88     	 ldrh r3,[r7,#2]
 2061 0012 B3F5805F 	 cmp r3,#4096
 2062 0016 0FD2     	 bcs .L94
 2063              	 .loc 2 540 0 is_stmt 0 discriminator 1
 2064 0018 3B88     	 ldrh r3,[r7]
 2065 001a B3F5805F 	 cmp r3,#4096
 2066 001e 0BD2     	 bcs .L94
 541:../Dave/Generated/DAC/dac.c ****   {
 542:../Dave/Generated/DAC/dac.c ****     /* Coupled Mode Enabled */
 543:../Dave/Generated/DAC/dac.c ****     XMC_DAC_SimultaneousWrite(HandlePtr->dac_module_ptr,Data0,Data1);
 2067              	 .loc 2 543 0 is_stmt 1
 2068 0020 7B68     	 ldr r3,[r7,#4]
 2069 0022 1968     	 ldr r1,[r3]
 2070 0024 7A88     	 ldrh r2,[r7,#2]
 2071 0026 3B88     	 ldrh r3,[r7]
 2072 0028 0846     	 mov r0,r1
 2073 002a 1146     	 mov r1,r2
 2074 002c 1A46     	 mov r2,r3
 2075 002e FFF7FEFF 	 bl XMC_DAC_SimultaneousWrite
 544:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_SUCCESS;
 2076              	 .loc 2 544 0
 2077 0032 0023     	 movs r3,#0
 2078 0034 FB73     	 strb r3,[r7,#15]
 2079 0036 01E0     	 b .L95
 2080              	.L94:
 545:../Dave/Generated/DAC/dac.c ****   }
 546:../Dave/Generated/DAC/dac.c ****   else
 547:../Dave/Generated/DAC/dac.c ****   {
 548:../Dave/Generated/DAC/dac.c ****     /* Data Values are out of range */
 549:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_API_FAIL;
 2081              	 .loc 2 549 0
 2082 0038 0223     	 movs r3,#2
 2083 003a FB73     	 strb r3,[r7,#15]
 2084              	.L95:
 550:../Dave/Generated/DAC/dac.c ****   }
 551:../Dave/Generated/DAC/dac.c ****   return status;
 2085              	 .loc 2 551 0
 2086 003c FB7B     	 ldrb r3,[r7,#15]
 552:../Dave/Generated/DAC/dac.c **** }
 2087              	 .loc 2 552 0
 2088 003e 1846     	 mov r0,r3
 2089 0040 1037     	 adds r7,r7,#16
 2090              	.LCFI131:
 2091              	 .cfi_def_cfa_offset 8
 2092 0042 BD46     	 mov sp,r7
 2093              	.LCFI132:
 2094              	 .cfi_def_cfa_register 13
 2095              	 
 2096 0044 80BD     	 pop {r7,pc}
 2097              	 .cfi_endproc
 2098              	.LFE234:
 2100 0046 00BF     	 .section .text.DAC_Ramp_SetStart,"ax",%progbits
 2101              	 .align 2
 2102              	 .global DAC_Ramp_SetStart
 2103              	 .thumb
 2104              	 .thumb_func
 2106              	DAC_Ramp_SetStart:
 2107              	.LFB235:
 553:../Dave/Generated/DAC/dac.c **** 
 554:../Dave/Generated/DAC/dac.c **** /*
 555:../Dave/Generated/DAC/dac.c ****   * This API will set Ramp Start in Ramp Mode.
 556:../Dave/Generated/DAC/dac.c **** */
 557:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_Ramp_SetStart(DAC_t * const HandlePtr,uint16_t ramp_start_mv)
 558:../Dave/Generated/DAC/dac.c **** {
 2108              	 .loc 2 558 0
 2109              	 .cfi_startproc
 2110              	 
 2111              	 
 2112 0000 80B5     	 push {r7,lr}
 2113              	.LCFI133:
 2114              	 .cfi_def_cfa_offset 8
 2115              	 .cfi_offset 7,-8
 2116              	 .cfi_offset 14,-4
 2117 0002 84B0     	 sub sp,sp,#16
 2118              	.LCFI134:
 2119              	 .cfi_def_cfa_offset 24
 2120 0004 00AF     	 add r7,sp,#0
 2121              	.LCFI135:
 2122              	 .cfi_def_cfa_register 7
 2123 0006 7860     	 str r0,[r7,#4]
 2124 0008 0B46     	 mov r3,r1
 2125 000a 7B80     	 strh r3,[r7,#2]
 559:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status = DAC_STATUS_SUCCESS;
 2126              	 .loc 2 559 0
 2127 000c 0023     	 movs r3,#0
 2128 000e FB73     	 strb r3,[r7,#15]
 560:../Dave/Generated/DAC/dac.c ****   uint16_t start_ramp,stop_ramp,temp;
 561:../Dave/Generated/DAC/dac.c **** 
 562:../Dave/Generated/DAC/dac.c ****   if((DAC_OUT_MAX_MV >= ramp_start_mv) && (DAC_OUT_MIN_MV <= ramp_start_mv))
 2129              	 .loc 2 562 0
 2130 0010 7B88     	 ldrh r3,[r7,#2]
 2131 0012 40F6C412 	 movw r2,#2500
 2132 0016 9342     	 cmp r3,r2
 2133 0018 00F29480 	 bhi .L98
 2134              	 .loc 2 562 0 is_stmt 0 discriminator 1
 2135 001c 7B88     	 ldrh r3,[r7,#2]
 2136 001e B3F5967F 	 cmp r3,#300
 2137 0022 C0F08F80 	 bcc .L98
 563:../Dave/Generated/DAC/dac.c ****   {
 564:../Dave/Generated/DAC/dac.c ****     #if (UC_SERIES == XMC45)
 565:../Dave/Generated/DAC/dac.c ****       if(ramp_start_mv >= HandlePtr->dac_ramp_stop_mv)
 566:../Dave/Generated/DAC/dac.c ****       {
 567:../Dave/Generated/DAC/dac.c ****         /* Negative Ramp is not possible for XMC45 device */
 568:../Dave/Generated/DAC/dac.c ****         status = DAC_STATUS_API_FAIL;
 569:../Dave/Generated/DAC/dac.c ****       }
 570:../Dave/Generated/DAC/dac.c ****     if( status == DAC_STATUS_SUCCESS )
 571:../Dave/Generated/DAC/dac.c ****     {
 572:../Dave/Generated/DAC/dac.c ****     #endif
 573:../Dave/Generated/DAC/dac.c ****       if(ramp_start_mv > HandlePtr->dac_ramp_stop_mv)
 2138              	 .loc 2 573 0 is_stmt 1
 2139 0026 7B68     	 ldr r3,[r7,#4]
 2140 0028 5B8C     	 ldrh r3,[r3,#34]
 2141 002a 7A88     	 ldrh r2,[r7,#2]
 2142 002c 9A42     	 cmp r2,r3
 2143 002e 1AD9     	 bls .L99
 574:../Dave/Generated/DAC/dac.c ****       {
 575:../Dave/Generated/DAC/dac.c ****         start_ramp = (uint16_t)(((HandlePtr->dac_ramp_stop_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STEP
 2144              	 .loc 2 575 0
 2145 0030 7B68     	 ldr r3,[r7,#4]
 2146 0032 5B8C     	 ldrh r3,[r3,#34]
 2147 0034 1A46     	 mov r2,r3
 2148 0036 1346     	 mov r3,r2
 2149 0038 1B03     	 lsls r3,r3,#12
 2150 003a 9A1A     	 subs r2,r3,r2
 2151 003c 454B     	 ldr r3,.L105
 2152 003e 1344     	 add r3,r3,r2
 2153 0040 DB08     	 lsrs r3,r3,#3
 2154 0042 454A     	 ldr r2,.L105+4
 2155 0044 A2FB0323 	 umull r2,r3,r2,r3
 2156 0048 5B09     	 lsrs r3,r3,#5
 2157 004a BB81     	 strh r3,[r7,#12]
 576:../Dave/Generated/DAC/dac.c ****         stop_ramp = (uint16_t)(((ramp_start_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STEPS) / DAC_VSS_MA
 2158              	 .loc 2 576 0
 2159 004c 7A88     	 ldrh r2,[r7,#2]
 2160 004e 1346     	 mov r3,r2
 2161 0050 1B03     	 lsls r3,r3,#12
 2162 0052 9A1A     	 subs r2,r3,r2
 2163 0054 3F4B     	 ldr r3,.L105
 2164 0056 1344     	 add r3,r3,r2
 2165 0058 DB08     	 lsrs r3,r3,#3
 2166 005a 3F4A     	 ldr r2,.L105+4
 2167 005c A2FB0323 	 umull r2,r3,r2,r3
 2168 0060 5B09     	 lsrs r3,r3,#5
 2169 0062 7B81     	 strh r3,[r7,#10]
 2170 0064 19E0     	 b .L100
 2171              	.L99:
 577:../Dave/Generated/DAC/dac.c ****       }
 578:../Dave/Generated/DAC/dac.c ****       else
 579:../Dave/Generated/DAC/dac.c ****       {
 580:../Dave/Generated/DAC/dac.c ****         start_ramp = (uint16_t)(((ramp_start_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STEPS) / DAC_VSS_M
 2172              	 .loc 2 580 0
 2173 0066 7A88     	 ldrh r2,[r7,#2]
 2174 0068 1346     	 mov r3,r2
 2175 006a 1B03     	 lsls r3,r3,#12
 2176 006c 9A1A     	 subs r2,r3,r2
 2177 006e 394B     	 ldr r3,.L105
 2178 0070 1344     	 add r3,r3,r2
 2179 0072 DB08     	 lsrs r3,r3,#3
 2180 0074 384A     	 ldr r2,.L105+4
 2181 0076 A2FB0323 	 umull r2,r3,r2,r3
 2182 007a 5B09     	 lsrs r3,r3,#5
 2183 007c BB81     	 strh r3,[r7,#12]
 581:../Dave/Generated/DAC/dac.c ****         stop_ramp = (uint16_t)(((HandlePtr->dac_ramp_stop_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STEPS
 2184              	 .loc 2 581 0
 2185 007e 7B68     	 ldr r3,[r7,#4]
 2186 0080 5B8C     	 ldrh r3,[r3,#34]
 2187 0082 1A46     	 mov r2,r3
 2188 0084 1346     	 mov r3,r2
 2189 0086 1B03     	 lsls r3,r3,#12
 2190 0088 9A1A     	 subs r2,r3,r2
 2191 008a 324B     	 ldr r3,.L105
 2192 008c 1344     	 add r3,r3,r2
 2193 008e DB08     	 lsrs r3,r3,#3
 2194 0090 314A     	 ldr r2,.L105+4
 2195 0092 A2FB0323 	 umull r2,r3,r2,r3
 2196 0096 5B09     	 lsrs r3,r3,#5
 2197 0098 7B81     	 strh r3,[r7,#10]
 2198              	.L100:
 582:../Dave/Generated/DAC/dac.c ****       }
 583:../Dave/Generated/DAC/dac.c **** 
 584:../Dave/Generated/DAC/dac.c ****       HandlePtr->dac_ramp_start_mv = ramp_start_mv;
 2199              	 .loc 2 584 0
 2200 009a 7B68     	 ldr r3,[r7,#4]
 2201 009c 7A88     	 ldrh r2,[r7,#2]
 2202 009e 1A84     	 strh r2,[r3,#32]
 585:../Dave/Generated/DAC/dac.c ****       if(HandlePtr->dac_ramp_start_mv > HandlePtr->dac_ramp_stop_mv)
 2203              	 .loc 2 585 0
 2204 00a0 7B68     	 ldr r3,[r7,#4]
 2205 00a2 1A8C     	 ldrh r2,[r3,#32]
 2206 00a4 7B68     	 ldr r3,[r7,#4]
 2207 00a6 5B8C     	 ldrh r3,[r3,#34]
 2208 00a8 9A42     	 cmp r2,r3
 2209 00aa 2BD9     	 bls .L101
 586:../Dave/Generated/DAC/dac.c ****       {
 587:../Dave/Generated/DAC/dac.c ****         /* Shift start/stop for negative ramp */
 588:../Dave/Generated/DAC/dac.c ****         temp = start_ramp;
 2210              	 .loc 2 588 0
 2211 00ac BB89     	 ldrh r3,[r7,#12]
 2212 00ae 3B81     	 strh r3,[r7,#8]
 589:../Dave/Generated/DAC/dac.c ****         start_ramp = DAC_RAMP_MAX_STEPS - stop_ramp;
 2213              	 .loc 2 589 0
 2214 00b0 7B89     	 ldrh r3,[r7,#10]
 2215 00b2 C3F57F63 	 rsb r3,r3,#4080
 2216 00b6 0F33     	 adds r3,r3,#15
 2217 00b8 BB81     	 strh r3,[r7,#12]
 590:../Dave/Generated/DAC/dac.c ****         stop_ramp  = DAC_RAMP_MAX_STEPS - temp;
 2218              	 .loc 2 590 0
 2219 00ba 3B89     	 ldrh r3,[r7,#8]
 2220 00bc C3F57F63 	 rsb r3,r3,#4080
 2221 00c0 0F33     	 adds r3,r3,#15
 2222 00c2 7B81     	 strh r3,[r7,#10]
 591:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_SetRampStop(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, stop_ramp);
 2223              	 .loc 2 591 0
 2224 00c4 7B68     	 ldr r3,[r7,#4]
 2225 00c6 1968     	 ldr r1,[r3]
 2226 00c8 7B68     	 ldr r3,[r7,#4]
 2227 00ca 93F82620 	 ldrb r2,[r3,#38]
 2228 00ce 7B89     	 ldrh r3,[r7,#10]
 2229 00d0 0846     	 mov r0,r1
 2230 00d2 1146     	 mov r1,r2
 2231 00d4 1A46     	 mov r2,r3
 2232 00d6 FFF7FEFF 	 bl XMC_DAC_CH_SetRampStop
 592:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_SetRampStart(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, start_ramp);
 2233              	 .loc 2 592 0
 2234 00da 7B68     	 ldr r3,[r7,#4]
 2235 00dc 1968     	 ldr r1,[r3]
 2236 00de 7B68     	 ldr r3,[r7,#4]
 2237 00e0 93F82620 	 ldrb r2,[r3,#38]
 2238 00e4 BB89     	 ldrh r3,[r7,#12]
 2239 00e6 0846     	 mov r0,r1
 2240 00e8 1146     	 mov r1,r2
 2241 00ea 1A46     	 mov r2,r3
 2242 00ec FFF7FEFF 	 bl XMC_DAC_CH_SetRampStart
 593:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_EnableOutputNegation(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
 2243              	 .loc 2 593 0
 2244 00f0 7B68     	 ldr r3,[r7,#4]
 2245 00f2 1A68     	 ldr r2,[r3]
 2246 00f4 7B68     	 ldr r3,[r7,#4]
 2247 00f6 93F82630 	 ldrb r3,[r3,#38]
 2248 00fa 1046     	 mov r0,r2
 2249 00fc 1946     	 mov r1,r3
 2250 00fe FFF7FEFF 	 bl XMC_DAC_CH_EnableOutputNegation
 585:../Dave/Generated/DAC/dac.c ****       {
 2251              	 .loc 2 585 0
 2252 0102 21E0     	 b .L103
 2253              	.L101:
 594:../Dave/Generated/DAC/dac.c ****       }
 595:../Dave/Generated/DAC/dac.c ****       else
 596:../Dave/Generated/DAC/dac.c ****       {
 597:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_DisableOutputNegation(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
 2254              	 .loc 2 597 0
 2255 0104 7B68     	 ldr r3,[r7,#4]
 2256 0106 1A68     	 ldr r2,[r3]
 2257 0108 7B68     	 ldr r3,[r7,#4]
 2258 010a 93F82630 	 ldrb r3,[r3,#38]
 2259 010e 1046     	 mov r0,r2
 2260 0110 1946     	 mov r1,r3
 2261 0112 FFF7FEFF 	 bl XMC_DAC_CH_DisableOutputNegation
 598:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_SetRampStop(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, stop_ramp);
 2262              	 .loc 2 598 0
 2263 0116 7B68     	 ldr r3,[r7,#4]
 2264 0118 1968     	 ldr r1,[r3]
 2265 011a 7B68     	 ldr r3,[r7,#4]
 2266 011c 93F82620 	 ldrb r2,[r3,#38]
 2267 0120 7B89     	 ldrh r3,[r7,#10]
 2268 0122 0846     	 mov r0,r1
 2269 0124 1146     	 mov r1,r2
 2270 0126 1A46     	 mov r2,r3
 2271 0128 FFF7FEFF 	 bl XMC_DAC_CH_SetRampStop
 599:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_SetRampStart(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, start_ramp);
 2272              	 .loc 2 599 0
 2273 012c 7B68     	 ldr r3,[r7,#4]
 2274 012e 1968     	 ldr r1,[r3]
 2275 0130 7B68     	 ldr r3,[r7,#4]
 2276 0132 93F82620 	 ldrb r2,[r3,#38]
 2277 0136 BB89     	 ldrh r3,[r7,#12]
 2278 0138 0846     	 mov r0,r1
 2279 013a 1146     	 mov r1,r2
 2280 013c 1A46     	 mov r2,r3
 2281 013e FFF7FEFF 	 bl XMC_DAC_CH_SetRampStart
 585:../Dave/Generated/DAC/dac.c ****       {
 2282              	 .loc 2 585 0
 2283 0142 01E0     	 b .L103
 2284              	.L98:
 600:../Dave/Generated/DAC/dac.c ****       }
 601:../Dave/Generated/DAC/dac.c ****     #if(UC_SERIES == XMC45)
 602:../Dave/Generated/DAC/dac.c ****     }
 603:../Dave/Generated/DAC/dac.c ****     #endif
 604:../Dave/Generated/DAC/dac.c ****   }
 605:../Dave/Generated/DAC/dac.c ****   else
 606:../Dave/Generated/DAC/dac.c ****   {
 607:../Dave/Generated/DAC/dac.c ****     /* Ramp start Value is out of range */
 608:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_API_FAIL;
 2285              	 .loc 2 608 0
 2286 0144 0223     	 movs r3,#2
 2287 0146 FB73     	 strb r3,[r7,#15]
 2288              	.L103:
 609:../Dave/Generated/DAC/dac.c ****   }
 610:../Dave/Generated/DAC/dac.c ****   return status;
 2289              	 .loc 2 610 0
 2290 0148 FB7B     	 ldrb r3,[r7,#15]
 611:../Dave/Generated/DAC/dac.c **** }
 2291              	 .loc 2 611 0
 2292 014a 1846     	 mov r0,r3
 2293 014c 1037     	 adds r7,r7,#16
 2294              	.LCFI136:
 2295              	 .cfi_def_cfa_offset 8
 2296 014e BD46     	 mov sp,r7
 2297              	.LCFI137:
 2298              	 .cfi_def_cfa_register 13
 2299              	 
 2300 0150 80BD     	 pop {r7,pc}
 2301              	.L106:
 2302 0152 00BF     	 .align 2
 2303              	.L105:
 2304 0154 2C41EDFF 	 .word -1228500
 2305 0158 DD01CA1D 	 .word 499778013
 2306              	 .cfi_endproc
 2307              	.LFE235:
 2309              	 .section .text.DAC_Ramp_SetStop,"ax",%progbits
 2310              	 .align 2
 2311              	 .global DAC_Ramp_SetStop
 2312              	 .thumb
 2313              	 .thumb_func
 2315              	DAC_Ramp_SetStop:
 2316              	.LFB236:
 612:../Dave/Generated/DAC/dac.c **** 
 613:../Dave/Generated/DAC/dac.c **** /*
 614:../Dave/Generated/DAC/dac.c ****   * This API will set Ramp Stop in Ramp Mode.
 615:../Dave/Generated/DAC/dac.c **** */
 616:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_Ramp_SetStop(DAC_t * const HandlePtr,uint16_t ramp_stop_mv)
 617:../Dave/Generated/DAC/dac.c **** {
 2317              	 .loc 2 617 0
 2318              	 .cfi_startproc
 2319              	 
 2320              	 
 2321 0000 80B5     	 push {r7,lr}
 2322              	.LCFI138:
 2323              	 .cfi_def_cfa_offset 8
 2324              	 .cfi_offset 7,-8
 2325              	 .cfi_offset 14,-4
 2326 0002 84B0     	 sub sp,sp,#16
 2327              	.LCFI139:
 2328              	 .cfi_def_cfa_offset 24
 2329 0004 00AF     	 add r7,sp,#0
 2330              	.LCFI140:
 2331              	 .cfi_def_cfa_register 7
 2332 0006 7860     	 str r0,[r7,#4]
 2333 0008 0B46     	 mov r3,r1
 2334 000a 7B80     	 strh r3,[r7,#2]
 618:../Dave/Generated/DAC/dac.c ****   uint16_t start_ramp,stop_ramp,temp;
 619:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status = DAC_STATUS_SUCCESS;
 2335              	 .loc 2 619 0
 2336 000c 0023     	 movs r3,#0
 2337 000e FB72     	 strb r3,[r7,#11]
 620:../Dave/Generated/DAC/dac.c **** 
 621:../Dave/Generated/DAC/dac.c ****   if((DAC_OUT_MAX_MV >= ramp_stop_mv)&&(DAC_OUT_MIN_MV <= ramp_stop_mv))
 2338              	 .loc 2 621 0
 2339 0010 7B88     	 ldrh r3,[r7,#2]
 2340 0012 40F6C412 	 movw r2,#2500
 2341 0016 9342     	 cmp r3,r2
 2342 0018 00F29480 	 bhi .L108
 2343              	 .loc 2 621 0 is_stmt 0 discriminator 1
 2344 001c 7B88     	 ldrh r3,[r7,#2]
 2345 001e B3F5967F 	 cmp r3,#300
 2346 0022 C0F08F80 	 bcc .L108
 622:../Dave/Generated/DAC/dac.c ****   {
 623:../Dave/Generated/DAC/dac.c ****     #if (UC_SERIES == XMC45)
 624:../Dave/Generated/DAC/dac.c ****       if(ramp_stop_mv <= HandlePtr->dac_ramp_start_mv)
 625:../Dave/Generated/DAC/dac.c ****       {
 626:../Dave/Generated/DAC/dac.c ****         /* Negative Ramp is not possible for XMC45 device */
 627:../Dave/Generated/DAC/dac.c ****         status = DAC_STATUS_API_FAIL;
 628:../Dave/Generated/DAC/dac.c ****       }
 629:../Dave/Generated/DAC/dac.c ****     if( status == DAC_STATUS_SUCCESS )
 630:../Dave/Generated/DAC/dac.c ****     {
 631:../Dave/Generated/DAC/dac.c ****     #endif
 632:../Dave/Generated/DAC/dac.c ****       if(HandlePtr->dac_ramp_start_mv > ramp_stop_mv)
 2347              	 .loc 2 632 0 is_stmt 1
 2348 0026 7B68     	 ldr r3,[r7,#4]
 2349 0028 1B8C     	 ldrh r3,[r3,#32]
 2350 002a 7A88     	 ldrh r2,[r7,#2]
 2351 002c 9A42     	 cmp r2,r3
 2352 002e 1AD2     	 bcs .L109
 633:../Dave/Generated/DAC/dac.c ****       {
 634:../Dave/Generated/DAC/dac.c ****         stop_ramp = (uint16_t)(((HandlePtr->dac_ramp_start_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STEP
 2353              	 .loc 2 634 0
 2354 0030 7B68     	 ldr r3,[r7,#4]
 2355 0032 1B8C     	 ldrh r3,[r3,#32]
 2356 0034 1A46     	 mov r2,r3
 2357 0036 1346     	 mov r3,r2
 2358 0038 1B03     	 lsls r3,r3,#12
 2359 003a 9A1A     	 subs r2,r3,r2
 2360 003c 454B     	 ldr r3,.L115
 2361 003e 1344     	 add r3,r3,r2
 2362 0040 DB08     	 lsrs r3,r3,#3
 2363 0042 454A     	 ldr r2,.L115+4
 2364 0044 A2FB0323 	 umull r2,r3,r2,r3
 2365 0048 5B09     	 lsrs r3,r3,#5
 2366 004a BB81     	 strh r3,[r7,#12]
 635:../Dave/Generated/DAC/dac.c ****         start_ramp = (uint16_t)(((ramp_stop_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STEPS) / DAC_VSS_MA
 2367              	 .loc 2 635 0
 2368 004c 7A88     	 ldrh r2,[r7,#2]
 2369 004e 1346     	 mov r3,r2
 2370 0050 1B03     	 lsls r3,r3,#12
 2371 0052 9A1A     	 subs r2,r3,r2
 2372 0054 3F4B     	 ldr r3,.L115
 2373 0056 1344     	 add r3,r3,r2
 2374 0058 DB08     	 lsrs r3,r3,#3
 2375 005a 3F4A     	 ldr r2,.L115+4
 2376 005c A2FB0323 	 umull r2,r3,r2,r3
 2377 0060 5B09     	 lsrs r3,r3,#5
 2378 0062 FB81     	 strh r3,[r7,#14]
 2379 0064 19E0     	 b .L110
 2380              	.L109:
 636:../Dave/Generated/DAC/dac.c ****       }
 637:../Dave/Generated/DAC/dac.c ****       else
 638:../Dave/Generated/DAC/dac.c ****       {
 639:../Dave/Generated/DAC/dac.c ****         stop_ramp = (uint16_t)(((ramp_stop_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STEPS) / DAC_VSS_MAX
 2381              	 .loc 2 639 0
 2382 0066 7A88     	 ldrh r2,[r7,#2]
 2383 0068 1346     	 mov r3,r2
 2384 006a 1B03     	 lsls r3,r3,#12
 2385 006c 9A1A     	 subs r2,r3,r2
 2386 006e 394B     	 ldr r3,.L115
 2387 0070 1344     	 add r3,r3,r2
 2388 0072 DB08     	 lsrs r3,r3,#3
 2389 0074 384A     	 ldr r2,.L115+4
 2390 0076 A2FB0323 	 umull r2,r3,r2,r3
 2391 007a 5B09     	 lsrs r3,r3,#5
 2392 007c BB81     	 strh r3,[r7,#12]
 640:../Dave/Generated/DAC/dac.c ****         start_ramp = (uint16_t)(((HandlePtr->dac_ramp_start_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STE
 2393              	 .loc 2 640 0
 2394 007e 7B68     	 ldr r3,[r7,#4]
 2395 0080 1B8C     	 ldrh r3,[r3,#32]
 2396 0082 1A46     	 mov r2,r3
 2397 0084 1346     	 mov r3,r2
 2398 0086 1B03     	 lsls r3,r3,#12
 2399 0088 9A1A     	 subs r2,r3,r2
 2400 008a 324B     	 ldr r3,.L115
 2401 008c 1344     	 add r3,r3,r2
 2402 008e DB08     	 lsrs r3,r3,#3
 2403 0090 314A     	 ldr r2,.L115+4
 2404 0092 A2FB0323 	 umull r2,r3,r2,r3
 2405 0096 5B09     	 lsrs r3,r3,#5
 2406 0098 FB81     	 strh r3,[r7,#14]
 2407              	.L110:
 641:../Dave/Generated/DAC/dac.c ****       }
 642:../Dave/Generated/DAC/dac.c **** 
 643:../Dave/Generated/DAC/dac.c ****       HandlePtr->dac_ramp_stop_mv = ramp_stop_mv;
 2408              	 .loc 2 643 0
 2409 009a 7B68     	 ldr r3,[r7,#4]
 2410 009c 7A88     	 ldrh r2,[r7,#2]
 2411 009e 5A84     	 strh r2,[r3,#34]
 644:../Dave/Generated/DAC/dac.c ****       if(HandlePtr->dac_ramp_start_mv > HandlePtr->dac_ramp_stop_mv)
 2412              	 .loc 2 644 0
 2413 00a0 7B68     	 ldr r3,[r7,#4]
 2414 00a2 1A8C     	 ldrh r2,[r3,#32]
 2415 00a4 7B68     	 ldr r3,[r7,#4]
 2416 00a6 5B8C     	 ldrh r3,[r3,#34]
 2417 00a8 9A42     	 cmp r2,r3
 2418 00aa 2BD9     	 bls .L111
 645:../Dave/Generated/DAC/dac.c ****       {
 646:../Dave/Generated/DAC/dac.c ****         /* Shift start/stop for negative ramp */
 647:../Dave/Generated/DAC/dac.c ****         temp = start_ramp;
 2419              	 .loc 2 647 0
 2420 00ac FB89     	 ldrh r3,[r7,#14]
 2421 00ae 3B81     	 strh r3,[r7,#8]
 648:../Dave/Generated/DAC/dac.c ****         start_ramp = DAC_RAMP_MAX_STEPS - stop_ramp;
 2422              	 .loc 2 648 0
 2423 00b0 BB89     	 ldrh r3,[r7,#12]
 2424 00b2 C3F57F63 	 rsb r3,r3,#4080
 2425 00b6 0F33     	 adds r3,r3,#15
 2426 00b8 FB81     	 strh r3,[r7,#14]
 649:../Dave/Generated/DAC/dac.c ****         stop_ramp  = DAC_RAMP_MAX_STEPS - temp;
 2427              	 .loc 2 649 0
 2428 00ba 3B89     	 ldrh r3,[r7,#8]
 2429 00bc C3F57F63 	 rsb r3,r3,#4080
 2430 00c0 0F33     	 adds r3,r3,#15
 2431 00c2 BB81     	 strh r3,[r7,#12]
 650:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_SetRampStart(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, start_ramp);
 2432              	 .loc 2 650 0
 2433 00c4 7B68     	 ldr r3,[r7,#4]
 2434 00c6 1968     	 ldr r1,[r3]
 2435 00c8 7B68     	 ldr r3,[r7,#4]
 2436 00ca 93F82620 	 ldrb r2,[r3,#38]
 2437 00ce FB89     	 ldrh r3,[r7,#14]
 2438 00d0 0846     	 mov r0,r1
 2439 00d2 1146     	 mov r1,r2
 2440 00d4 1A46     	 mov r2,r3
 2441 00d6 FFF7FEFF 	 bl XMC_DAC_CH_SetRampStart
 651:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_SetRampStop(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, stop_ramp);
 2442              	 .loc 2 651 0
 2443 00da 7B68     	 ldr r3,[r7,#4]
 2444 00dc 1968     	 ldr r1,[r3]
 2445 00de 7B68     	 ldr r3,[r7,#4]
 2446 00e0 93F82620 	 ldrb r2,[r3,#38]
 2447 00e4 BB89     	 ldrh r3,[r7,#12]
 2448 00e6 0846     	 mov r0,r1
 2449 00e8 1146     	 mov r1,r2
 2450 00ea 1A46     	 mov r2,r3
 2451 00ec FFF7FEFF 	 bl XMC_DAC_CH_SetRampStop
 652:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_EnableOutputNegation(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
 2452              	 .loc 2 652 0
 2453 00f0 7B68     	 ldr r3,[r7,#4]
 2454 00f2 1A68     	 ldr r2,[r3]
 2455 00f4 7B68     	 ldr r3,[r7,#4]
 2456 00f6 93F82630 	 ldrb r3,[r3,#38]
 2457 00fa 1046     	 mov r0,r2
 2458 00fc 1946     	 mov r1,r3
 2459 00fe FFF7FEFF 	 bl XMC_DAC_CH_EnableOutputNegation
 644:../Dave/Generated/DAC/dac.c ****       {
 2460              	 .loc 2 644 0
 2461 0102 21E0     	 b .L113
 2462              	.L111:
 653:../Dave/Generated/DAC/dac.c ****       }
 654:../Dave/Generated/DAC/dac.c ****       else
 655:../Dave/Generated/DAC/dac.c ****       {
 656:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_DisableOutputNegation(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
 2463              	 .loc 2 656 0
 2464 0104 7B68     	 ldr r3,[r7,#4]
 2465 0106 1A68     	 ldr r2,[r3]
 2466 0108 7B68     	 ldr r3,[r7,#4]
 2467 010a 93F82630 	 ldrb r3,[r3,#38]
 2468 010e 1046     	 mov r0,r2
 2469 0110 1946     	 mov r1,r3
 2470 0112 FFF7FEFF 	 bl XMC_DAC_CH_DisableOutputNegation
 657:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_SetRampStart(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, start_ramp);
 2471              	 .loc 2 657 0
 2472 0116 7B68     	 ldr r3,[r7,#4]
 2473 0118 1968     	 ldr r1,[r3]
 2474 011a 7B68     	 ldr r3,[r7,#4]
 2475 011c 93F82620 	 ldrb r2,[r3,#38]
 2476 0120 FB89     	 ldrh r3,[r7,#14]
 2477 0122 0846     	 mov r0,r1
 2478 0124 1146     	 mov r1,r2
 2479 0126 1A46     	 mov r2,r3
 2480 0128 FFF7FEFF 	 bl XMC_DAC_CH_SetRampStart
 658:../Dave/Generated/DAC/dac.c ****         XMC_DAC_CH_SetRampStop(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, stop_ramp);
 2481              	 .loc 2 658 0
 2482 012c 7B68     	 ldr r3,[r7,#4]
 2483 012e 1968     	 ldr r1,[r3]
 2484 0130 7B68     	 ldr r3,[r7,#4]
 2485 0132 93F82620 	 ldrb r2,[r3,#38]
 2486 0136 BB89     	 ldrh r3,[r7,#12]
 2487 0138 0846     	 mov r0,r1
 2488 013a 1146     	 mov r1,r2
 2489 013c 1A46     	 mov r2,r3
 2490 013e FFF7FEFF 	 bl XMC_DAC_CH_SetRampStop
 644:../Dave/Generated/DAC/dac.c ****       {
 2491              	 .loc 2 644 0
 2492 0142 01E0     	 b .L113
 2493              	.L108:
 659:../Dave/Generated/DAC/dac.c ****       }
 660:../Dave/Generated/DAC/dac.c ****     #if(UC_SERIES == XMC45)
 661:../Dave/Generated/DAC/dac.c ****     }
 662:../Dave/Generated/DAC/dac.c ****     #endif
 663:../Dave/Generated/DAC/dac.c ****   }
 664:../Dave/Generated/DAC/dac.c ****   else
 665:../Dave/Generated/DAC/dac.c ****   {
 666:../Dave/Generated/DAC/dac.c ****     /* Ramp start Value is out of range */
 667:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_API_FAIL;
 2494              	 .loc 2 667 0
 2495 0144 0223     	 movs r3,#2
 2496 0146 FB72     	 strb r3,[r7,#11]
 2497              	.L113:
 668:../Dave/Generated/DAC/dac.c ****   }
 669:../Dave/Generated/DAC/dac.c ****   return status;
 2498              	 .loc 2 669 0
 2499 0148 FB7A     	 ldrb r3,[r7,#11]
 670:../Dave/Generated/DAC/dac.c **** }
 2500              	 .loc 2 670 0
 2501 014a 1846     	 mov r0,r3
 2502 014c 1037     	 adds r7,r7,#16
 2503              	.LCFI141:
 2504              	 .cfi_def_cfa_offset 8
 2505 014e BD46     	 mov sp,r7
 2506              	.LCFI142:
 2507              	 .cfi_def_cfa_register 13
 2508              	 
 2509 0150 80BD     	 pop {r7,pc}
 2510              	.L116:
 2511 0152 00BF     	 .align 2
 2512              	.L115:
 2513 0154 2C41EDFF 	 .word -1228500
 2514 0158 DD01CA1D 	 .word 499778013
 2515              	 .cfi_endproc
 2516              	.LFE236:
 2518              	 .section .text.DAC_Ramp_SetFrequency,"ax",%progbits
 2519              	 .align 2
 2520              	 .global DAC_Ramp_SetFrequency
 2521              	 .thumb
 2522              	 .thumb_func
 2524              	DAC_Ramp_SetFrequency:
 2525              	.LFB237:
 671:../Dave/Generated/DAC/dac.c **** 
 672:../Dave/Generated/DAC/dac.c **** /*
 673:../Dave/Generated/DAC/dac.c ****  * This API will set Ramp frequency in Ramp Mode.
 674:../Dave/Generated/DAC/dac.c **** */
 675:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_Ramp_SetFrequency(const DAC_t * const HandlePtr,uint32_t Frequency_Hz)
 676:../Dave/Generated/DAC/dac.c **** {
 2526              	 .loc 2 676 0
 2527              	 .cfi_startproc
 2528              	 
 2529              	 
 2530 0000 80B5     	 push {r7,lr}
 2531              	.LCFI143:
 2532              	 .cfi_def_cfa_offset 8
 2533              	 .cfi_offset 7,-8
 2534              	 .cfi_offset 14,-4
 2535 0002 86B0     	 sub sp,sp,#24
 2536              	.LCFI144:
 2537              	 .cfi_def_cfa_offset 32
 2538 0004 00AF     	 add r7,sp,#0
 2539              	.LCFI145:
 2540              	 .cfi_def_cfa_register 7
 2541 0006 7860     	 str r0,[r7,#4]
 2542 0008 3960     	 str r1,[r7]
 677:../Dave/Generated/DAC/dac.c ****   uint16_t start_ramp;
 678:../Dave/Generated/DAC/dac.c ****   uint16_t stop_ramp;
 679:../Dave/Generated/DAC/dac.c ****   uint32_t clk_divider = 0U;
 2543              	 .loc 2 679 0
 2544 000a 0023     	 movs r3,#0
 2545 000c 3B61     	 str r3,[r7,#16]
 680:../Dave/Generated/DAC/dac.c ****   uint16_t temp_steps;
 681:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status = DAC_STATUS_SUCCESS;
 2546              	 .loc 2 681 0
 2547 000e 0023     	 movs r3,#0
 2548 0010 FB73     	 strb r3,[r7,#15]
 682:../Dave/Generated/DAC/dac.c ****   uint32_t temp_freq;
 683:../Dave/Generated/DAC/dac.c **** 
 684:../Dave/Generated/DAC/dac.c ****   if((HandlePtr->dac_input_trigger == XMC_DAC_CH_TRIGGER_INTERNAL) && (Frequency_Hz != 0U))
 2549              	 .loc 2 684 0
 2550 0012 7B68     	 ldr r3,[r7,#4]
 2551 0014 1B69     	 ldr r3,[r3,#16]
 2552 0016 002B     	 cmp r3,#0
 2553 0018 40F09C80 	 bne .L118
 2554              	 .loc 2 684 0 is_stmt 0 discriminator 1
 2555 001c 3B68     	 ldr r3,[r7]
 2556 001e 002B     	 cmp r3,#0
 2557 0020 00F09880 	 beq .L118
 685:../Dave/Generated/DAC/dac.c ****   {
 686:../Dave/Generated/DAC/dac.c ****     if(HandlePtr->dac_ramp_start_mv > HandlePtr->dac_ramp_stop_mv)
 2558              	 .loc 2 686 0 is_stmt 1
 2559 0024 7B68     	 ldr r3,[r7,#4]
 2560 0026 1A8C     	 ldrh r2,[r3,#32]
 2561 0028 7B68     	 ldr r3,[r7,#4]
 2562 002a 5B8C     	 ldrh r3,[r3,#34]
 2563 002c 9A42     	 cmp r2,r3
 2564 002e 1CD9     	 bls .L119
 687:../Dave/Generated/DAC/dac.c ****     {
 688:../Dave/Generated/DAC/dac.c ****       start_ramp = (uint16_t)(((HandlePtr->dac_ramp_stop_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STEPS)
 2565              	 .loc 2 688 0
 2566 0030 7B68     	 ldr r3,[r7,#4]
 2567 0032 5B8C     	 ldrh r3,[r3,#34]
 2568 0034 1A46     	 mov r2,r3
 2569 0036 1346     	 mov r3,r2
 2570 0038 1B03     	 lsls r3,r3,#12
 2571 003a 9A1A     	 subs r2,r3,r2
 2572 003c 494B     	 ldr r3,.L129
 2573 003e 1344     	 add r3,r3,r2
 2574 0040 DB08     	 lsrs r3,r3,#3
 2575 0042 494A     	 ldr r2,.L129+4
 2576 0044 A2FB0323 	 umull r2,r3,r2,r3
 2577 0048 5B09     	 lsrs r3,r3,#5
 2578 004a FB82     	 strh r3,[r7,#22]
 689:../Dave/Generated/DAC/dac.c ****       stop_ramp  = (uint16_t)(((HandlePtr->dac_ramp_start_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STEPS
 2579              	 .loc 2 689 0
 2580 004c 7B68     	 ldr r3,[r7,#4]
 2581 004e 1B8C     	 ldrh r3,[r3,#32]
 2582 0050 1A46     	 mov r2,r3
 2583 0052 1346     	 mov r3,r2
 2584 0054 1B03     	 lsls r3,r3,#12
 2585 0056 9A1A     	 subs r2,r3,r2
 2586 0058 424B     	 ldr r3,.L129
 2587 005a 1344     	 add r3,r3,r2
 2588 005c DB08     	 lsrs r3,r3,#3
 2589 005e 424A     	 ldr r2,.L129+4
 2590 0060 A2FB0323 	 umull r2,r3,r2,r3
 2591 0064 5B09     	 lsrs r3,r3,#5
 2592 0066 BB82     	 strh r3,[r7,#20]
 2593 0068 1BE0     	 b .L120
 2594              	.L119:
 690:../Dave/Generated/DAC/dac.c ****     }
 691:../Dave/Generated/DAC/dac.c ****     else
 692:../Dave/Generated/DAC/dac.c ****     {
 693:../Dave/Generated/DAC/dac.c ****       start_ramp = (uint16_t)(((HandlePtr->dac_ramp_start_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STEPS
 2595              	 .loc 2 693 0
 2596 006a 7B68     	 ldr r3,[r7,#4]
 2597 006c 1B8C     	 ldrh r3,[r3,#32]
 2598 006e 1A46     	 mov r2,r3
 2599 0070 1346     	 mov r3,r2
 2600 0072 1B03     	 lsls r3,r3,#12
 2601 0074 9A1A     	 subs r2,r3,r2
 2602 0076 3B4B     	 ldr r3,.L129
 2603 0078 1344     	 add r3,r3,r2
 2604 007a DB08     	 lsrs r3,r3,#3
 2605 007c 3A4A     	 ldr r2,.L129+4
 2606 007e A2FB0323 	 umull r2,r3,r2,r3
 2607 0082 5B09     	 lsrs r3,r3,#5
 2608 0084 FB82     	 strh r3,[r7,#22]
 694:../Dave/Generated/DAC/dac.c ****       stop_ramp  = (uint16_t)(((HandlePtr->dac_ramp_stop_mv - DAC_OUT_MIN_MV) * DAC_RAMP_MAX_STEPS)
 2609              	 .loc 2 694 0
 2610 0086 7B68     	 ldr r3,[r7,#4]
 2611 0088 5B8C     	 ldrh r3,[r3,#34]
 2612 008a 1A46     	 mov r2,r3
 2613 008c 1346     	 mov r3,r2
 2614 008e 1B03     	 lsls r3,r3,#12
 2615 0090 9A1A     	 subs r2,r3,r2
 2616 0092 344B     	 ldr r3,.L129
 2617 0094 1344     	 add r3,r3,r2
 2618 0096 DB08     	 lsrs r3,r3,#3
 2619 0098 334A     	 ldr r2,.L129+4
 2620 009a A2FB0323 	 umull r2,r3,r2,r3
 2621 009e 5B09     	 lsrs r3,r3,#5
 2622 00a0 BB82     	 strh r3,[r7,#20]
 2623              	.L120:
 695:../Dave/Generated/DAC/dac.c ****     }
 696:../Dave/Generated/DAC/dac.c **** 
 697:../Dave/Generated/DAC/dac.c ****     temp_steps = (uint16_t)((stop_ramp - start_ramp) + 1U);
 2624              	 .loc 2 697 0
 2625 00a2 BA8A     	 ldrh r2,[r7,#20]
 2626 00a4 FB8A     	 ldrh r3,[r7,#22]
 2627 00a6 D31A     	 subs r3,r2,r3
 2628 00a8 9BB2     	 uxth r3,r3
 2629 00aa 0133     	 adds r3,r3,#1
 2630 00ac BB81     	 strh r3,[r7,#12]
 698:../Dave/Generated/DAC/dac.c **** 
 699:../Dave/Generated/DAC/dac.c ****     if(stop_ramp == start_ramp)
 2631              	 .loc 2 699 0
 2632 00ae BA8A     	 ldrh r2,[r7,#20]
 2633 00b0 FB8A     	 ldrh r3,[r7,#22]
 2634 00b2 9A42     	 cmp r2,r3
 2635 00b4 02D1     	 bne .L121
 700:../Dave/Generated/DAC/dac.c ****     {
 701:../Dave/Generated/DAC/dac.c ****       status = DAC_STATUS_API_FAIL;
 2636              	 .loc 2 701 0
 2637 00b6 0223     	 movs r3,#2
 2638 00b8 FB73     	 strb r3,[r7,#15]
 2639 00ba 4AE0     	 b .L122
 2640              	.L121:
 702:../Dave/Generated/DAC/dac.c ****     }
 703:../Dave/Generated/DAC/dac.c ****     else
 704:../Dave/Generated/DAC/dac.c ****     {
 705:../Dave/Generated/DAC/dac.c ****       clk_divider = (uint32_t)(XMC_SCU_CLOCK_GetPeripheralClockFrequency() / (temp_steps * Frequenc
 2641              	 .loc 2 705 0
 2642 00bc FFF7FEFF 	 bl XMC_SCU_CLOCK_GetPeripheralClockFrequency
 2643 00c0 0146     	 mov r1,r0
 2644 00c2 BB89     	 ldrh r3,[r7,#12]
 2645 00c4 3A68     	 ldr r2,[r7]
 2646 00c6 02FB03F3 	 mul r3,r2,r3
 2647 00ca B1FBF3F3 	 udiv r3,r1,r3
 2648 00ce 3B61     	 str r3,[r7,#16]
 706:../Dave/Generated/DAC/dac.c ****       if(clk_divider == 0U)
 2649              	 .loc 2 706 0
 2650 00d0 3B69     	 ldr r3,[r7,#16]
 2651 00d2 002B     	 cmp r3,#0
 2652 00d4 01D1     	 bne .L123
 707:../Dave/Generated/DAC/dac.c ****       {
 708:../Dave/Generated/DAC/dac.c ****         clk_divider = 1U;
 2653              	 .loc 2 708 0
 2654 00d6 0123     	 movs r3,#1
 2655 00d8 3B61     	 str r3,[r7,#16]
 2656              	.L123:
 709:../Dave/Generated/DAC/dac.c ****       }
 710:../Dave/Generated/DAC/dac.c ****       temp_freq = (uint32_t)(XMC_SCU_CLOCK_GetPeripheralClockFrequency()/clk_divider);
 2657              	 .loc 2 710 0
 2658 00da FFF7FEFF 	 bl XMC_SCU_CLOCK_GetPeripheralClockFrequency
 2659 00de 0246     	 mov r2,r0
 2660 00e0 3B69     	 ldr r3,[r7,#16]
 2661 00e2 B2FBF3F3 	 udiv r3,r2,r3
 2662 00e6 BB60     	 str r3,[r7,#8]
 711:../Dave/Generated/DAC/dac.c **** 
 712:../Dave/Generated/DAC/dac.c ****       if(clk_divider <= DAC_MAX_CLK_DIV)
 2663              	 .loc 2 712 0
 2664 00e8 3B69     	 ldr r3,[r7,#16]
 2665 00ea B3F5801F 	 cmp r3,#1048576
 2666 00ee 25D2     	 bcs .L124
 713:../Dave/Generated/DAC/dac.c ****       {
 714:../Dave/Generated/DAC/dac.c ****         if( temp_freq > DAC_MAX_FREQUENCY)
 2667              	 .loc 2 714 0
 2668 00f0 BB68     	 ldr r3,[r7,#8]
 2669 00f2 1E4A     	 ldr r2,.L129+8
 2670 00f4 9342     	 cmp r3,r2
 2671 00f6 0AD9     	 bls .L125
 715:../Dave/Generated/DAC/dac.c ****         {
 716:../Dave/Generated/DAC/dac.c ****           /* Up-scaling is required to configure required frequency */
 717:../Dave/Generated/DAC/dac.c ****           status = DAC_Ramp_ScaleUp(HandlePtr,start_ramp,stop_ramp,Frequency_Hz);
 2672              	 .loc 2 717 0
 2673 00f8 FA8A     	 ldrh r2,[r7,#22]
 2674 00fa BB8A     	 ldrh r3,[r7,#20]
 2675 00fc 7868     	 ldr r0,[r7,#4]
 2676 00fe 1146     	 mov r1,r2
 2677 0100 1A46     	 mov r2,r3
 2678 0102 3B68     	 ldr r3,[r7]
 2679 0104 FFF7FEFF 	 bl DAC_Ramp_ScaleUp
 2680 0108 0346     	 mov r3,r0
 2681 010a FB73     	 strb r3,[r7,#15]
 2682 010c 21E0     	 b .L122
 2683              	.L125:
 718:../Dave/Generated/DAC/dac.c ****         }
 719:../Dave/Generated/DAC/dac.c ****         else
 720:../Dave/Generated/DAC/dac.c ****         {
 721:../Dave/Generated/DAC/dac.c ****           /* No need of scaling */
 722:../Dave/Generated/DAC/dac.c ****           XMC_DAC_CH_SetOutputScale(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,XMC_DAC_CH_OUTPUT_S
 2684              	 .loc 2 722 0
 2685 010e 7B68     	 ldr r3,[r7,#4]
 2686 0110 1A68     	 ldr r2,[r3]
 2687 0112 7B68     	 ldr r3,[r7,#4]
 2688 0114 93F82630 	 ldrb r3,[r3,#38]
 2689 0118 1046     	 mov r0,r2
 2690 011a 1946     	 mov r1,r3
 2691 011c 0022     	 movs r2,#0
 2692 011e FFF7FEFF 	 bl XMC_DAC_CH_SetOutputScale
 723:../Dave/Generated/DAC/dac.c ****           status = (DAC_STATUS_t)XMC_DAC_CH_SetFrequency(HandlePtr->dac_module_ptr,HandlePtr->dac_c
 2693              	 .loc 2 723 0
 2694 0122 7B68     	 ldr r3,[r7,#4]
 2695 0124 1A68     	 ldr r2,[r3]
 2696 0126 7B68     	 ldr r3,[r7,#4]
 2697 0128 93F82630 	 ldrb r3,[r3,#38]
 2698 012c 1046     	 mov r0,r2
 2699 012e 1946     	 mov r1,r3
 2700 0130 BA68     	 ldr r2,[r7,#8]
 2701 0132 FFF7FEFF 	 bl XMC_DAC_CH_SetFrequency
 2702 0136 0346     	 mov r3,r0
 2703 0138 FB73     	 strb r3,[r7,#15]
 699:../Dave/Generated/DAC/dac.c ****     {
 2704              	 .loc 2 699 0
 2705 013a 0DE0     	 b .L127
 2706              	.L124:
 724:../Dave/Generated/DAC/dac.c ****         }
 725:../Dave/Generated/DAC/dac.c ****       }
 726:../Dave/Generated/DAC/dac.c ****       else
 727:../Dave/Generated/DAC/dac.c ****       {
 728:../Dave/Generated/DAC/dac.c ****         /* Down-scaling is required to configure required frequency */
 729:../Dave/Generated/DAC/dac.c ****         status = DAC_Ramp_ScaleDown(HandlePtr,start_ramp,stop_ramp,Frequency_Hz);
 2707              	 .loc 2 729 0
 2708 013c FA8A     	 ldrh r2,[r7,#22]
 2709 013e BB8A     	 ldrh r3,[r7,#20]
 2710 0140 7868     	 ldr r0,[r7,#4]
 2711 0142 1146     	 mov r1,r2
 2712 0144 1A46     	 mov r2,r3
 2713 0146 3B68     	 ldr r3,[r7]
 2714 0148 FFF7FEFF 	 bl DAC_Ramp_ScaleDown
 2715 014c 0346     	 mov r3,r0
 2716 014e FB73     	 strb r3,[r7,#15]
 699:../Dave/Generated/DAC/dac.c ****     {
 2717              	 .loc 2 699 0
 2718 0150 02E0     	 b .L127
 2719              	.L122:
 699:../Dave/Generated/DAC/dac.c ****     {
 2720              	 .loc 2 699 0 is_stmt 0 discriminator 1
 2721 0152 01E0     	 b .L127
 2722              	.L118:
 730:../Dave/Generated/DAC/dac.c ****       }
 731:../Dave/Generated/DAC/dac.c ****     }
 732:../Dave/Generated/DAC/dac.c ****   }
 733:../Dave/Generated/DAC/dac.c ****   else
 734:../Dave/Generated/DAC/dac.c ****   {
 735:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_API_FAIL;
 2723              	 .loc 2 735 0 is_stmt 1
 2724 0154 0223     	 movs r3,#2
 2725 0156 FB73     	 strb r3,[r7,#15]
 2726              	.L127:
 736:../Dave/Generated/DAC/dac.c ****   }
 737:../Dave/Generated/DAC/dac.c ****   return status;
 2727              	 .loc 2 737 0
 2728 0158 FB7B     	 ldrb r3,[r7,#15]
 738:../Dave/Generated/DAC/dac.c ****  }
 2729              	 .loc 2 738 0
 2730 015a 1846     	 mov r0,r3
 2731 015c 1837     	 adds r7,r7,#24
 2732              	.LCFI146:
 2733              	 .cfi_def_cfa_offset 8
 2734 015e BD46     	 mov sp,r7
 2735              	.LCFI147:
 2736              	 .cfi_def_cfa_register 13
 2737              	 
 2738 0160 80BD     	 pop {r7,pc}
 2739              	.L130:
 2740 0162 00BF     	 .align 2
 2741              	.L129:
 2742 0164 2C41EDFF 	 .word -1228500
 2743 0168 DD01CA1D 	 .word 499778013
 2744 016c 80841E00 	 .word 2000000
 2745              	 .cfi_endproc
 2746              	.LFE237:
 2748              	 .section .text.DAC_Noise_SetAmplitude,"ax",%progbits
 2749              	 .align 2
 2750              	 .global DAC_Noise_SetAmplitude
 2751              	 .thumb
 2752              	 .thumb_func
 2754              	DAC_Noise_SetAmplitude:
 2755              	.LFB238:
 739:../Dave/Generated/DAC/dac.c **** 
 740:../Dave/Generated/DAC/dac.c **** /*
 741:../Dave/Generated/DAC/dac.c ****   * This API will set the amplitude in Noise Mode.
 742:../Dave/Generated/DAC/dac.c **** */
 743:../Dave/Generated/DAC/dac.c **** DAC_STATUS_t DAC_Noise_SetAmplitude(const DAC_t * const HandlePtr,DAC_VSS_t Amplitude)
 744:../Dave/Generated/DAC/dac.c **** {
 2756              	 .loc 2 744 0
 2757              	 .cfi_startproc
 2758              	 
 2759              	 
 2760 0000 80B5     	 push {r7,lr}
 2761              	.LCFI148:
 2762              	 .cfi_def_cfa_offset 8
 2763              	 .cfi_offset 7,-8
 2764              	 .cfi_offset 14,-4
 2765 0002 84B0     	 sub sp,sp,#16
 2766              	.LCFI149:
 2767              	 .cfi_def_cfa_offset 24
 2768 0004 00AF     	 add r7,sp,#0
 2769              	.LCFI150:
 2770              	 .cfi_def_cfa_register 7
 2771 0006 7860     	 str r0,[r7,#4]
 2772 0008 0B46     	 mov r3,r1
 2773 000a FB70     	 strb r3,[r7,#3]
 745:../Dave/Generated/DAC/dac.c ****   DAC_STATUS_t status = DAC_STATUS_SUCCESS;
 2774              	 .loc 2 745 0
 2775 000c 0023     	 movs r3,#0
 2776 000e FB73     	 strb r3,[r7,#15]
 746:../Dave/Generated/DAC/dac.c ****   XMC_DAC_CH_OUTPUT_SCALE_t scale;
 747:../Dave/Generated/DAC/dac.c **** 
 748:../Dave/Generated/DAC/dac.c ****   /* Check if Amplitude is configurable */
 749:../Dave/Generated/DAC/dac.c ****   if(DAC_VSS_0017_mV <= Amplitude)
 2777              	 .loc 2 749 0
 2778 0010 FB78     	 ldrb r3,[r7,#3]
 2779 0012 032B     	 cmp r3,#3
 2780 0014 15D9     	 bls .L132
 750:../Dave/Generated/DAC/dac.c ****   {
 751:../Dave/Generated/DAC/dac.c ****     if(Amplitude == DAC_VSS_2200_mV)
 2781              	 .loc 2 751 0
 2782 0016 FB78     	 ldrb r3,[r7,#3]
 2783 0018 0B2B     	 cmp r3,#11
 2784 001a 02D1     	 bne .L133
 752:../Dave/Generated/DAC/dac.c ****     {
 753:../Dave/Generated/DAC/dac.c ****       /* Scale not required */
 754:../Dave/Generated/DAC/dac.c ****       scale = XMC_DAC_CH_OUTPUT_SCALE_NONE;
 2785              	 .loc 2 754 0
 2786 001c 0023     	 movs r3,#0
 2787 001e BB73     	 strb r3,[r7,#14]
 2788 0020 03E0     	 b .L134
 2789              	.L133:
 755:../Dave/Generated/DAC/dac.c ****     }
 756:../Dave/Generated/DAC/dac.c ****     else
 757:../Dave/Generated/DAC/dac.c ****     {
 758:../Dave/Generated/DAC/dac.c ****       scale = (XMC_DAC_CH_OUTPUT_SCALE_t)((uint32_t)XMC_DAC_CH_OUTPUT_SCALE_DIV_128 +
 2790              	 .loc 2 758 0
 2791 0022 FB78     	 ldrb r3,[r7,#3]
 2792 0024 C3F10B03 	 rsb r3,r3,#11
 2793 0028 BB73     	 strb r3,[r7,#14]
 2794              	.L134:
 759:../Dave/Generated/DAC/dac.c ****                                    ((uint32_t)DAC_VSS_0017_mV - (uint32_t)Amplitude));
 760:../Dave/Generated/DAC/dac.c ****     }
 761:../Dave/Generated/DAC/dac.c ****     XMC_DAC_CH_SetOutputScale(HandlePtr->dac_module_ptr,HandlePtr->dac_ch, scale);
 2795              	 .loc 2 761 0
 2796 002a 7B68     	 ldr r3,[r7,#4]
 2797 002c 1968     	 ldr r1,[r3]
 2798 002e 7B68     	 ldr r3,[r7,#4]
 2799 0030 93F82620 	 ldrb r2,[r3,#38]
 2800 0034 BB7B     	 ldrb r3,[r7,#14]
 2801 0036 0846     	 mov r0,r1
 2802 0038 1146     	 mov r1,r2
 2803 003a 1A46     	 mov r2,r3
 2804 003c FFF7FEFF 	 bl XMC_DAC_CH_SetOutputScale
 2805 0040 01E0     	 b .L135
 2806              	.L132:
 762:../Dave/Generated/DAC/dac.c ****   }
 763:../Dave/Generated/DAC/dac.c ****   else
 764:../Dave/Generated/DAC/dac.c ****   {
 765:../Dave/Generated/DAC/dac.c ****     /* Amplitude can't be configurable */
 766:../Dave/Generated/DAC/dac.c ****     status = DAC_STATUS_API_FAIL;
 2807              	 .loc 2 766 0
 2808 0042 0223     	 movs r3,#2
 2809 0044 FB73     	 strb r3,[r7,#15]
 2810              	.L135:
 767:../Dave/Generated/DAC/dac.c ****   }
 768:../Dave/Generated/DAC/dac.c ****   return status;
 2811              	 .loc 2 768 0
 2812 0046 FB7B     	 ldrb r3,[r7,#15]
 769:../Dave/Generated/DAC/dac.c **** }
 2813              	 .loc 2 769 0
 2814 0048 1846     	 mov r0,r3
 2815 004a 1037     	 adds r7,r7,#16
 2816              	.LCFI151:
 2817              	 .cfi_def_cfa_offset 8
 2818 004c BD46     	 mov sp,r7
 2819              	.LCFI152:
 2820              	 .cfi_def_cfa_register 13
 2821              	 
 2822 004e 80BD     	 pop {r7,pc}
 2823              	 .cfi_endproc
 2824              	.LFE238:
 2826              	 .text
 2827              	.Letext0:
 2828              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 2829              	 .file 4 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 2830              	 .file 5 "C:/work_mari/XMC4800/DAC_ADC/Dave/Generated/DAVE_Common.h"
 2831              	 .file 6 "C:/work_mari/XMC4800/DAC_ADC/Libraries/XMCLib/inc/xmc4_gpio.h"
 2832              	 .file 7 "C:/work_mari/XMC4800/DAC_ADC/Dave/Generated/ANALOG_IO/analog_io.h"
 2833              	 .file 8 "../Dave/Generated/DAC/dac.h"
 2834              	 .file 9 "C:/work_mari/XMC4800/DAC_ADC/Libraries/CMSIS/Include/cmsis_gcc.h"
 2835              	 .file 10 "C:/work_mari/XMC4800/DAC_ADC/Libraries/CMSIS/Include/core_cm4.h"
 2836              	 .file 11 "C:/work_mari/XMC4800/DAC_ADC/Libraries/CMSIS/Infineon/XMC4800_series/Include/system_XMC4800.h"
DEFINED SYMBOLS
                            *ABS*:00000000 dac.c
    {standard input}:20     .text.XMC_DAC_EnableSimultaneousDataMode:00000000 $t
    {standard input}:24     .text.XMC_DAC_EnableSimultaneousDataMode:00000000 XMC_DAC_EnableSimultaneousDataMode
    {standard input}:66     .text.XMC_DAC_SimultaneousWrite:00000000 $t
    {standard input}:70     .text.XMC_DAC_SimultaneousWrite:00000000 XMC_DAC_SimultaneousWrite
    {standard input}:117    .text.XMC_DAC_CH_Write:00000000 $t
    {standard input}:121    .text.XMC_DAC_CH_Write:00000000 XMC_DAC_CH_Write
    {standard input}:168    .text.XMC_DAC_CH_SetRampStart:00000000 $t
    {standard input}:172    .text.XMC_DAC_CH_SetRampStart:00000000 XMC_DAC_CH_SetRampStart
    {standard input}:219    .text.XMC_DAC_CH_SetRampStop:00000000 $t
    {standard input}:223    .text.XMC_DAC_CH_SetRampStop:00000000 XMC_DAC_CH_SetRampStop
    {standard input}:281    .text.XMC_DAC_CH_SetMode:00000000 $t
    {standard input}:285    .text.XMC_DAC_CH_SetMode:00000000 XMC_DAC_CH_SetMode
    {standard input}:337    .text.XMC_DAC_CH_EnableEvent:00000000 $t
    {standard input}:341    .text.XMC_DAC_CH_EnableEvent:00000000 XMC_DAC_CH_EnableEvent
    {standard input}:390    .text.XMC_DAC_CH_SetOutputOffset:00000000 $t
    {standard input}:394    .text.XMC_DAC_CH_SetOutputOffset:00000000 XMC_DAC_CH_SetOutputOffset
    {standard input}:450    .text.XMC_DAC_CH_SetOutputScale:00000000 $t
    {standard input}:454    .text.XMC_DAC_CH_SetOutputScale:00000000 XMC_DAC_CH_SetOutputScale
    {standard input}:507    .text.XMC_DAC_CH_GetOutputScale:00000000 $t
    {standard input}:511    .text.XMC_DAC_CH_GetOutputScale:00000000 XMC_DAC_CH_GetOutputScale
    {standard input}:558    .text.XMC_DAC_CH_EnableOutputNegation:00000000 $t
    {standard input}:562    .text.XMC_DAC_CH_EnableOutputNegation:00000000 XMC_DAC_CH_EnableOutputNegation
    {standard input}:611    .text.XMC_DAC_CH_DisableOutputNegation:00000000 $t
    {standard input}:615    .text.XMC_DAC_CH_DisableOutputNegation:00000000 XMC_DAC_CH_DisableOutputNegation
    {standard input}:664    .text.DAC_Ramp_ScaleUp:00000000 $t
    {standard input}:669    .text.DAC_Ramp_ScaleUp:00000000 DAC_Ramp_ScaleUp
    {standard input}:1090   .text.DAC_Ramp_StartStopConfigure:00000000 DAC_Ramp_StartStopConfigure
    {standard input}:865    .text.DAC_Ramp_ScaleUp:00000134 $d
    {standard input}:870    .text.DAC_Ramp_ScaleDown:00000000 $t
    {standard input}:875    .text.DAC_Ramp_ScaleDown:00000000 DAC_Ramp_ScaleDown
    {standard input}:1085   .text.DAC_Ramp_StartStopConfigure:00000000 $t
    {standard input}:1184   .text.DAC_ModeConfig:00000000 $t
    {standard input}:1189   .text.DAC_ModeConfig:00000000 DAC_ModeConfig
    {standard input}:1389   .text.DAC_GetAppVersion:00000000 $t
    {standard input}:1394   .text.DAC_GetAppVersion:00000000 DAC_GetAppVersion
    {standard input}:1454   .text.DAC_Init:00000000 $t
    {standard input}:1459   .text.DAC_Init:00000000 DAC_Init
    {standard input}:1553   .text.DAC_Pattern_SetAmplitude:00000000 $t
    {standard input}:1558   .text.DAC_Pattern_SetAmplitude:00000000 DAC_Pattern_SetAmplitude
    {standard input}:1625   .text.DAC_Pattern_SetOffset:00000000 $t
    {standard input}:1630   .text.DAC_Pattern_SetOffset:00000000 DAC_Pattern_SetOffset
    {standard input}:1772   .text.DAC_SingleValue_SetValue_s16:00000000 $t
    {standard input}:1777   .text.DAC_SingleValue_SetValue_s16:00000000 DAC_SingleValue_SetValue_s16
    {standard input}:1858   .text.DAC_SingleValue_SetValue_s16_Coupled:00000000 $t
    {standard input}:1863   .text.DAC_SingleValue_SetValue_s16_Coupled:00000000 DAC_SingleValue_SetValue_s16_Coupled
    {standard input}:1968   .text.DAC_SingleValue_SetValue_u16:00000000 $t
    {standard input}:1973   .text.DAC_SingleValue_SetValue_u16:00000000 DAC_SingleValue_SetValue_u16
    {standard input}:2032   .text.DAC_SingleValue_SetValue_u16_Coupled:00000000 $t
    {standard input}:2037   .text.DAC_SingleValue_SetValue_u16_Coupled:00000000 DAC_SingleValue_SetValue_u16_Coupled
    {standard input}:2101   .text.DAC_Ramp_SetStart:00000000 $t
    {standard input}:2106   .text.DAC_Ramp_SetStart:00000000 DAC_Ramp_SetStart
    {standard input}:2304   .text.DAC_Ramp_SetStart:00000154 $d
    {standard input}:2310   .text.DAC_Ramp_SetStop:00000000 $t
    {standard input}:2315   .text.DAC_Ramp_SetStop:00000000 DAC_Ramp_SetStop
    {standard input}:2513   .text.DAC_Ramp_SetStop:00000154 $d
    {standard input}:2519   .text.DAC_Ramp_SetFrequency:00000000 $t
    {standard input}:2524   .text.DAC_Ramp_SetFrequency:00000000 DAC_Ramp_SetFrequency
    {standard input}:2742   .text.DAC_Ramp_SetFrequency:00000164 $d
    {standard input}:2749   .text.DAC_Noise_SetAmplitude:00000000 $t
    {standard input}:2754   .text.DAC_Noise_SetAmplitude:00000000 DAC_Noise_SetAmplitude
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
XMC_SCU_CLOCK_GetPeripheralClockFrequency
XMC_DAC_CH_SetFrequency
XMC_DAC_CH_StartPatternMode
XMC_DAC_CH_StartSingleValueMode
XMC_DAC_CH_StartDataMode
XMC_DAC_CH_StartRampMode
XMC_DAC_CH_StartNoiseMode
XMC_DAC_CH_Init
ANALOG_IO_Init
