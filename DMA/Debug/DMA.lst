
DMA.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000276c  08000000  0c000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 Stack         00000800  1ffe8000  1ffe8000  00018000  2**0
                  ALLOC
  2 .data         00000054  1ffe8800  0c00276c  00010800  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00001040  1ffe8854  0c0027c0  00010854  2**2
                  ALLOC
  4 .no_init      00000014  2003ffc0  2003ffc0  00017fc0  2**2
                  ALLOC
  5 .debug_aranges 00000728  00000000  00000000  00010858  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009535  00000000  00000000  00010f80  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001451  00000000  00000000  0001a4b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002bcb  00000000  00000000  0001b906  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001dfc  00000000  00000000  0001e4d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004792  00000000  00000000  000202d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003d68  00000000  00000000  00024a62  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000658  00000000  00000000  000287ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .build_attributes 000002e6  00000000  00000000  00028e22  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08000000 <__Vectors>:
 8000000:	00 88 fe 1f 01 02 00 08 99 02 00 08 99 02 00 08     ................
 8000010:	99 02 00 08 99 02 00 08 99 02 00 08 00 00 00 00     ................
	...
 800002c:	99 02 00 08 99 02 00 08 00 00 00 00 99 02 00 08     ................
 800003c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800004c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800005c:	99 02 00 08 99 02 00 08 00 00 00 00 00 00 00 00     ................
 800006c:	00 00 00 00 99 02 00 08 00 00 00 00 99 02 00 08     ................
 800007c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800008c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800009c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 80000ac:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 80000bc:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 80000cc:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 80000dc:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 80000ec:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 80000fc:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800010c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800011c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800012c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800013c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800014c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800015c:	99 02 00 08 00 00 00 00 00 00 00 00 00 00 00 00     ................
 800016c:	00 00 00 00 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800017c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800018c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 800019c:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 80001ac:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 80001bc:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 80001cc:	99 02 00 08 99 02 00 08 99 02 00 08 99 02 00 08     ................
 80001dc:	00 00 00 00 99 02 00 08 8d 13 00 08 99 02 00 08     ................
 80001ec:	99 02 00 08 99 02 00 08 99 02 00 08 9d 13 00 08     ................
 80001fc:	00 00 00 00                                         ....

08000200 <Reset_Handler>:
/* Reset Handler */
    .thumb_func
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler:
    ldr sp,=__initial_sp
 8000200:	f8df d074 	ldr.w	sp, [pc, #116]	; 8000278 <__zero_table_end__>

#ifndef __SKIP_SYSTEM_INIT
    ldr  r0, =SystemInit
 8000204:	481d      	ldr	r0, [pc, #116]	; (800027c <__zero_table_end__+0x4>)
    blx  r0
 8000206:	4780      	blx	r0
 *    offset 4: VMA of start of a section to copy to
 *    offset 8: size of the section to copy. Must be multiply of 4
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
	ldr	r4, =__copy_table_start__
 8000208:	4c1d      	ldr	r4, [pc, #116]	; (8000280 <__zero_table_end__+0x8>)
	ldr	r5, =__copy_table_end__
 800020a:	4d1e      	ldr	r5, [pc, #120]	; (8000284 <__zero_table_end__+0xc>)

.L_loop0:
	cmp	r4, r5
 800020c:	42ac      	cmp	r4, r5
	bge	.L_loop0_done
 800020e:	da09      	bge.n	8000224 <Reset_Handler+0x24>
	ldr	r1, [r4]
 8000210:	6821      	ldr	r1, [r4, #0]
	ldr	r2, [r4, #4]
 8000212:	6862      	ldr	r2, [r4, #4]
	ldr	r3, [r4, #8]
 8000214:	68a3      	ldr	r3, [r4, #8]

.L_loop0_0:
	subs	r3, #4
 8000216:	3b04      	subs	r3, #4
	ittt	ge
 8000218:	bfa2      	ittt	ge
	ldrge	r0, [r1, r3]
 800021a:	58c8      	ldrge	r0, [r1, r3]
	strge	r0, [r2, r3]
 800021c:	50d0      	strge	r0, [r2, r3]
	bge	.L_loop0_0
 800021e:	e7fa      	bge.n	8000216 <Reset_Handler+0x16>

	adds	r4, #12
 8000220:	340c      	adds	r4, #12
	b	.L_loop0
 8000222:	e7f3      	b.n	800020c <Reset_Handler+0xc>
 *    offset 4: Size of this BSS section. Must be multiply of 4
 *
 *  Define __SKIP_BSS_CLEAR to disable zeroing uninitialzed data in startup.
 */    
#ifndef __SKIP_BSS_CLEAR
	ldr	r3, =__zero_table_start__
 8000224:	4b18      	ldr	r3, [pc, #96]	; (8000288 <__zero_table_end__+0x10>)
	ldr	r4, =__zero_table_end__
 8000226:	4c19      	ldr	r4, [pc, #100]	; (800028c <__zero_table_end__+0x14>)

.L_loop2:
	cmp	r3, r4
 8000228:	42a3      	cmp	r3, r4
	bge	.L_loop2_done
 800022a:	da08      	bge.n	800023e <Reset_Handler+0x3e>
	ldr	r1, [r3]
 800022c:	6819      	ldr	r1, [r3, #0]
	ldr	r2, [r3, #4]
 800022e:	685a      	ldr	r2, [r3, #4]
	movs	r0, 0
 8000230:	2000      	movs	r0, #0

.L_loop2_0:
	subs	r2, #4
 8000232:	3a04      	subs	r2, #4
	itt	ge
 8000234:	bfa4      	itt	ge
	strge	r0, [r1, r2]
 8000236:	5088      	strge	r0, [r1, r2]
	bge	.L_loop2_0
 8000238:	e7fb      	bge.n	8000232 <Reset_Handler+0x32>

	adds	r3, #8
 800023a:	3308      	adds	r3, #8
	b	.L_loop2
 800023c:	e7f4      	b.n	8000228 <Reset_Handler+0x28>
.L_loop2_done:    
#endif /* __SKIP_BSS_CLEAR */
   
#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
 800023e:	4814      	ldr	r0, [pc, #80]	; (8000290 <__zero_table_end__+0x18>)
    blx  r0
 8000240:	4780      	blx	r0
#endif

    ldr  r0, =main
 8000242:	4814      	ldr	r0, [pc, #80]	; (8000294 <__zero_table_end__+0x1c>)
    blx  r0
 8000244:	4780      	blx	r0
	...

08000248 <__copy_table_start__>:
 8000248:	0c00276c 	.word	0x0c00276c
 800024c:	1ffe8800 	.word	0x1ffe8800
 8000250:	00000054 	.word	0x00000054
 8000254:	0c00276c 	.word	0x0c00276c
 8000258:	1ffe8800 	.word	0x1ffe8800
 800025c:	00000000 	.word	0x00000000

08000260 <__copy_table_end__>:
 8000260:	1ffe8854 	.word	0x1ffe8854
 8000264:	00001040 	.word	0x00001040
 8000268:	20000000 	.word	0x20000000
 800026c:	00000000 	.word	0x00000000
 8000270:	20000000 	.word	0x20000000
 8000274:	00000000 	.word	0x00000000

08000278 <__zero_table_end__>:
/* Reset Handler */
    .thumb_func
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler:
    ldr sp,=__initial_sp
 8000278:	1ffe8800 	.word	0x1ffe8800

#ifndef __SKIP_SYSTEM_INIT
    ldr  r0, =SystemInit
 800027c:	080002c5 	.word	0x080002c5
 *    offset 4: VMA of start of a section to copy to
 *    offset 8: size of the section to copy. Must be multiply of 4
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
	ldr	r4, =__copy_table_start__
 8000280:	08000248 	.word	0x08000248
	ldr	r5, =__copy_table_end__
 8000284:	08000260 	.word	0x08000260
 *    offset 4: Size of this BSS section. Must be multiply of 4
 *
 *  Define __SKIP_BSS_CLEAR to disable zeroing uninitialzed data in startup.
 */    
#ifndef __SKIP_BSS_CLEAR
	ldr	r3, =__zero_table_start__
 8000288:	08000260 	.word	0x08000260
	ldr	r4, =__zero_table_end__
 800028c:	08000278 	.word	0x08000278
	b	.L_loop2
.L_loop2_done:    
#endif /* __SKIP_BSS_CLEAR */
   
#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
 8000290:	08001709 	.word	0x08001709
    blx  r0
#endif

    ldr  r0, =main
 8000294:	08001679 	.word	0x08001679

08000298 <BusFault_Handler>:
	.align	1
    .thumb_func
    .weak Default_Handler
    .type Default_Handler, %function
Default_Handler:
    b .
 8000298:	e7fe      	b.n	8000298 <BusFault_Handler>
	...

0800029c <delay>:

/*******************************************************************************
 * LOCAL FUNCTIONS
 *******************************************************************************/
static void delay(uint32_t cycles)
{
 800029c:	b480      	push	{r7}
 800029e:	b085      	sub	sp, #20
 80002a0:	af00      	add	r7, sp, #0
 80002a2:	6078      	str	r0, [r7, #4]
  volatile uint32_t i;

  for(i = 0UL; i < cycles ;++i)
 80002a4:	2300      	movs	r3, #0
 80002a6:	60fb      	str	r3, [r7, #12]
 80002a8:	e003      	b.n	80002b2 <delay+0x16>
  {
    __NOP();
 80002aa:	bf00      	nop
 *******************************************************************************/
static void delay(uint32_t cycles)
{
  volatile uint32_t i;

  for(i = 0UL; i < cycles ;++i)
 80002ac:	68fb      	ldr	r3, [r7, #12]
 80002ae:	3301      	adds	r3, #1
 80002b0:	60fb      	str	r3, [r7, #12]
 80002b2:	68fa      	ldr	r2, [r7, #12]
 80002b4:	687b      	ldr	r3, [r7, #4]
 80002b6:	429a      	cmp	r2, r3
 80002b8:	d3f7      	bcc.n	80002aa <delay+0xe>
  {
    __NOP();
  }
}
 80002ba:	3714      	adds	r7, #20
 80002bc:	46bd      	mov	sp, r7
 80002be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80002c2:	4770      	bx	lr

080002c4 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{
 80002c4:	b598      	push	{r3, r4, r7, lr}
 80002c6:	af00      	add	r7, sp, #0
  memcpy(g_chipid, CHIPID_LOC, 16);
 80002c8:	4a05      	ldr	r2, [pc, #20]	; (80002e0 <SystemInit+0x1c>)
 80002ca:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80002ce:	4614      	mov	r4, r2
 80002d0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80002d2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

  SystemCoreSetup();
 80002d6:	f001 f941 	bl	800155c <SystemCoreSetup>
  SystemCoreClockSetup();
 80002da:	f000 f803 	bl	80002e4 <SystemCoreClockSetup>
}
 80002de:	bd98      	pop	{r3, r4, r7, pc}
 80002e0:	2003ffc4 	.word	0x2003ffc4

080002e4 <SystemCoreClockSetup>:
  temp |= PMU_FLASH_WS;
  FLASH0->FCON = temp;
}

__WEAK void SystemCoreClockSetup(void)
{
 80002e4:	b580      	push	{r7, lr}
 80002e6:	af00      	add	r7, sp, #0
#else
  /* Automatic calibration uses the fSTDBY */

  /* Enable HIB domain */
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0)
 80002e8:	4ba7      	ldr	r3, [pc, #668]	; (8000588 <SystemCoreClockSetup+0x2a4>)
 80002ea:	681b      	ldr	r3, [r3, #0]
 80002ec:	f003 0301 	and.w	r3, r3, #1
 80002f0:	2b00      	cmp	r3, #0
 80002f2:	d10c      	bne.n	800030e <SystemCoreClockSetup+0x2a>
  {
    SCU_POWER->PWRSET |= SCU_POWER_PWRSET_HIB_Msk;
 80002f4:	4aa4      	ldr	r2, [pc, #656]	; (8000588 <SystemCoreClockSetup+0x2a4>)
 80002f6:	4ba4      	ldr	r3, [pc, #656]	; (8000588 <SystemCoreClockSetup+0x2a4>)
 80002f8:	685b      	ldr	r3, [r3, #4]
 80002fa:	f043 0301 	orr.w	r3, r3, #1
 80002fe:	6053      	str	r3, [r2, #4]

    while((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0)
 8000300:	bf00      	nop
 8000302:	4ba1      	ldr	r3, [pc, #644]	; (8000588 <SystemCoreClockSetup+0x2a4>)
 8000304:	681b      	ldr	r3, [r3, #0]
 8000306:	f003 0301 	and.w	r3, r3, #1
 800030a:	2b00      	cmp	r3, #0
 800030c:	d0f9      	beq.n	8000302 <SystemCoreClockSetup+0x1e>
      /* wait until HIB domain is enabled */
    }
  }

  /* Remove the reset only if HIB domain were in a state of reset */
  if((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_HIBRS_Msk)
 800030e:	4b9f      	ldr	r3, [pc, #636]	; (800058c <SystemCoreClockSetup+0x2a8>)
 8000310:	681b      	ldr	r3, [r3, #0]
 8000312:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8000316:	2b00      	cmp	r3, #0
 8000318:	d009      	beq.n	800032e <SystemCoreClockSetup+0x4a>
  {
    SCU_RESET->RSTCLR |= SCU_RESET_RSTCLR_HIBRS_Msk;
 800031a:	4a9c      	ldr	r2, [pc, #624]	; (800058c <SystemCoreClockSetup+0x2a8>)
 800031c:	4b9b      	ldr	r3, [pc, #620]	; (800058c <SystemCoreClockSetup+0x2a8>)
 800031e:	689b      	ldr	r3, [r3, #8]
 8000320:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000324:	6093      	str	r3, [r2, #8]
    delay(DELAY_CNT_150US_50MHZ);
 8000326:	f641 504c 	movw	r0, #7500	; 0x1d4c
 800032a:	f7ff ffb7 	bl	800029c <delay>
  }
  SCU_HIBERNATE->HDCR |= SCU_HIBERNATE_HDCR_RCS_Msk | SCU_HIBERNATE_HDCR_STDBYSEL_Msk;
#endif /* STDBY_CLOCK_SRC == STDBY_CLOCK_SRC_OSCULP */

  /* Enable automatic calibration of internal fast oscillator */
  SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_AOTREN_Msk;
 800032e:	4a98      	ldr	r2, [pc, #608]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000330:	4b97      	ldr	r3, [pc, #604]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000332:	685b      	ldr	r3, [r3, #4]
 8000334:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8000338:	6053      	str	r3, [r2, #4]
#endif /* FOFI_CALIBRATION_MODE == FOFI_CALIBRATION_MODE_AUTOMATIC */

  delay(DELAY_CNT_50US_50MHZ);
 800033a:	f640 10c4 	movw	r0, #2500	; 0x9c4
 800033e:	f7ff ffad 	bl	800029c <delay>

#if ENABLE_PLL

  /* enable PLL */
  SCU_PLL->PLLCON0 &= ~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8000342:	4a93      	ldr	r2, [pc, #588]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000344:	4b92      	ldr	r3, [pc, #584]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000346:	685b      	ldr	r3, [r3, #4]
 8000348:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800034c:	f023 0302 	bic.w	r3, r3, #2
 8000350:	6053      	str	r3, [r2, #4]

#if PLL_CLOCK_SRC != PLL_CLOCK_SRC_OFI
  /* enable OSC_HP */
  if ((SCU_OSC->OSCHPCTRL & SCU_OSC_OSCHPCTRL_MODE_Msk) != 0U)
 8000352:	4b90      	ldr	r3, [pc, #576]	; (8000594 <SystemCoreClockSetup+0x2b0>)
 8000354:	685b      	ldr	r3, [r3, #4]
 8000356:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800035a:	2b00      	cmp	r3, #0
 800035c:	d026      	beq.n	80003ac <SystemCoreClockSetup+0xc8>
  {
    SCU_OSC->OSCHPCTRL &= ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk);
 800035e:	4a8d      	ldr	r2, [pc, #564]	; (8000594 <SystemCoreClockSetup+0x2b0>)
 8000360:	4b8c      	ldr	r3, [pc, #560]	; (8000594 <SystemCoreClockSetup+0x2b0>)
 8000362:	685b      	ldr	r3, [r3, #4]
 8000364:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8000368:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 800036c:	6053      	str	r3, [r2, #4]
    SCU_OSC->OSCHPCTRL |= ((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos;
 800036e:	f000 f9e3 	bl	8000738 <OSCHP_GetFrequency>
 8000372:	4602      	mov	r2, r0
 8000374:	4b88      	ldr	r3, [pc, #544]	; (8000598 <SystemCoreClockSetup+0x2b4>)
 8000376:	fba3 2302 	umull	r2, r3, r3, r2
 800037a:	0d1b      	lsrs	r3, r3, #20
 800037c:	3b01      	subs	r3, #1
 800037e:	041b      	lsls	r3, r3, #16
 8000380:	4984      	ldr	r1, [pc, #528]	; (8000594 <SystemCoreClockSetup+0x2b0>)
 8000382:	4a84      	ldr	r2, [pc, #528]	; (8000594 <SystemCoreClockSetup+0x2b0>)
 8000384:	6852      	ldr	r2, [r2, #4]
 8000386:	4313      	orrs	r3, r2
 8000388:	604b      	str	r3, [r1, #4]

    /* select OSC_HP clock as PLL input */
    SCU_PLL->PLLCON2 = 0;
 800038a:	4b81      	ldr	r3, [pc, #516]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 800038c:	2200      	movs	r2, #0
 800038e:	60da      	str	r2, [r3, #12]

    /* restart OSC Watchdog */
    SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_OSCRES_Msk;
 8000390:	4a7f      	ldr	r2, [pc, #508]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000392:	4b7f      	ldr	r3, [pc, #508]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000394:	685b      	ldr	r3, [r3, #4]
 8000396:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800039a:	6053      	str	r3, [r2, #4]

    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_OSC_USABLE) != SCU_PLL_PLLSTAT_OSC_USABLE)
 800039c:	bf00      	nop
 800039e:	4b7c      	ldr	r3, [pc, #496]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003a0:	681b      	ldr	r3, [r3, #0]
 80003a2:	f403 7360 	and.w	r3, r3, #896	; 0x380
 80003a6:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 80003aa:	d1f8      	bne.n	800039e <SystemCoreClockSetup+0xba>
  /* select backup clock as PLL input */
  SCU_PLL->PLLCON2 = SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk;
#endif

  /* Go to bypass the Main PLL */
  SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_VCOBYP_Msk;
 80003ac:	4a78      	ldr	r2, [pc, #480]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003ae:	4b78      	ldr	r3, [pc, #480]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003b0:	685b      	ldr	r3, [r3, #4]
 80003b2:	f043 0301 	orr.w	r3, r3, #1
 80003b6:	6053      	str	r3, [r2, #4]
  while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 80003b8:	bf00      	nop
 80003ba:	4b75      	ldr	r3, [pc, #468]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003bc:	681b      	ldr	r3, [r3, #0]
 80003be:	f003 0301 	and.w	r3, r3, #1
 80003c2:	2b00      	cmp	r3, #0
 80003c4:	d0f9      	beq.n	80003ba <SystemCoreClockSetup+0xd6>
  {
    /* wait for prescaler mode */
  }

  /* disconnect Oscillator from PLL */
  SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_FINDIS_Msk;
 80003c6:	4a72      	ldr	r2, [pc, #456]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003c8:	4b71      	ldr	r3, [pc, #452]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003ca:	685b      	ldr	r3, [r3, #4]
 80003cc:	f043 0310 	orr.w	r3, r3, #16
 80003d0:	6053      	str	r3, [r2, #4]

  /* Setup divider settings for main PLL */
  SCU_PLL->PLLCON1 = ((PLL_NDIV << SCU_PLL_PLLCON1_NDIV_Pos) |
 80003d2:	4b6f      	ldr	r3, [pc, #444]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003d4:	4a71      	ldr	r2, [pc, #452]	; (800059c <SystemCoreClockSetup+0x2b8>)
 80003d6:	609a      	str	r2, [r3, #8]
                      (PLL_K2DIV_24MHZ << SCU_PLL_PLLCON1_K2DIV_Pos) |
                      (PLL_PDIV << SCU_PLL_PLLCON1_PDIV_Pos));

  /* Set OSCDISCDIS */
  SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 80003d8:	4a6d      	ldr	r2, [pc, #436]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003da:	4b6d      	ldr	r3, [pc, #436]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003dc:	685b      	ldr	r3, [r3, #4]
 80003de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80003e2:	6053      	str	r3, [r2, #4]

  /* connect Oscillator to PLL */
  SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_FINDIS_Msk;
 80003e4:	4a6a      	ldr	r2, [pc, #424]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003e6:	4b6a      	ldr	r3, [pc, #424]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003e8:	685b      	ldr	r3, [r3, #4]
 80003ea:	f023 0310 	bic.w	r3, r3, #16
 80003ee:	6053      	str	r3, [r2, #4]

  /* restart PLL Lock detection */
  SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_RESLD_Msk;
 80003f0:	4a67      	ldr	r2, [pc, #412]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003f2:	4b67      	ldr	r3, [pc, #412]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80003f4:	685b      	ldr	r3, [r3, #4]
 80003f6:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80003fa:	6053      	str	r3, [r2, #4]

  while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk) == 0U)
 80003fc:	bf00      	nop
 80003fe:	4b64      	ldr	r3, [pc, #400]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000400:	681b      	ldr	r3, [r3, #0]
 8000402:	f003 0304 	and.w	r3, r3, #4
 8000406:	2b00      	cmp	r3, #0
 8000408:	d0f9      	beq.n	80003fe <SystemCoreClockSetup+0x11a>
  {
    /* wait for PLL Lock at 24MHz*/
  }

  /* Disable bypass- put PLL clock back */
  SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_VCOBYP_Msk;
 800040a:	4a61      	ldr	r2, [pc, #388]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 800040c:	4b60      	ldr	r3, [pc, #384]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 800040e:	685b      	ldr	r3, [r3, #4]
 8000410:	f023 0301 	bic.w	r3, r3, #1
 8000414:	6053      	str	r3, [r2, #4]
  while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) != 0U)
 8000416:	bf00      	nop
 8000418:	4b5d      	ldr	r3, [pc, #372]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 800041a:	681b      	ldr	r3, [r3, #0]
 800041c:	f003 0301 	and.w	r3, r3, #1
 8000420:	2b00      	cmp	r3, #0
 8000422:	d1f9      	bne.n	8000418 <SystemCoreClockSetup+0x134>
  }

#endif /* ENABLE_PLL */

  /* Before scaling to final frequency we need to setup the clock dividers */
  SCU_CLK->SYSCLKCR = __SYSCLKCR;
 8000424:	4b5e      	ldr	r3, [pc, #376]	; (80005a0 <SystemCoreClockSetup+0x2bc>)
 8000426:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 800042a:	60da      	str	r2, [r3, #12]
  SCU_CLK->PBCLKCR = __PBCLKCR;
 800042c:	4b5c      	ldr	r3, [pc, #368]	; (80005a0 <SystemCoreClockSetup+0x2bc>)
 800042e:	2200      	movs	r2, #0
 8000430:	615a      	str	r2, [r3, #20]
  SCU_CLK->CPUCLKCR = __CPUCLKCR;
 8000432:	4b5b      	ldr	r3, [pc, #364]	; (80005a0 <SystemCoreClockSetup+0x2bc>)
 8000434:	2200      	movs	r2, #0
 8000436:	611a      	str	r2, [r3, #16]
  SCU_CLK->CCUCLKCR = __CCUCLKCR;
 8000438:	4b59      	ldr	r3, [pc, #356]	; (80005a0 <SystemCoreClockSetup+0x2bc>)
 800043a:	2200      	movs	r2, #0
 800043c:	621a      	str	r2, [r3, #32]
  SCU_CLK->WDTCLKCR = __WDTCLKCR;
 800043e:	4b58      	ldr	r3, [pc, #352]	; (80005a0 <SystemCoreClockSetup+0x2bc>)
 8000440:	2200      	movs	r2, #0
 8000442:	625a      	str	r2, [r3, #36]	; 0x24
  SCU_CLK->EBUCLKCR = __EBUCLKCR;
 8000444:	4b56      	ldr	r3, [pc, #344]	; (80005a0 <SystemCoreClockSetup+0x2bc>)
 8000446:	2203      	movs	r2, #3
 8000448:	61da      	str	r2, [r3, #28]
  SCU_CLK->USBCLKCR = __USBCLKCR;
 800044a:	4b55      	ldr	r3, [pc, #340]	; (80005a0 <SystemCoreClockSetup+0x2bc>)
 800044c:	4a55      	ldr	r2, [pc, #340]	; (80005a4 <SystemCoreClockSetup+0x2c0>)
 800044e:	619a      	str	r2, [r3, #24]
  SCU_CLK->ECATCLKCR = __ECATCLKCR;
 8000450:	4b53      	ldr	r3, [pc, #332]	; (80005a0 <SystemCoreClockSetup+0x2bc>)
 8000452:	2201      	movs	r2, #1
 8000454:	639a      	str	r2, [r3, #56]	; 0x38
  SCU_CLK->EXTCLKCR = __EXTCLKCR;
 8000456:	4b52      	ldr	r3, [pc, #328]	; (80005a0 <SystemCoreClockSetup+0x2bc>)
 8000458:	4a53      	ldr	r2, [pc, #332]	; (80005a8 <SystemCoreClockSetup+0x2c4>)
 800045a:	629a      	str	r2, [r3, #40]	; 0x28

#if ENABLE_PLL
  /* PLL frequency stepping...*/
  /* Reset OSCDISCDIS */
  SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 800045c:	4a4c      	ldr	r2, [pc, #304]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 800045e:	4b4c      	ldr	r3, [pc, #304]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000460:	685b      	ldr	r3, [r3, #4]
 8000462:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000466:	6053      	str	r3, [r2, #4]

  SCU_PLL->PLLCON1 = ((PLL_NDIV << SCU_PLL_PLLCON1_NDIV_Pos) |
 8000468:	4b49      	ldr	r3, [pc, #292]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 800046a:	4a50      	ldr	r2, [pc, #320]	; (80005ac <SystemCoreClockSetup+0x2c8>)
 800046c:	609a      	str	r2, [r3, #8]
	                  (PLL_K2DIV_48MHZ << SCU_PLL_PLLCON1_K2DIV_Pos) |
	                  (PLL_PDIV << SCU_PLL_PLLCON1_PDIV_Pos));

  while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_K2RDY_Msk) == 0U)
 800046e:	bf00      	nop
 8000470:	4b47      	ldr	r3, [pc, #284]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000472:	681b      	ldr	r3, [r3, #0]
 8000474:	f003 0320 	and.w	r3, r3, #32
 8000478:	2b00      	cmp	r3, #0
 800047a:	d0f9      	beq.n	8000470 <SystemCoreClockSetup+0x18c>
  {
    /* wait until K2-divider operates on the configured value  */
  }

  delay(DELAY_CNT_50US_48MHZ);
 800047c:	f44f 6016 	mov.w	r0, #2400	; 0x960
 8000480:	f7ff ff0c 	bl	800029c <delay>

  SCU_PLL->PLLCON1 = ((PLL_NDIV << SCU_PLL_PLLCON1_NDIV_Pos) |
 8000484:	4b42      	ldr	r3, [pc, #264]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000486:	4a4a      	ldr	r2, [pc, #296]	; (80005b0 <SystemCoreClockSetup+0x2cc>)
 8000488:	609a      	str	r2, [r3, #8]
	                  (PLL_K2DIV_72MHZ << SCU_PLL_PLLCON1_K2DIV_Pos) |
	                  (PLL_PDIV << SCU_PLL_PLLCON1_PDIV_Pos));

  while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_K2RDY_Msk) == 0U)
 800048a:	bf00      	nop
 800048c:	4b40      	ldr	r3, [pc, #256]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 800048e:	681b      	ldr	r3, [r3, #0]
 8000490:	f003 0320 	and.w	r3, r3, #32
 8000494:	2b00      	cmp	r3, #0
 8000496:	d0f9      	beq.n	800048c <SystemCoreClockSetup+0x1a8>
  {
    /* wait until K2-divider operates on the configured value  */
  }

  delay(DELAY_CNT_50US_72MHZ);
 8000498:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 800049c:	f7ff fefe 	bl	800029c <delay>

  SCU_PLL->PLLCON1 = ((PLL_NDIV << SCU_PLL_PLLCON1_NDIV_Pos) |
 80004a0:	4b3b      	ldr	r3, [pc, #236]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80004a2:	4a44      	ldr	r2, [pc, #272]	; (80005b4 <SystemCoreClockSetup+0x2d0>)
 80004a4:	609a      	str	r2, [r3, #8]
	                  (PLL_K2DIV_96MHZ << SCU_PLL_PLLCON1_K2DIV_Pos) |
	                  (PLL_PDIV << SCU_PLL_PLLCON1_PDIV_Pos));

  while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_K2RDY_Msk) == 0U)
 80004a6:	bf00      	nop
 80004a8:	4b39      	ldr	r3, [pc, #228]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80004aa:	681b      	ldr	r3, [r3, #0]
 80004ac:	f003 0320 	and.w	r3, r3, #32
 80004b0:	2b00      	cmp	r3, #0
 80004b2:	d0f9      	beq.n	80004a8 <SystemCoreClockSetup+0x1c4>
  {
    /* wait until K2-divider operates on the configured value  */
  }

  delay(DELAY_CNT_50US_96MHZ);
 80004b4:	f44f 5096 	mov.w	r0, #4800	; 0x12c0
 80004b8:	f7ff fef0 	bl	800029c <delay>

  SCU_PLL->PLLCON1 = ((PLL_NDIV << SCU_PLL_PLLCON1_NDIV_Pos) |
 80004bc:	4b34      	ldr	r3, [pc, #208]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80004be:	4a3e      	ldr	r2, [pc, #248]	; (80005b8 <SystemCoreClockSetup+0x2d4>)
 80004c0:	609a      	str	r2, [r3, #8]
	                  (PLL_K2DIV_120MHZ << SCU_PLL_PLLCON1_K2DIV_Pos) |
	                  (PLL_PDIV << SCU_PLL_PLLCON1_PDIV_Pos));

  while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_K2RDY_Msk) == 0U)
 80004c2:	bf00      	nop
 80004c4:	4b32      	ldr	r3, [pc, #200]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80004c6:	681b      	ldr	r3, [r3, #0]
 80004c8:	f003 0320 	and.w	r3, r3, #32
 80004cc:	2b00      	cmp	r3, #0
 80004ce:	d0f9      	beq.n	80004c4 <SystemCoreClockSetup+0x1e0>
  {
    /* wait until K2-divider operates on the configured value  */
  }

  delay(DELAY_CNT_50US_120MHZ);
 80004d0:	f241 7070 	movw	r0, #6000	; 0x1770
 80004d4:	f7ff fee2 	bl	800029c <delay>

  SCU_PLL->PLLCON1 = ((PLL_NDIV << SCU_PLL_PLLCON1_NDIV_Pos) |
 80004d8:	4b2d      	ldr	r3, [pc, #180]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80004da:	4a38      	ldr	r2, [pc, #224]	; (80005bc <SystemCoreClockSetup+0x2d8>)
 80004dc:	609a      	str	r2, [r3, #8]
	                  (PLL_K2DIV << SCU_PLL_PLLCON1_K2DIV_Pos) |
	                  (PLL_PDIV << SCU_PLL_PLLCON1_PDIV_Pos));

  while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_K2RDY_Msk) == 0U)
 80004de:	bf00      	nop
 80004e0:	4b2b      	ldr	r3, [pc, #172]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80004e2:	681b      	ldr	r3, [r3, #0]
 80004e4:	f003 0320 	and.w	r3, r3, #32
 80004e8:	2b00      	cmp	r3, #0
 80004ea:	d0f9      	beq.n	80004e0 <SystemCoreClockSetup+0x1fc>
  {
    /* wait until K2-divider operates on the configured value  */
  }

  delay(DELAY_CNT_50US_144MHZ);
 80004ec:	f44f 50e1 	mov.w	r0, #7200	; 0x1c20
 80004f0:	f7ff fed4 	bl	800029c <delay>

  SCU_TRAP->TRAPCLR = SCU_TRAP_TRAPCLR_SOSCWDGT_Msk | SCU_TRAP_TRAPCLR_SVCOLCKT_Msk;
 80004f4:	4b32      	ldr	r3, [pc, #200]	; (80005c0 <SystemCoreClockSetup+0x2dc>)
 80004f6:	2205      	movs	r2, #5
 80004f8:	60da      	str	r2, [r3, #12]
#endif /* ENABLE_PLL */

#if ENABLE_USBPLL
  /* enable USB PLL first */
  SCU_PLL->USBPLLCON &= ~(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
 80004fa:	4a25      	ldr	r2, [pc, #148]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80004fc:	4b24      	ldr	r3, [pc, #144]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 80004fe:	695b      	ldr	r3, [r3, #20]
 8000500:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000504:	f023 0302 	bic.w	r3, r3, #2
 8000508:	6153      	str	r3, [r2, #20]

  /* USB PLL uses as clock input the OSC_HP */
  /* check and if not already running enable OSC_HP */
  if ((SCU_OSC->OSCHPCTRL & SCU_OSC_OSCHPCTRL_MODE_Msk) != 0U)
 800050a:	4b22      	ldr	r3, [pc, #136]	; (8000594 <SystemCoreClockSetup+0x2b0>)
 800050c:	685b      	ldr	r3, [r3, #4]
 800050e:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8000512:	2b00      	cmp	r3, #0
 8000514:	d031      	beq.n	800057a <SystemCoreClockSetup+0x296>
  {
    /* check if Main PLL is switched on for OSC WDG*/
    if ((SCU_PLL->PLLCON0 &(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk)) != 0UL)
 8000516:	4b1e      	ldr	r3, [pc, #120]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000518:	685a      	ldr	r2, [r3, #4]
 800051a:	4b2a      	ldr	r3, [pc, #168]	; (80005c4 <SystemCoreClockSetup+0x2e0>)
 800051c:	4013      	ands	r3, r2
 800051e:	2b00      	cmp	r3, #0
 8000520:	d007      	beq.n	8000532 <SystemCoreClockSetup+0x24e>
    {
      /* enable PLL first */
      SCU_PLL->PLLCON0 &= ~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8000522:	4a1b      	ldr	r2, [pc, #108]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000524:	4b1a      	ldr	r3, [pc, #104]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000526:	685b      	ldr	r3, [r3, #4]
 8000528:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800052c:	f023 0302 	bic.w	r3, r3, #2
 8000530:	6053      	str	r3, [r2, #4]
    }

    SCU_OSC->OSCHPCTRL &= ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk);
 8000532:	4a18      	ldr	r2, [pc, #96]	; (8000594 <SystemCoreClockSetup+0x2b0>)
 8000534:	4b17      	ldr	r3, [pc, #92]	; (8000594 <SystemCoreClockSetup+0x2b0>)
 8000536:	685b      	ldr	r3, [r3, #4]
 8000538:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 800053c:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8000540:	6053      	str	r3, [r2, #4]
    SCU_OSC->OSCHPCTRL |= ((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos;
 8000542:	f000 f8f9 	bl	8000738 <OSCHP_GetFrequency>
 8000546:	4602      	mov	r2, r0
 8000548:	4b13      	ldr	r3, [pc, #76]	; (8000598 <SystemCoreClockSetup+0x2b4>)
 800054a:	fba3 2302 	umull	r2, r3, r3, r2
 800054e:	0d1b      	lsrs	r3, r3, #20
 8000550:	3b01      	subs	r3, #1
 8000552:	041b      	lsls	r3, r3, #16
 8000554:	490f      	ldr	r1, [pc, #60]	; (8000594 <SystemCoreClockSetup+0x2b0>)
 8000556:	4a0f      	ldr	r2, [pc, #60]	; (8000594 <SystemCoreClockSetup+0x2b0>)
 8000558:	6852      	ldr	r2, [r2, #4]
 800055a:	4313      	orrs	r3, r2
 800055c:	604b      	str	r3, [r1, #4]

    /* restart OSC Watchdog */
    SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_OSCRES_Msk;
 800055e:	4a0c      	ldr	r2, [pc, #48]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000560:	4b0b      	ldr	r3, [pc, #44]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 8000562:	685b      	ldr	r3, [r3, #4]
 8000564:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8000568:	6053      	str	r3, [r2, #4]

    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_OSC_USABLE) != SCU_PLL_PLLSTAT_OSC_USABLE)
 800056a:	bf00      	nop
 800056c:	4b08      	ldr	r3, [pc, #32]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 800056e:	681b      	ldr	r3, [r3, #0]
 8000570:	f403 7360 	and.w	r3, r3, #896	; 0x380
 8000574:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8000578:	d1f8      	bne.n	800056c <SystemCoreClockSetup+0x288>
    }
  }

  /* Setup USB PLL */
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= SCU_PLL_USBPLLCON_VCOBYP_Msk;
 800057a:	4a05      	ldr	r2, [pc, #20]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 800057c:	4b04      	ldr	r3, [pc, #16]	; (8000590 <SystemCoreClockSetup+0x2ac>)
 800057e:	695b      	ldr	r3, [r3, #20]
 8000580:	f043 0301 	orr.w	r3, r3, #1
 8000584:	6153      	str	r3, [r2, #20]
 8000586:	e01f      	b.n	80005c8 <SystemCoreClockSetup+0x2e4>
 8000588:	50004200 	.word	0x50004200
 800058c:	50004400 	.word	0x50004400
 8000590:	50004710 	.word	0x50004710
 8000594:	50004700 	.word	0x50004700
 8000598:	6b5fca6b 	.word	0x6b5fca6b
 800059c:	010b2f00 	.word	0x010b2f00
 80005a0:	50004600 	.word	0x50004600
 80005a4:	00010005 	.word	0x00010005
 80005a8:	01200003 	.word	0x01200003
 80005ac:	01052f00 	.word	0x01052f00
 80005b0:	01032f00 	.word	0x01032f00
 80005b4:	01022f00 	.word	0x01022f00
 80005b8:	01012f00 	.word	0x01012f00
 80005bc:	01002f00 	.word	0x01002f00
 80005c0:	50004160 	.word	0x50004160
 80005c4:	00010002 	.word	0x00010002
  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOBYST_Msk) == 0U)
 80005c8:	bf00      	nop
 80005ca:	4b22      	ldr	r3, [pc, #136]	; (8000654 <SystemCoreClockSetup+0x370>)
 80005cc:	691b      	ldr	r3, [r3, #16]
 80005ce:	f003 0301 	and.w	r3, r3, #1
 80005d2:	2b00      	cmp	r3, #0
 80005d4:	d0f9      	beq.n	80005ca <SystemCoreClockSetup+0x2e6>
  {
    /* wait for prescaler mode */
  }

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= SCU_PLL_USBPLLCON_FINDIS_Msk;
 80005d6:	4a1f      	ldr	r2, [pc, #124]	; (8000654 <SystemCoreClockSetup+0x370>)
 80005d8:	4b1e      	ldr	r3, [pc, #120]	; (8000654 <SystemCoreClockSetup+0x370>)
 80005da:	695b      	ldr	r3, [r3, #20]
 80005dc:	f043 0310 	orr.w	r3, r3, #16
 80005e0:	6153      	str	r3, [r2, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = ((USB_NDIV << SCU_PLL_USBPLLCON_NDIV_Pos) |
 80005e2:	4b1c      	ldr	r3, [pc, #112]	; (8000654 <SystemCoreClockSetup+0x370>)
 80005e4:	4a1c      	ldr	r2, [pc, #112]	; (8000658 <SystemCoreClockSetup+0x374>)
 80005e6:	615a      	str	r2, [r3, #20]
                        (USB_PDIV << SCU_PLL_USBPLLCON_PDIV_Pos));

  /* Set OSCDISCDIS */
  SCU_PLL->USBPLLCON |= SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 80005e8:	4a1a      	ldr	r2, [pc, #104]	; (8000654 <SystemCoreClockSetup+0x370>)
 80005ea:	4b1a      	ldr	r3, [pc, #104]	; (8000654 <SystemCoreClockSetup+0x370>)
 80005ec:	695b      	ldr	r3, [r3, #20]
 80005ee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80005f2:	6153      	str	r3, [r2, #20]

  /* connect Oscillator to USB PLL */
  SCU_PLL->USBPLLCON &= ~SCU_PLL_USBPLLCON_FINDIS_Msk;
 80005f4:	4a17      	ldr	r2, [pc, #92]	; (8000654 <SystemCoreClockSetup+0x370>)
 80005f6:	4b17      	ldr	r3, [pc, #92]	; (8000654 <SystemCoreClockSetup+0x370>)
 80005f8:	695b      	ldr	r3, [r3, #20]
 80005fa:	f023 0310 	bic.w	r3, r3, #16
 80005fe:	6153      	str	r3, [r2, #20]

  /* restart PLL Lock detection */
  SCU_PLL->USBPLLCON |= SCU_PLL_USBPLLCON_RESLD_Msk;
 8000600:	4a14      	ldr	r2, [pc, #80]	; (8000654 <SystemCoreClockSetup+0x370>)
 8000602:	4b14      	ldr	r3, [pc, #80]	; (8000654 <SystemCoreClockSetup+0x370>)
 8000604:	695b      	ldr	r3, [r3, #20]
 8000606:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800060a:	6153      	str	r3, [r2, #20]

  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) == 0U)
 800060c:	bf00      	nop
 800060e:	4b11      	ldr	r3, [pc, #68]	; (8000654 <SystemCoreClockSetup+0x370>)
 8000610:	691b      	ldr	r3, [r3, #16]
 8000612:	f003 0304 	and.w	r3, r3, #4
 8000616:	2b00      	cmp	r3, #0
 8000618:	d0f9      	beq.n	800060e <SystemCoreClockSetup+0x32a>
  {
    /* wait for PLL Lock */
  }

  /* Disable bypass- put PLL clock back */
  SCU_PLL->USBPLLCON &= ~SCU_PLL_USBPLLCON_VCOBYP_Msk;
 800061a:	4a0e      	ldr	r2, [pc, #56]	; (8000654 <SystemCoreClockSetup+0x370>)
 800061c:	4b0d      	ldr	r3, [pc, #52]	; (8000654 <SystemCoreClockSetup+0x370>)
 800061e:	695b      	ldr	r3, [r3, #20]
 8000620:	f023 0301 	bic.w	r3, r3, #1
 8000624:	6153      	str	r3, [r2, #20]
  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOBYST_Msk) != 0U)
 8000626:	bf00      	nop
 8000628:	4b0a      	ldr	r3, [pc, #40]	; (8000654 <SystemCoreClockSetup+0x370>)
 800062a:	691b      	ldr	r3, [r3, #16]
 800062c:	f003 0301 	and.w	r3, r3, #1
 8000630:	2b00      	cmp	r3, #0
 8000632:	d1f9      	bne.n	8000628 <SystemCoreClockSetup+0x344>
  {
    /* wait for normal mode */
  }

  /* Reset OSCDISCDIS */
  SCU_PLL->USBPLLCON &= ~SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 8000634:	4a07      	ldr	r2, [pc, #28]	; (8000654 <SystemCoreClockSetup+0x370>)
 8000636:	4b07      	ldr	r3, [pc, #28]	; (8000654 <SystemCoreClockSetup+0x370>)
 8000638:	695b      	ldr	r3, [r3, #20]
 800063a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800063e:	6153      	str	r3, [r2, #20]

  SCU_TRAP->TRAPCLR = SCU_TRAP_TRAPCLR_UVCOLCKT_Msk;
 8000640:	4b06      	ldr	r3, [pc, #24]	; (800065c <SystemCoreClockSetup+0x378>)
 8000642:	2208      	movs	r2, #8
 8000644:	60da      	str	r2, [r3, #12]
#endif

  /* Enable selected clocks */
  SCU_CLK->CLKSET = __CLKSET;
 8000646:	4b06      	ldr	r3, [pc, #24]	; (8000660 <SystemCoreClockSetup+0x37c>)
 8000648:	2200      	movs	r2, #0
 800064a:	605a      	str	r2, [r3, #4]
  PORT0->PDR1 &= ~PORT0_PDR1_PD8_Msk;
  PORT0->IOCR8 = (PORT0->IOCR8 & ~PORT0_IOCR8_PC8_Msk) | (0x11U << PORT0_IOCR8_PC8_Pos);
#endif
#endif  /* ENABLE_EXTCLK == 1  */

  SystemCoreClockUpdate();
 800064c:	f000 f80a 	bl	8000664 <SystemCoreClockUpdate>
}
 8000650:	bd80      	pop	{r7, pc}
 8000652:	bf00      	nop
 8000654:	50004710 	.word	0x50004710
 8000658:	02006300 	.word	0x02006300
 800065c:	50004160 	.word	0x50004160
 8000660:	50004600 	.word	0x50004600

08000664 <SystemCoreClockUpdate>:

__WEAK void SystemCoreClockUpdate(void)
{
 8000664:	b580      	push	{r7, lr}
 8000666:	b084      	sub	sp, #16
 8000668:	af00      	add	r7, sp, #0
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 800066a:	4b2f      	ldr	r3, [pc, #188]	; (8000728 <SystemCoreClockUpdate+0xc4>)
 800066c:	68db      	ldr	r3, [r3, #12]
 800066e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8000672:	2b00      	cmp	r3, #0
 8000674:	d03e      	beq.n	80006f4 <SystemCoreClockUpdate+0x90>
  {
    /* fPLL is clock source for fSYS */
    if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk)
 8000676:	4b2d      	ldr	r3, [pc, #180]	; (800072c <SystemCoreClockUpdate+0xc8>)
 8000678:	68db      	ldr	r3, [r3, #12]
 800067a:	f003 0301 	and.w	r3, r3, #1
 800067e:	2b00      	cmp	r3, #0
 8000680:	d002      	beq.n	8000688 <SystemCoreClockUpdate+0x24>
    {
      /* PLL input clock is the backup clock (fOFI) */
      temp = OFI_FREQUENCY;
 8000682:	4b2b      	ldr	r3, [pc, #172]	; (8000730 <SystemCoreClockUpdate+0xcc>)
 8000684:	60fb      	str	r3, [r7, #12]
 8000686:	e002      	b.n	800068e <SystemCoreClockUpdate+0x2a>
    }
    else
    {
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
 8000688:	f000 f856 	bl	8000738 <OSCHP_GetFrequency>
 800068c:	60f8      	str	r0, [r7, #12]
    }

    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
 800068e:	4b27      	ldr	r3, [pc, #156]	; (800072c <SystemCoreClockUpdate+0xc8>)
 8000690:	681b      	ldr	r3, [r3, #0]
 8000692:	f003 0304 	and.w	r3, r3, #4
 8000696:	2b00      	cmp	r3, #0
 8000698:	d020      	beq.n	80006dc <SystemCoreClockUpdate+0x78>
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 800069a:	4b24      	ldr	r3, [pc, #144]	; (800072c <SystemCoreClockUpdate+0xc8>)
 800069c:	689b      	ldr	r3, [r3, #8]
 800069e:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 80006a2:	0e1b      	lsrs	r3, r3, #24
 80006a4:	3301      	adds	r3, #1
 80006a6:	60bb      	str	r3, [r7, #8]
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 80006a8:	4b20      	ldr	r3, [pc, #128]	; (800072c <SystemCoreClockUpdate+0xc8>)
 80006aa:	689b      	ldr	r3, [r3, #8]
 80006ac:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 80006b0:	0a1b      	lsrs	r3, r3, #8
 80006b2:	3301      	adds	r3, #1
 80006b4:	607b      	str	r3, [r7, #4]
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 80006b6:	4b1d      	ldr	r3, [pc, #116]	; (800072c <SystemCoreClockUpdate+0xc8>)
 80006b8:	689b      	ldr	r3, [r3, #8]
 80006ba:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 80006be:	0c1b      	lsrs	r3, r3, #16
 80006c0:	3301      	adds	r3, #1
 80006c2:	603b      	str	r3, [r7, #0]

      temp = (temp / (pdiv * kdiv)) * ndiv;
 80006c4:	68bb      	ldr	r3, [r7, #8]
 80006c6:	683a      	ldr	r2, [r7, #0]
 80006c8:	fb02 f303 	mul.w	r3, r2, r3
 80006cc:	68fa      	ldr	r2, [r7, #12]
 80006ce:	fbb2 f3f3 	udiv	r3, r2, r3
 80006d2:	687a      	ldr	r2, [r7, #4]
 80006d4:	fb02 f303 	mul.w	r3, r2, r3
 80006d8:	60fb      	str	r3, [r7, #12]
 80006da:	e00d      	b.n	80006f8 <SystemCoreClockUpdate+0x94>
    }
    else
    {
      /* PLL prescalar mode */
      /* read back divider settings */
      kdiv  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K1DIV_Msk) >> SCU_PLL_PLLCON1_K1DIV_Pos) + 1;
 80006dc:	4b13      	ldr	r3, [pc, #76]	; (800072c <SystemCoreClockUpdate+0xc8>)
 80006de:	689b      	ldr	r3, [r3, #8]
 80006e0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80006e4:	3301      	adds	r3, #1
 80006e6:	603b      	str	r3, [r7, #0]

      temp = (temp / kdiv);
 80006e8:	68fa      	ldr	r2, [r7, #12]
 80006ea:	683b      	ldr	r3, [r7, #0]
 80006ec:	fbb2 f3f3 	udiv	r3, r2, r3
 80006f0:	60fb      	str	r3, [r7, #12]
 80006f2:	e001      	b.n	80006f8 <SystemCoreClockUpdate+0x94>
    }
  }
  else
  {
    /* fOFI is clock source for fSYS */
    temp = OFI_FREQUENCY;
 80006f4:	4b0e      	ldr	r3, [pc, #56]	; (8000730 <SystemCoreClockUpdate+0xcc>)
 80006f6:	60fb      	str	r3, [r7, #12]
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80006f8:	4b0b      	ldr	r3, [pc, #44]	; (8000728 <SystemCoreClockUpdate+0xc4>)
 80006fa:	68db      	ldr	r3, [r3, #12]
 80006fc:	b2db      	uxtb	r3, r3
 80006fe:	3301      	adds	r3, #1
 8000700:	68fa      	ldr	r2, [r7, #12]
 8000702:	fbb2 f3f3 	udiv	r3, r2, r3
 8000706:	60fb      	str	r3, [r7, #12]
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 8000708:	4b07      	ldr	r3, [pc, #28]	; (8000728 <SystemCoreClockUpdate+0xc4>)
 800070a:	691b      	ldr	r3, [r3, #16]
 800070c:	f003 0301 	and.w	r3, r3, #1
 8000710:	3301      	adds	r3, #1
 8000712:	68fa      	ldr	r2, [r7, #12]
 8000714:	fbb2 f3f3 	udiv	r3, r2, r3
 8000718:	60fb      	str	r3, [r7, #12]

  SystemCoreClock = temp;
 800071a:	4a06      	ldr	r2, [pc, #24]	; (8000734 <SystemCoreClockUpdate+0xd0>)
 800071c:	68fb      	ldr	r3, [r7, #12]
 800071e:	6013      	str	r3, [r2, #0]
}
 8000720:	3710      	adds	r7, #16
 8000722:	46bd      	mov	sp, r7
 8000724:	bd80      	pop	{r7, pc}
 8000726:	bf00      	nop
 8000728:	50004600 	.word	0x50004600
 800072c:	50004710 	.word	0x50004710
 8000730:	016e3600 	.word	0x016e3600
 8000734:	2003ffc0 	.word	0x2003ffc0

08000738 <OSCHP_GetFrequency>:

__WEAK uint32_t OSCHP_GetFrequency(void)
{
 8000738:	b480      	push	{r7}
 800073a:	af00      	add	r7, sp, #0
  return OSCHP_FREQUENCY;
 800073c:	4b02      	ldr	r3, [pc, #8]	; (8000748 <OSCHP_GetFrequency+0x10>)
}
 800073e:	4618      	mov	r0, r3
 8000740:	46bd      	mov	sp, r7
 8000742:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000746:	4770      	bx	lr
 8000748:	00b71b00 	.word	0x00b71b00

0800074c <XMC_SCU_RESET_DeassertPeripheralReset>:
  *(volatile uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
}

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
 800074c:	b480      	push	{r7}
 800074e:	b085      	sub	sp, #20
 8000750:	af00      	add	r7, sp, #0
 8000752:	6078      	str	r0, [r7, #4]
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8000754:	687b      	ldr	r3, [r7, #4]
 8000756:	0f1b      	lsrs	r3, r3, #28
 8000758:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 800075a:	687b      	ldr	r3, [r7, #4]
 800075c:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8000760:	60bb      	str	r3, [r7, #8]

  *(volatile uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 8000762:	68fa      	ldr	r2, [r7, #12]
 8000764:	4613      	mov	r3, r2
 8000766:	005b      	lsls	r3, r3, #1
 8000768:	4413      	add	r3, r2
 800076a:	009b      	lsls	r3, r3, #2
 800076c:	461a      	mov	r2, r3
 800076e:	4b04      	ldr	r3, [pc, #16]	; (8000780 <XMC_SCU_RESET_DeassertPeripheralReset+0x34>)
 8000770:	4413      	add	r3, r2
 8000772:	68ba      	ldr	r2, [r7, #8]
 8000774:	601a      	str	r2, [r3, #0]
}
 8000776:	3714      	adds	r7, #20
 8000778:	46bd      	mov	sp, r7
 800077a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800077e:	4770      	bx	lr
 8000780:	50004414 	.word	0x50004414

08000784 <XMC_SCU_RESET_IsPeripheralResetAsserted>:

/* Find out if the peripheral reset is asserted */
bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
 8000784:	b480      	push	{r7}
 8000786:	b085      	sub	sp, #20
 8000788:	af00      	add	r7, sp, #0
 800078a:	6078      	str	r0, [r7, #4]
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 800078c:	687b      	ldr	r3, [r7, #4]
 800078e:	0f1b      	lsrs	r3, r3, #28
 8000790:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8000792:	687b      	ldr	r3, [r7, #4]
 8000794:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8000798:	60bb      	str	r3, [r7, #8]

  return ((*(const volatile uint32_t *)(&(SCU_RESET->PRSTAT0) + (index * 3U)) & mask) != 0U);
 800079a:	68fa      	ldr	r2, [r7, #12]
 800079c:	4613      	mov	r3, r2
 800079e:	005b      	lsls	r3, r3, #1
 80007a0:	4413      	add	r3, r2
 80007a2:	009b      	lsls	r3, r3, #2
 80007a4:	461a      	mov	r2, r3
 80007a6:	4b08      	ldr	r3, [pc, #32]	; (80007c8 <XMC_SCU_RESET_IsPeripheralResetAsserted+0x44>)
 80007a8:	4413      	add	r3, r2
 80007aa:	681a      	ldr	r2, [r3, #0]
 80007ac:	68bb      	ldr	r3, [r7, #8]
 80007ae:	4013      	ands	r3, r2
 80007b0:	2b00      	cmp	r3, #0
 80007b2:	bf14      	ite	ne
 80007b4:	2301      	movne	r3, #1
 80007b6:	2300      	moveq	r3, #0
 80007b8:	b2db      	uxtb	r3, r3
}
 80007ba:	4618      	mov	r0, r3
 80007bc:	3714      	adds	r7, #20
 80007be:	46bd      	mov	sp, r7
 80007c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007c4:	4770      	bx	lr
 80007c6:	bf00      	nop
 80007c8:	5000440c 	.word	0x5000440c

080007cc <XMC_SCU_CLOCK_UngatePeripheralClock>:
  *(volatile uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) = (uint32_t)mask;
}

/* API to ungate a given module clock */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
 80007cc:	b480      	push	{r7}
 80007ce:	b085      	sub	sp, #20
 80007d0:	af00      	add	r7, sp, #0
 80007d2:	6078      	str	r0, [r7, #4]
  uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
 80007d4:	687b      	ldr	r3, [r7, #4]
 80007d6:	0f1b      	lsrs	r3, r3, #28
 80007d8:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 80007da:	687b      	ldr	r3, [r7, #4]
 80007dc:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 80007e0:	60bb      	str	r3, [r7, #8]

  *(volatile uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) = (uint32_t)mask;
 80007e2:	68fa      	ldr	r2, [r7, #12]
 80007e4:	4613      	mov	r3, r2
 80007e6:	005b      	lsls	r3, r3, #1
 80007e8:	4413      	add	r3, r2
 80007ea:	009b      	lsls	r3, r3, #2
 80007ec:	461a      	mov	r2, r3
 80007ee:	4b04      	ldr	r3, [pc, #16]	; (8000800 <XMC_SCU_CLOCK_UngatePeripheralClock+0x34>)
 80007f0:	4413      	add	r3, r2
 80007f2:	68ba      	ldr	r2, [r7, #8]
 80007f4:	601a      	str	r2, [r3, #0]
}
 80007f6:	3714      	adds	r7, #20
 80007f8:	46bd      	mov	sp, r7
 80007fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007fe:	4770      	bx	lr
 8000800:	50004648 	.word	0x50004648

08000804 <XMC_SCU_CLOCK_IsPeripheralClockGated>:

/* API to ungate a given module clock */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
 8000804:	b480      	push	{r7}
 8000806:	b085      	sub	sp, #20
 8000808:	af00      	add	r7, sp, #0
 800080a:	6078      	str	r0, [r7, #4]
  uint32_t index = ((peripheral & 0xf0000000UL) >> 28UL);
 800080c:	687b      	ldr	r3, [r7, #4]
 800080e:	0f1b      	lsrs	r3, r3, #28
 8000810:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 8000812:	687b      	ldr	r3, [r7, #4]
 8000814:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8000818:	60bb      	str	r3, [r7, #8]

  return ((*(const volatile uint32_t *)(&(SCU_CLK->CGATSTAT0) + (index * 3U)) & mask) != 0U);
 800081a:	68fa      	ldr	r2, [r7, #12]
 800081c:	4613      	mov	r3, r2
 800081e:	005b      	lsls	r3, r3, #1
 8000820:	4413      	add	r3, r2
 8000822:	009b      	lsls	r3, r3, #2
 8000824:	461a      	mov	r2, r3
 8000826:	4b08      	ldr	r3, [pc, #32]	; (8000848 <XMC_SCU_CLOCK_IsPeripheralClockGated+0x44>)
 8000828:	4413      	add	r3, r2
 800082a:	681a      	ldr	r2, [r3, #0]
 800082c:	68bb      	ldr	r3, [r7, #8]
 800082e:	4013      	ands	r3, r2
 8000830:	2b00      	cmp	r3, #0
 8000832:	bf14      	ite	ne
 8000834:	2301      	movne	r3, #1
 8000836:	2300      	moveq	r3, #0
 8000838:	b2db      	uxtb	r3, r3
}
 800083a:	4618      	mov	r0, r3
 800083c:	3714      	adds	r7, #20
 800083e:	46bd      	mov	sp, r7
 8000840:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000844:	4770      	bx	lr
 8000846:	bf00      	nop
 8000848:	50004640 	.word	0x50004640

0800084c <XMC_DMA_GetEventStatus>:
 * Source transaction complete -> ::XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE      <br>
 * Destination transaction complete -> ::XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE <br>
 * DMA error event -> ::XMC_DMA_CH_EVENT_ERROR                                     <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetEventStatus(XMC_DMA_t *const dma)
{
 800084c:	b480      	push	{r7}
 800084e:	b083      	sub	sp, #12
 8000850:	af00      	add	r7, sp, #0
 8000852:	6078      	str	r0, [r7, #4]
  return (dma->STATUSGLEV);
 8000854:	687b      	ldr	r3, [r7, #4]
 8000856:	f8d3 3360 	ldr.w	r3, [r3, #864]	; 0x360
}
 800085a:	4618      	mov	r0, r3
 800085c:	370c      	adds	r7, #12
 800085e:	46bd      	mov	sp, r7
 8000860:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000864:	4770      	bx	lr
 8000866:	bf00      	nop

08000868 <XMC_DMA_GetChannelsTransferCompleteStatus>:
 *
 * \par
 * The function returns GPDMA transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsTransferCompleteStatus(XMC_DMA_t *const dma)
{
 8000868:	b480      	push	{r7}
 800086a:	b083      	sub	sp, #12
 800086c:	af00      	add	r7, sp, #0
 800086e:	6078      	str	r0, [r7, #4]
  return (dma->STATUSCHEV[0]);
 8000870:	687b      	ldr	r3, [r7, #4]
 8000872:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
}
 8000876:	4618      	mov	r0, r3
 8000878:	370c      	adds	r7, #12
 800087a:	46bd      	mov	sp, r7
 800087c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000880:	4770      	bx	lr
 8000882:	bf00      	nop

08000884 <XMC_DMA_GetChannelsBlockCompleteStatus>:
 *
 * \par
 * The function returns GPDMA block transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsBlockCompleteStatus(XMC_DMA_t *const dma)
{
 8000884:	b480      	push	{r7}
 8000886:	b083      	sub	sp, #12
 8000888:	af00      	add	r7, sp, #0
 800088a:	6078      	str	r0, [r7, #4]
  return (dma->STATUSCHEV[2]);
 800088c:	687b      	ldr	r3, [r7, #4]
 800088e:	f8d3 32f0 	ldr.w	r3, [r3, #752]	; 0x2f0
}
 8000892:	4618      	mov	r0, r3
 8000894:	370c      	adds	r7, #12
 8000896:	46bd      	mov	sp, r7
 8000898:	f85d 7b04 	ldr.w	r7, [sp], #4
 800089c:	4770      	bx	lr
 800089e:	bf00      	nop

080008a0 <XMC_DMA_GetChannelsSourceTransactionCompleteStatus>:
 * \par<b>Note: </b><br>
 * If the source peripheral is memory, the source transaction complete interrupt is
 * ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsSourceTransactionCompleteStatus(XMC_DMA_t *const dma)
{
 80008a0:	b480      	push	{r7}
 80008a2:	b083      	sub	sp, #12
 80008a4:	af00      	add	r7, sp, #0
 80008a6:	6078      	str	r0, [r7, #4]
  return (dma->STATUSCHEV[4]);
 80008a8:	687b      	ldr	r3, [r7, #4]
 80008aa:	f8d3 32f8 	ldr.w	r3, [r3, #760]	; 0x2f8
}
 80008ae:	4618      	mov	r0, r3
 80008b0:	370c      	adds	r7, #12
 80008b2:	46bd      	mov	sp, r7
 80008b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008b8:	4770      	bx	lr
 80008ba:	bf00      	nop

080008bc <XMC_DMA_GetChannelsDestinationTransactionCompleteStatus>:
 * \par<b>Note: </b><br>
 * If the destination peripheral is memory, the destination transaction complete
 * interrupt is ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(XMC_DMA_t *const dma)
{
 80008bc:	b480      	push	{r7}
 80008be:	b083      	sub	sp, #12
 80008c0:	af00      	add	r7, sp, #0
 80008c2:	6078      	str	r0, [r7, #4]
  return (dma->STATUSCHEV[6]);
 80008c4:	687b      	ldr	r3, [r7, #4]
 80008c6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
}
 80008ca:	4618      	mov	r0, r3
 80008cc:	370c      	adds	r7, #12
 80008ce:	46bd      	mov	sp, r7
 80008d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008d4:	4770      	bx	lr
 80008d6:	bf00      	nop

080008d8 <XMC_DMA_GetChannelsErrorStatus>:
 *
 * \par
 * The function returns error interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsErrorStatus(XMC_DMA_t *const dma)
{
 80008d8:	b480      	push	{r7}
 80008da:	b083      	sub	sp, #12
 80008dc:	af00      	add	r7, sp, #0
 80008de:	6078      	str	r0, [r7, #4]
  return (dma->STATUSCHEV[8]);
 80008e0:	687b      	ldr	r3, [r7, #4]
 80008e2:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
}
 80008e6:	4618      	mov	r0, r3
 80008e8:	370c      	adds	r7, #12
 80008ea:	46bd      	mov	sp, r7
 80008ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008f0:	4770      	bx	lr
 80008f2:	bf00      	nop

080008f4 <XMC_DMA_Init>:
 * API IMPLEMENTATION
 *******************************************************************************/

/* Initialize GPDMA */
void XMC_DMA_Init(XMC_DMA_t *const dma)
{
 80008f4:	b580      	push	{r7, lr}
 80008f6:	b082      	sub	sp, #8
 80008f8:	af00      	add	r7, sp, #0
 80008fa:	6078      	str	r0, [r7, #4]
  XMC_DMA_Enable(dma);
 80008fc:	6878      	ldr	r0, [r7, #4]
 80008fe:	f000 f803 	bl	8000908 <XMC_DMA_Enable>
}
 8000902:	3708      	adds	r7, #8
 8000904:	46bd      	mov	sp, r7
 8000906:	bd80      	pop	{r7, pc}

08000908 <XMC_DMA_Enable>:

/* Enable GPDMA module */
void XMC_DMA_Enable(XMC_DMA_t *const dma)
{
 8000908:	b580      	push	{r7, lr}
 800090a:	b082      	sub	sp, #8
 800090c:	af00      	add	r7, sp, #0
 800090e:	6078      	str	r0, [r7, #4]
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8000910:	687b      	ldr	r3, [r7, #4]
 8000912:	4a0b      	ldr	r2, [pc, #44]	; (8000940 <XMC_DMA_Enable+0x38>)
 8000914:	4293      	cmp	r3, r2
 8000916:	d106      	bne.n	8000926 <XMC_DMA_Enable+0x1e>
  {
#endif
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 8000918:	480a      	ldr	r0, [pc, #40]	; (8000944 <XMC_DMA_Enable+0x3c>)
 800091a:	f7ff ff57 	bl	80007cc <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 800091e:	4809      	ldr	r0, [pc, #36]	; (8000944 <XMC_DMA_Enable+0x3c>)
 8000920:	f7ff ff14 	bl	800074c <XMC_SCU_RESET_DeassertPeripheralReset>
 8000924:	e005      	b.n	8000932 <XMC_DMA_Enable+0x2a>
#if defined(GPDMA1)
  }
  else
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 8000926:	4808      	ldr	r0, [pc, #32]	; (8000948 <XMC_DMA_Enable+0x40>)
 8000928:	f7ff ff50 	bl	80007cc <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
 800092c:	4806      	ldr	r0, [pc, #24]	; (8000948 <XMC_DMA_Enable+0x40>)
 800092e:	f7ff ff0d 	bl	800074c <XMC_SCU_RESET_DeassertPeripheralReset>
  }
#endif

  dma->DMACFGREG = 0x1U;
 8000932:	687b      	ldr	r3, [r7, #4]
 8000934:	2201      	movs	r2, #1
 8000936:	f8c3 2398 	str.w	r2, [r3, #920]	; 0x398
}
 800093a:	3708      	adds	r7, #8
 800093c:	46bd      	mov	sp, r7
 800093e:	bd80      	pop	{r7, pc}
 8000940:	50014000 	.word	0x50014000
 8000944:	20000010 	.word	0x20000010
 8000948:	20000020 	.word	0x20000020

0800094c <XMC_DMA_IsEnabled>:
#endif
}

/* Check is the GPDMA peripheral is enabled */
bool XMC_DMA_IsEnabled(const XMC_DMA_t *const dma)
{
 800094c:	b580      	push	{r7, lr}
 800094e:	b084      	sub	sp, #16
 8000950:	af00      	add	r7, sp, #0
 8000952:	6078      	str	r0, [r7, #4]
  bool status;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8000954:	687b      	ldr	r3, [r7, #4]
 8000956:	4a33      	ldr	r2, [pc, #204]	; (8000a24 <XMC_DMA_IsEnabled+0xd8>)
 8000958:	4293      	cmp	r3, r2
 800095a:	d125      	bne.n	80009a8 <XMC_DMA_IsEnabled+0x5c>
  {
#endif
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 800095c:	4832      	ldr	r0, [pc, #200]	; (8000a28 <XMC_DMA_IsEnabled+0xdc>)
 800095e:	f7ff ff11 	bl	8000784 <XMC_SCU_RESET_IsPeripheralResetAsserted>
 8000962:	4603      	mov	r3, r0
 8000964:	2b00      	cmp	r3, #0
 8000966:	bf14      	ite	ne
 8000968:	2301      	movne	r3, #1
 800096a:	2300      	moveq	r3, #0
 800096c:	b2db      	uxtb	r3, r3
 800096e:	f083 0301 	eor.w	r3, r3, #1
 8000972:	b2db      	uxtb	r3, r3
 8000974:	73fb      	strb	r3, [r7, #15]
 8000976:	7bfb      	ldrb	r3, [r7, #15]
 8000978:	f003 0301 	and.w	r3, r3, #1
 800097c:	73fb      	strb	r3, [r7, #15]
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 800097e:	7bfb      	ldrb	r3, [r7, #15]
 8000980:	2b00      	cmp	r3, #0
 8000982:	d00a      	beq.n	800099a <XMC_DMA_IsEnabled+0x4e>
 8000984:	4828      	ldr	r0, [pc, #160]	; (8000a28 <XMC_DMA_IsEnabled+0xdc>)
 8000986:	f7ff ff3d 	bl	8000804 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 800098a:	4603      	mov	r3, r0
 800098c:	f083 0301 	eor.w	r3, r3, #1
 8000990:	b2db      	uxtb	r3, r3
 8000992:	2b00      	cmp	r3, #0
 8000994:	d001      	beq.n	800099a <XMC_DMA_IsEnabled+0x4e>
 8000996:	2301      	movs	r3, #1
 8000998:	e000      	b.n	800099c <XMC_DMA_IsEnabled+0x50>
 800099a:	2300      	movs	r3, #0
 800099c:	73fb      	strb	r3, [r7, #15]
 800099e:	7bfb      	ldrb	r3, [r7, #15]
 80009a0:	f003 0301 	and.w	r3, r3, #1
 80009a4:	73fb      	strb	r3, [r7, #15]
 80009a6:	e024      	b.n	80009f2 <XMC_DMA_IsEnabled+0xa6>
#endif
#if defined(GPDMA1)
  }
  else
  {
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
 80009a8:	4820      	ldr	r0, [pc, #128]	; (8000a2c <XMC_DMA_IsEnabled+0xe0>)
 80009aa:	f7ff feeb 	bl	8000784 <XMC_SCU_RESET_IsPeripheralResetAsserted>
 80009ae:	4603      	mov	r3, r0
 80009b0:	2b00      	cmp	r3, #0
 80009b2:	bf14      	ite	ne
 80009b4:	2301      	movne	r3, #1
 80009b6:	2300      	moveq	r3, #0
 80009b8:	b2db      	uxtb	r3, r3
 80009ba:	f083 0301 	eor.w	r3, r3, #1
 80009be:	b2db      	uxtb	r3, r3
 80009c0:	73fb      	strb	r3, [r7, #15]
 80009c2:	7bfb      	ldrb	r3, [r7, #15]
 80009c4:	f003 0301 	and.w	r3, r3, #1
 80009c8:	73fb      	strb	r3, [r7, #15]
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 80009ca:	7bfb      	ldrb	r3, [r7, #15]
 80009cc:	2b00      	cmp	r3, #0
 80009ce:	d00a      	beq.n	80009e6 <XMC_DMA_IsEnabled+0x9a>
 80009d0:	4816      	ldr	r0, [pc, #88]	; (8000a2c <XMC_DMA_IsEnabled+0xe0>)
 80009d2:	f7ff ff17 	bl	8000804 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 80009d6:	4603      	mov	r3, r0
 80009d8:	f083 0301 	eor.w	r3, r3, #1
 80009dc:	b2db      	uxtb	r3, r3
 80009de:	2b00      	cmp	r3, #0
 80009e0:	d001      	beq.n	80009e6 <XMC_DMA_IsEnabled+0x9a>
 80009e2:	2301      	movs	r3, #1
 80009e4:	e000      	b.n	80009e8 <XMC_DMA_IsEnabled+0x9c>
 80009e6:	2300      	movs	r3, #0
 80009e8:	73fb      	strb	r3, [r7, #15]
 80009ea:	7bfb      	ldrb	r3, [r7, #15]
 80009ec:	f003 0301 	and.w	r3, r3, #1
 80009f0:	73fb      	strb	r3, [r7, #15]
#endif
  }
#endif

  /* DMA reset is not asserted and peripheral clock is not gated */
  if (status == true)
 80009f2:	7bfb      	ldrb	r3, [r7, #15]
 80009f4:	2b00      	cmp	r3, #0
 80009f6:	d00f      	beq.n	8000a18 <XMC_DMA_IsEnabled+0xcc>
  {
    status = status && (dma->DMACFGREG != 0U);
 80009f8:	7bfb      	ldrb	r3, [r7, #15]
 80009fa:	2b00      	cmp	r3, #0
 80009fc:	d006      	beq.n	8000a0c <XMC_DMA_IsEnabled+0xc0>
 80009fe:	687b      	ldr	r3, [r7, #4]
 8000a00:	f8d3 3398 	ldr.w	r3, [r3, #920]	; 0x398
 8000a04:	2b00      	cmp	r3, #0
 8000a06:	d001      	beq.n	8000a0c <XMC_DMA_IsEnabled+0xc0>
 8000a08:	2301      	movs	r3, #1
 8000a0a:	e000      	b.n	8000a0e <XMC_DMA_IsEnabled+0xc2>
 8000a0c:	2300      	movs	r3, #0
 8000a0e:	73fb      	strb	r3, [r7, #15]
 8000a10:	7bfb      	ldrb	r3, [r7, #15]
 8000a12:	f003 0301 	and.w	r3, r3, #1
 8000a16:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 8000a18:	7bfb      	ldrb	r3, [r7, #15]
}
 8000a1a:	4618      	mov	r0, r3
 8000a1c:	3710      	adds	r7, #16
 8000a1e:	46bd      	mov	sp, r7
 8000a20:	bd80      	pop	{r7, pc}
 8000a22:	bf00      	nop
 8000a24:	50014000 	.word	0x50014000
 8000a28:	20000010 	.word	0x20000010
 8000a2c:	20000020 	.word	0x20000020

08000a30 <XMC_DMA_EnableRequestLine>:

/* Enable request line */
void XMC_DMA_EnableRequestLine(XMC_DMA_t *const dma, uint8_t line, uint8_t peripheral)
{
 8000a30:	b480      	push	{r7}
 8000a32:	b083      	sub	sp, #12
 8000a34:	af00      	add	r7, sp, #0
 8000a36:	6078      	str	r0, [r7, #4]
 8000a38:	460b      	mov	r3, r1
 8000a3a:	70fb      	strb	r3, [r7, #3]
 8000a3c:	4613      	mov	r3, r2
 8000a3e:	70bb      	strb	r3, [r7, #2]
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8000a40:	687b      	ldr	r3, [r7, #4]
 8000a42:	4a1f      	ldr	r2, [pc, #124]	; (8000ac0 <XMC_DMA_EnableRequestLine+0x90>)
 8000a44:	4293      	cmp	r3, r2
 8000a46:	d11b      	bne.n	8000a80 <XMC_DMA_EnableRequestLine+0x50>
  {
#else
  XMC_UNUSED_ARG(dma);
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8000a48:	481e      	ldr	r0, [pc, #120]	; (8000ac4 <XMC_DMA_EnableRequestLine+0x94>)
 8000a4a:	4b1e      	ldr	r3, [pc, #120]	; (8000ac4 <XMC_DMA_EnableRequestLine+0x94>)
 8000a4c:	689a      	ldr	r2, [r3, #8]
 8000a4e:	78fb      	ldrb	r3, [r7, #3]
 8000a50:	009b      	lsls	r3, r3, #2
 8000a52:	4619      	mov	r1, r3
 8000a54:	230f      	movs	r3, #15
 8000a56:	408b      	lsls	r3, r1
 8000a58:	43db      	mvns	r3, r3
 8000a5a:	401a      	ands	r2, r3
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8000a5c:	78bb      	ldrb	r3, [r7, #2]
 8000a5e:	78f9      	ldrb	r1, [r7, #3]
 8000a60:	0089      	lsls	r1, r1, #2
 8000a62:	408b      	lsls	r3, r1
  if (dma == XMC_DMA0)
  {
#else
  XMC_UNUSED_ARG(dma);
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8000a64:	4313      	orrs	r3, r2
 8000a66:	6083      	str	r3, [r0, #8]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
 8000a68:	4916      	ldr	r1, [pc, #88]	; (8000ac4 <XMC_DMA_EnableRequestLine+0x94>)
 8000a6a:	4b16      	ldr	r3, [pc, #88]	; (8000ac4 <XMC_DMA_EnableRequestLine+0x94>)
 8000a6c:	691a      	ldr	r2, [r3, #16]
 8000a6e:	78fb      	ldrb	r3, [r7, #3]
 8000a70:	f003 0307 	and.w	r3, r3, #7
 8000a74:	2001      	movs	r0, #1
 8000a76:	fa00 f303 	lsl.w	r3, r0, r3
 8000a7a:	4313      	orrs	r3, r2
 8000a7c:	610b      	str	r3, [r1, #16]
 8000a7e:	e019      	b.n	8000ab4 <XMC_DMA_EnableRequestLine+0x84>
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8000a80:	4810      	ldr	r0, [pc, #64]	; (8000ac4 <XMC_DMA_EnableRequestLine+0x94>)
 8000a82:	4b10      	ldr	r3, [pc, #64]	; (8000ac4 <XMC_DMA_EnableRequestLine+0x94>)
 8000a84:	68da      	ldr	r2, [r3, #12]
 8000a86:	78fb      	ldrb	r3, [r7, #3]
 8000a88:	009b      	lsls	r3, r3, #2
 8000a8a:	4619      	mov	r1, r3
 8000a8c:	230f      	movs	r3, #15
 8000a8e:	408b      	lsls	r3, r1
 8000a90:	43db      	mvns	r3, r3
 8000a92:	401a      	ands	r2, r3
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8000a94:	78bb      	ldrb	r3, [r7, #2]
 8000a96:	78f9      	ldrb	r1, [r7, #3]
 8000a98:	0089      	lsls	r1, r1, #2
 8000a9a:	408b      	lsls	r3, r1
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8000a9c:	4313      	orrs	r3, r2
 8000a9e:	60c3      	str	r3, [r0, #12]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x100UL << line);
 8000aa0:	4908      	ldr	r1, [pc, #32]	; (8000ac4 <XMC_DMA_EnableRequestLine+0x94>)
 8000aa2:	4b08      	ldr	r3, [pc, #32]	; (8000ac4 <XMC_DMA_EnableRequestLine+0x94>)
 8000aa4:	691a      	ldr	r2, [r3, #16]
 8000aa6:	78fb      	ldrb	r3, [r7, #3]
 8000aa8:	f44f 7080 	mov.w	r0, #256	; 0x100
 8000aac:	fa00 f303 	lsl.w	r3, r0, r3
 8000ab0:	4313      	orrs	r3, r2
 8000ab2:	610b      	str	r3, [r1, #16]
  }
#endif
}
 8000ab4:	370c      	adds	r7, #12
 8000ab6:	46bd      	mov	sp, r7
 8000ab8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000abc:	4770      	bx	lr
 8000abe:	bf00      	nop
 8000ac0:	50014000 	.word	0x50014000
 8000ac4:	50004900 	.word	0x50004900

08000ac8 <XMC_DMA_CH_IsEnabled>:
  }
}

/* Check if a DMA channel is enabled */
bool XMC_DMA_CH_IsEnabled(XMC_DMA_t *const dma, const uint8_t channel)
{
 8000ac8:	b480      	push	{r7}
 8000aca:	b083      	sub	sp, #12
 8000acc:	af00      	add	r7, sp, #0
 8000ace:	6078      	str	r0, [r7, #4]
 8000ad0:	460b      	mov	r3, r1
 8000ad2:	70fb      	strb	r3, [r7, #3]
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
 8000ad4:	687b      	ldr	r3, [r7, #4]
 8000ad6:	f8d3 23a0 	ldr.w	r2, [r3, #928]	; 0x3a0
 8000ada:	78fb      	ldrb	r3, [r7, #3]
 8000adc:	fa22 f303 	lsr.w	r3, r2, r3
 8000ae0:	f003 0301 	and.w	r3, r3, #1
 8000ae4:	2b00      	cmp	r3, #0
 8000ae6:	bf14      	ite	ne
 8000ae8:	2301      	movne	r3, #1
 8000aea:	2300      	moveq	r3, #0
 8000aec:	b2db      	uxtb	r3, r3
}
 8000aee:	4618      	mov	r0, r3
 8000af0:	370c      	adds	r7, #12
 8000af2:	46bd      	mov	sp, r7
 8000af4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000af8:	4770      	bx	lr
 8000afa:	bf00      	nop

08000afc <XMC_DMA_CH_Init>:

/* Initialize DMA channel */
XMC_DMA_CH_STATUS_t XMC_DMA_CH_Init(XMC_DMA_t *const dma, const uint8_t channel, const XMC_DMA_CH_CONFIG_t *const config)
{
 8000afc:	b580      	push	{r7, lr}
 8000afe:	b086      	sub	sp, #24
 8000b00:	af00      	add	r7, sp, #0
 8000b02:	60f8      	str	r0, [r7, #12]
 8000b04:	460b      	mov	r3, r1
 8000b06:	607a      	str	r2, [r7, #4]
 8000b08:	72fb      	strb	r3, [r7, #11]
  XMC_DMA_CH_STATUS_t status;
  uint8_t line;
  uint8_t peripheral;

  if (XMC_DMA_IsEnabled(dma) == true)
 8000b0a:	68f8      	ldr	r0, [r7, #12]
 8000b0c:	f7ff ff1e 	bl	800094c <XMC_DMA_IsEnabled>
 8000b10:	4603      	mov	r3, r0
 8000b12:	2b00      	cmp	r3, #0
 8000b14:	f000 81f1 	beq.w	8000efa <XMC_DMA_CH_Init+0x3fe>
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
 8000b18:	7afb      	ldrb	r3, [r7, #11]
 8000b1a:	68f8      	ldr	r0, [r7, #12]
 8000b1c:	4619      	mov	r1, r3
 8000b1e:	f7ff ffd3 	bl	8000ac8 <XMC_DMA_CH_IsEnabled>
 8000b22:	4603      	mov	r3, r0
 8000b24:	f083 0301 	eor.w	r3, r3, #1
 8000b28:	b2db      	uxtb	r3, r3
 8000b2a:	2b00      	cmp	r3, #0
 8000b2c:	f000 81e2 	beq.w	8000ef4 <XMC_DMA_CH_Init+0x3f8>
    {
      dma->CH[channel].SAR = config->src_addr;
 8000b30:	7afb      	ldrb	r3, [r7, #11]
 8000b32:	687a      	ldr	r2, [r7, #4]
 8000b34:	6852      	ldr	r2, [r2, #4]
 8000b36:	68f9      	ldr	r1, [r7, #12]
 8000b38:	2058      	movs	r0, #88	; 0x58
 8000b3a:	fb00 f303 	mul.w	r3, r0, r3
 8000b3e:	440b      	add	r3, r1
 8000b40:	601a      	str	r2, [r3, #0]
      dma->CH[channel].DAR = config->dst_addr;
 8000b42:	7afb      	ldrb	r3, [r7, #11]
 8000b44:	687a      	ldr	r2, [r7, #4]
 8000b46:	6892      	ldr	r2, [r2, #8]
 8000b48:	68f9      	ldr	r1, [r7, #12]
 8000b4a:	2058      	movs	r0, #88	; 0x58
 8000b4c:	fb00 f303 	mul.w	r3, r0, r3
 8000b50:	440b      	add	r3, r1
 8000b52:	3308      	adds	r3, #8
 8000b54:	601a      	str	r2, [r3, #0]
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
 8000b56:	7afb      	ldrb	r3, [r7, #11]
 8000b58:	687a      	ldr	r2, [r7, #4]
 8000b5a:	68d2      	ldr	r2, [r2, #12]
 8000b5c:	4610      	mov	r0, r2
 8000b5e:	68fa      	ldr	r2, [r7, #12]
 8000b60:	2158      	movs	r1, #88	; 0x58
 8000b62:	fb01 f303 	mul.w	r3, r1, r3
 8000b66:	4413      	add	r3, r2
 8000b68:	3310      	adds	r3, #16
 8000b6a:	6018      	str	r0, [r3, #0]
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
 8000b6c:	7afb      	ldrb	r3, [r7, #11]
 8000b6e:	687a      	ldr	r2, [r7, #4]
 8000b70:	8b12      	ldrh	r2, [r2, #24]
 8000b72:	4610      	mov	r0, r2
 8000b74:	68fa      	ldr	r2, [r7, #12]
 8000b76:	2158      	movs	r1, #88	; 0x58
 8000b78:	fb01 f303 	mul.w	r3, r1, r3
 8000b7c:	4413      	add	r3, r2
 8000b7e:	3318      	adds	r3, #24
 8000b80:	6058      	str	r0, [r3, #4]
      dma->CH[channel].CTLL = config->control;
 8000b82:	7afb      	ldrb	r3, [r7, #11]
 8000b84:	687a      	ldr	r2, [r7, #4]
 8000b86:	6812      	ldr	r2, [r2, #0]
 8000b88:	68f9      	ldr	r1, [r7, #12]
 8000b8a:	2058      	movs	r0, #88	; 0x58
 8000b8c:	fb00 f303 	mul.w	r3, r0, r3
 8000b90:	440b      	add	r3, r1
 8000b92:	3318      	adds	r3, #24
 8000b94:	601a      	str	r2, [r3, #0]

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 8000b96:	7afb      	ldrb	r3, [r7, #11]
 8000b98:	687a      	ldr	r2, [r7, #4]
 8000b9a:	7ed2      	ldrb	r2, [r2, #27]
 8000b9c:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
 8000ba0:	68f9      	ldr	r1, [r7, #12]
 8000ba2:	2058      	movs	r0, #88	; 0x58
 8000ba4:	fb00 f303 	mul.w	r3, r0, r3
 8000ba8:	440b      	add	r3, r1
 8000baa:	3340      	adds	r3, #64	; 0x40
 8000bac:	601a      	str	r2, [r3, #0]
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 8000bae:	68fb      	ldr	r3, [r7, #12]
 8000bb0:	4ab1      	ldr	r2, [pc, #708]	; (8000e78 <XMC_DMA_CH_Init+0x37c>)
 8000bb2:	4293      	cmp	r3, r2
 8000bb4:	d116      	bne.n	8000be4 <XMC_DMA_CH_Init+0xe8>
 8000bb6:	7afb      	ldrb	r3, [r7, #11]
 8000bb8:	2b01      	cmp	r3, #1
 8000bba:	d813      	bhi.n	8000be4 <XMC_DMA_CH_Init+0xe8>
      {
        /* Configure scatter and gather */
        dma->CH[channel].SGR = config->src_gather_control;
 8000bbc:	7afb      	ldrb	r3, [r7, #11]
 8000bbe:	687a      	ldr	r2, [r7, #4]
 8000bc0:	6912      	ldr	r2, [r2, #16]
 8000bc2:	68f9      	ldr	r1, [r7, #12]
 8000bc4:	2058      	movs	r0, #88	; 0x58
 8000bc6:	fb00 f303 	mul.w	r3, r0, r3
 8000bca:	440b      	add	r3, r1
 8000bcc:	3348      	adds	r3, #72	; 0x48
 8000bce:	601a      	str	r2, [r3, #0]
        dma->CH[channel].DSR = config->dst_scatter_control;
 8000bd0:	7afb      	ldrb	r3, [r7, #11]
 8000bd2:	687a      	ldr	r2, [r7, #4]
 8000bd4:	6952      	ldr	r2, [r2, #20]
 8000bd6:	68f9      	ldr	r1, [r7, #12]
 8000bd8:	2058      	movs	r0, #88	; 0x58
 8000bda:	fb00 f303 	mul.w	r3, r0, r3
 8000bde:	440b      	add	r3, r1
 8000be0:	3350      	adds	r3, #80	; 0x50
 8000be2:	601a      	str	r2, [r3, #0]
      }

      if (config->dst_handshaking == XMC_DMA_CH_DST_HANDSHAKING_HARDWARE)
 8000be4:	687b      	ldr	r3, [r7, #4]
 8000be6:	8c1b      	ldrh	r3, [r3, #32]
 8000be8:	2b00      	cmp	r3, #0
 8000bea:	d14f      	bne.n	8000c8c <XMC_DMA_CH_Init+0x190>
      {
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
 8000bec:	687b      	ldr	r3, [r7, #4]
 8000bee:	789b      	ldrb	r3, [r3, #2]
 8000bf0:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8000bf4:	b2db      	uxtb	r3, r3
 8000bf6:	2b10      	cmp	r3, #16
 8000bf8:	d006      	beq.n	8000c08 <XMC_DMA_CH_Init+0x10c>
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
 8000bfa:	687b      	ldr	r3, [r7, #4]
 8000bfc:	789b      	ldrb	r3, [r3, #2]
 8000bfe:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8000c02:	b2db      	uxtb	r3, r3
      }

      if (config->dst_handshaking == XMC_DMA_CH_DST_HANDSHAKING_HARDWARE)
      {
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
 8000c04:	2b30      	cmp	r3, #48	; 0x30
 8000c06:	d141      	bne.n	8000c8c <XMC_DMA_CH_Init+0x190>
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8000c08:	68fb      	ldr	r3, [r7, #12]
 8000c0a:	4a9b      	ldr	r2, [pc, #620]	; (8000e78 <XMC_DMA_CH_Init+0x37c>)
 8000c0c:	4293      	cmp	r3, r2
 8000c0e:	d106      	bne.n	8000c1e <XMC_DMA_CH_Init+0x122>
          {
#endif
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8000c10:	687b      	ldr	r3, [r7, #4]
 8000c12:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8000c16:	f003 0307 	and.w	r3, r3, #7
 8000c1a:	75bb      	strb	r3, [r7, #22]
 8000c1c:	e005      	b.n	8000c2a <XMC_DMA_CH_Init+0x12e>
#if defined(GPDMA1)
          }
          else
          {
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
 8000c1e:	687b      	ldr	r3, [r7, #4]
 8000c20:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8000c24:	f003 0303 	and.w	r3, r3, #3
 8000c28:	75bb      	strb	r3, [r7, #22]
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;
 8000c2a:	687b      	ldr	r3, [r7, #4]
 8000c2c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8000c30:	091b      	lsrs	r3, r3, #4
 8000c32:	757b      	strb	r3, [r7, #21]

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8000c34:	7afb      	ldrb	r3, [r7, #11]
 8000c36:	7afa      	ldrb	r2, [r7, #11]
 8000c38:	68f9      	ldr	r1, [r7, #12]
 8000c3a:	2058      	movs	r0, #88	; 0x58
 8000c3c:	fb00 f202 	mul.w	r2, r0, r2
 8000c40:	440a      	add	r2, r1
 8000c42:	3240      	adds	r2, #64	; 0x40
 8000c44:	6851      	ldr	r1, [r2, #4]
 8000c46:	7dba      	ldrb	r2, [r7, #22]
 8000c48:	02d2      	lsls	r2, r2, #11
 8000c4a:	430a      	orrs	r2, r1
 8000c4c:	68f9      	ldr	r1, [r7, #12]
 8000c4e:	2058      	movs	r0, #88	; 0x58
 8000c50:	fb00 f303 	mul.w	r3, r0, r3
 8000c54:	440b      	add	r3, r1
 8000c56:	3340      	adds	r3, #64	; 0x40
 8000c58:	605a      	str	r2, [r3, #4]
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
 8000c5a:	7dba      	ldrb	r2, [r7, #22]
 8000c5c:	7d7b      	ldrb	r3, [r7, #21]
 8000c5e:	68f8      	ldr	r0, [r7, #12]
 8000c60:	4611      	mov	r1, r2
 8000c62:	461a      	mov	r2, r3
 8000c64:	f7ff fee4 	bl	8000a30 <XMC_DMA_EnableRequestLine>
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_DST_Msk;
 8000c68:	7afb      	ldrb	r3, [r7, #11]
 8000c6a:	7afa      	ldrb	r2, [r7, #11]
 8000c6c:	68f9      	ldr	r1, [r7, #12]
 8000c6e:	2058      	movs	r0, #88	; 0x58
 8000c70:	fb00 f202 	mul.w	r2, r0, r2
 8000c74:	440a      	add	r2, r1
 8000c76:	3240      	adds	r2, #64	; 0x40
 8000c78:	6812      	ldr	r2, [r2, #0]
 8000c7a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000c7e:	68f9      	ldr	r1, [r7, #12]
 8000c80:	2058      	movs	r0, #88	; 0x58
 8000c82:	fb00 f303 	mul.w	r3, r0, r3
 8000c86:	440b      	add	r3, r1
 8000c88:	3340      	adds	r3, #64	; 0x40
 8000c8a:	601a      	str	r2, [r3, #0]
        }
      }


      if (config->src_handshaking == XMC_DMA_CH_SRC_HANDSHAKING_HARDWARE)
 8000c8c:	687b      	ldr	r3, [r7, #4]
 8000c8e:	8b9b      	ldrh	r3, [r3, #28]
 8000c90:	2b00      	cmp	r3, #0
 8000c92:	d14c      	bne.n	8000d2e <XMC_DMA_CH_Init+0x232>
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
 8000c94:	687b      	ldr	r3, [r7, #4]
 8000c96:	789b      	ldrb	r3, [r3, #2]
 8000c98:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8000c9c:	b2db      	uxtb	r3, r3
 8000c9e:	2b20      	cmp	r3, #32
 8000ca0:	d006      	beq.n	8000cb0 <XMC_DMA_CH_Init+0x1b4>
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
 8000ca2:	687b      	ldr	r3, [r7, #4]
 8000ca4:	789b      	ldrb	r3, [r3, #2]
 8000ca6:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8000caa:	b2db      	uxtb	r3, r3
      }


      if (config->src_handshaking == XMC_DMA_CH_SRC_HANDSHAKING_HARDWARE)
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
 8000cac:	2b30      	cmp	r3, #48	; 0x30
 8000cae:	d13e      	bne.n	8000d2e <XMC_DMA_CH_Init+0x232>
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8000cb0:	68fb      	ldr	r3, [r7, #12]
 8000cb2:	4a71      	ldr	r2, [pc, #452]	; (8000e78 <XMC_DMA_CH_Init+0x37c>)
 8000cb4:	4293      	cmp	r3, r2
 8000cb6:	d105      	bne.n	8000cc4 <XMC_DMA_CH_Init+0x1c8>
          {
#endif
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8000cb8:	687b      	ldr	r3, [r7, #4]
 8000cba:	7f9b      	ldrb	r3, [r3, #30]
 8000cbc:	f003 0307 	and.w	r3, r3, #7
 8000cc0:	75bb      	strb	r3, [r7, #22]
 8000cc2:	e004      	b.n	8000cce <XMC_DMA_CH_Init+0x1d2>
#if defined(GPDMA1)
          }
          else
          {
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
 8000cc4:	687b      	ldr	r3, [r7, #4]
 8000cc6:	7f9b      	ldrb	r3, [r3, #30]
 8000cc8:	f003 0303 	and.w	r3, r3, #3
 8000ccc:	75bb      	strb	r3, [r7, #22]
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;
 8000cce:	687b      	ldr	r3, [r7, #4]
 8000cd0:	7f9b      	ldrb	r3, [r3, #30]
 8000cd2:	091b      	lsrs	r3, r3, #4
 8000cd4:	757b      	strb	r3, [r7, #21]

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8000cd6:	7afb      	ldrb	r3, [r7, #11]
 8000cd8:	7afa      	ldrb	r2, [r7, #11]
 8000cda:	68f9      	ldr	r1, [r7, #12]
 8000cdc:	2058      	movs	r0, #88	; 0x58
 8000cde:	fb00 f202 	mul.w	r2, r0, r2
 8000ce2:	440a      	add	r2, r1
 8000ce4:	3240      	adds	r2, #64	; 0x40
 8000ce6:	6851      	ldr	r1, [r2, #4]
 8000ce8:	7dba      	ldrb	r2, [r7, #22]
 8000cea:	01d2      	lsls	r2, r2, #7
 8000cec:	430a      	orrs	r2, r1
 8000cee:	68f9      	ldr	r1, [r7, #12]
 8000cf0:	2058      	movs	r0, #88	; 0x58
 8000cf2:	fb00 f303 	mul.w	r3, r0, r3
 8000cf6:	440b      	add	r3, r1
 8000cf8:	3340      	adds	r3, #64	; 0x40
 8000cfa:	605a      	str	r2, [r3, #4]
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
 8000cfc:	7dba      	ldrb	r2, [r7, #22]
 8000cfe:	7d7b      	ldrb	r3, [r7, #21]
 8000d00:	68f8      	ldr	r0, [r7, #12]
 8000d02:	4611      	mov	r1, r2
 8000d04:	461a      	mov	r2, r3
 8000d06:	f7ff fe93 	bl	8000a30 <XMC_DMA_EnableRequestLine>
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_SRC_Msk;
 8000d0a:	7afb      	ldrb	r3, [r7, #11]
 8000d0c:	7afa      	ldrb	r2, [r7, #11]
 8000d0e:	68f9      	ldr	r1, [r7, #12]
 8000d10:	2058      	movs	r0, #88	; 0x58
 8000d12:	fb00 f202 	mul.w	r2, r0, r2
 8000d16:	440a      	add	r2, r1
 8000d18:	3240      	adds	r2, #64	; 0x40
 8000d1a:	6812      	ldr	r2, [r2, #0]
 8000d1c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8000d20:	68f9      	ldr	r1, [r7, #12]
 8000d22:	2058      	movs	r0, #88	; 0x58
 8000d24:	fb00 f303 	mul.w	r3, r0, r3
 8000d28:	440b      	add	r3, r1
 8000d2a:	3340      	adds	r3, #64	; 0x40
 8000d2c:	601a      	str	r2, [r3, #0]
        }
      }

      XMC_DMA_CH_ClearEventStatus(dma, channel, (uint32_t)((uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE |
 8000d2e:	7afb      	ldrb	r3, [r7, #11]
 8000d30:	68f8      	ldr	r0, [r7, #12]
 8000d32:	4619      	mov	r1, r3
 8000d34:	221f      	movs	r2, #31
 8000d36:	f000 f90f 	bl	8000f58 <XMC_DMA_CH_ClearEventStatus>
                                  (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                  (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                  (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                  (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 8000d3a:	687b      	ldr	r3, [r7, #4]
 8000d3c:	7e9b      	ldrb	r3, [r3, #26]
 8000d3e:	2b08      	cmp	r3, #8
 8000d40:	f200 80d4 	bhi.w	8000eec <XMC_DMA_CH_Init+0x3f0>
 8000d44:	a201      	add	r2, pc, #4	; (adr r2, 8000d4c <XMC_DMA_CH_Init+0x250>)
 8000d46:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000d4a:	bf00      	nop
 8000d4c:	08000eed 	.word	0x08000eed
 8000d50:	08000d71 	.word	0x08000d71
 8000d54:	08000d97 	.word	0x08000d97
 8000d58:	08000dbd 	.word	0x08000dbd
 8000d5c:	08000de3 	.word	0x08000de3
 8000d60:	08000e09 	.word	0x08000e09
 8000d64:	08000e53 	.word	0x08000e53
 8000d68:	08000e7d 	.word	0x08000e7d
 8000d6c:	08000ec7 	.word	0x08000ec7
      {
        case XMC_DMA_CH_TRANSFER_TYPE_SINGLE_BLOCK:
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8000d70:	7afb      	ldrb	r3, [r7, #11]
 8000d72:	7afa      	ldrb	r2, [r7, #11]
 8000d74:	68f9      	ldr	r1, [r7, #12]
 8000d76:	2058      	movs	r0, #88	; 0x58
 8000d78:	fb00 f202 	mul.w	r2, r0, r2
 8000d7c:	440a      	add	r2, r1
 8000d7e:	3240      	adds	r2, #64	; 0x40
 8000d80:	6812      	ldr	r2, [r2, #0]
 8000d82:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8000d86:	68f9      	ldr	r1, [r7, #12]
 8000d88:	2058      	movs	r0, #88	; 0x58
 8000d8a:	fb00 f303 	mul.w	r3, r0, r3
 8000d8e:	440b      	add	r3, r1
 8000d90:	3340      	adds	r3, #64	; 0x40
 8000d92:	601a      	str	r2, [r3, #0]
          break;
 8000d94:	e0ab      	b.n	8000eee <XMC_DMA_CH_Init+0x3f2>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8000d96:	7afb      	ldrb	r3, [r7, #11]
 8000d98:	7afa      	ldrb	r2, [r7, #11]
 8000d9a:	68f9      	ldr	r1, [r7, #12]
 8000d9c:	2058      	movs	r0, #88	; 0x58
 8000d9e:	fb00 f202 	mul.w	r2, r0, r2
 8000da2:	440a      	add	r2, r1
 8000da4:	3240      	adds	r2, #64	; 0x40
 8000da6:	6812      	ldr	r2, [r2, #0]
 8000da8:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8000dac:	68f9      	ldr	r1, [r7, #12]
 8000dae:	2058      	movs	r0, #88	; 0x58
 8000db0:	fb00 f303 	mul.w	r3, r0, r3
 8000db4:	440b      	add	r3, r1
 8000db6:	3340      	adds	r3, #64	; 0x40
 8000db8:	601a      	str	r2, [r3, #0]
          break;
 8000dba:	e098      	b.n	8000eee <XMC_DMA_CH_Init+0x3f2>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
 8000dbc:	7afb      	ldrb	r3, [r7, #11]
 8000dbe:	7afa      	ldrb	r2, [r7, #11]
 8000dc0:	68f9      	ldr	r1, [r7, #12]
 8000dc2:	2058      	movs	r0, #88	; 0x58
 8000dc4:	fb00 f202 	mul.w	r2, r0, r2
 8000dc8:	440a      	add	r2, r1
 8000dca:	3240      	adds	r2, #64	; 0x40
 8000dcc:	6812      	ldr	r2, [r2, #0]
 8000dce:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
 8000dd2:	68f9      	ldr	r1, [r7, #12]
 8000dd4:	2058      	movs	r0, #88	; 0x58
 8000dd6:	fb00 f303 	mul.w	r3, r0, r3
 8000dda:	440b      	add	r3, r1
 8000ddc:	3340      	adds	r3, #64	; 0x40
 8000dde:	601a      	str	r2, [r3, #0]
                                              (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk);
          break;
 8000de0:	e085      	b.n	8000eee <XMC_DMA_CH_Init+0x3f2>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8000de2:	7afb      	ldrb	r3, [r7, #11]
 8000de4:	7afa      	ldrb	r2, [r7, #11]
 8000de6:	68f9      	ldr	r1, [r7, #12]
 8000de8:	2058      	movs	r0, #88	; 0x58
 8000dea:	fb00 f202 	mul.w	r2, r0, r2
 8000dee:	440a      	add	r2, r1
 8000df0:	3218      	adds	r2, #24
 8000df2:	6812      	ldr	r2, [r2, #0]
 8000df4:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8000df8:	68f9      	ldr	r1, [r7, #12]
 8000dfa:	2058      	movs	r0, #88	; 0x58
 8000dfc:	fb00 f303 	mul.w	r3, r0, r3
 8000e00:	440b      	add	r3, r1
 8000e02:	3318      	adds	r3, #24
 8000e04:	601a      	str	r2, [r3, #0]
          break;
 8000e06:	e072      	b.n	8000eee <XMC_DMA_CH_Init+0x3f2>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_LINKED:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8000e08:	7afb      	ldrb	r3, [r7, #11]
 8000e0a:	7afa      	ldrb	r2, [r7, #11]
 8000e0c:	68f9      	ldr	r1, [r7, #12]
 8000e0e:	2058      	movs	r0, #88	; 0x58
 8000e10:	fb00 f202 	mul.w	r2, r0, r2
 8000e14:	440a      	add	r2, r1
 8000e16:	3240      	adds	r2, #64	; 0x40
 8000e18:	6812      	ldr	r2, [r2, #0]
 8000e1a:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8000e1e:	68f9      	ldr	r1, [r7, #12]
 8000e20:	2058      	movs	r0, #88	; 0x58
 8000e22:	fb00 f303 	mul.w	r3, r0, r3
 8000e26:	440b      	add	r3, r1
 8000e28:	3340      	adds	r3, #64	; 0x40
 8000e2a:	601a      	str	r2, [r3, #0]
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8000e2c:	7afb      	ldrb	r3, [r7, #11]
 8000e2e:	7afa      	ldrb	r2, [r7, #11]
 8000e30:	68f9      	ldr	r1, [r7, #12]
 8000e32:	2058      	movs	r0, #88	; 0x58
 8000e34:	fb00 f202 	mul.w	r2, r0, r2
 8000e38:	440a      	add	r2, r1
 8000e3a:	3218      	adds	r2, #24
 8000e3c:	6812      	ldr	r2, [r2, #0]
 8000e3e:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8000e42:	68f9      	ldr	r1, [r7, #12]
 8000e44:	2058      	movs	r0, #88	; 0x58
 8000e46:	fb00 f303 	mul.w	r3, r0, r3
 8000e4a:	440b      	add	r3, r1
 8000e4c:	3318      	adds	r3, #24
 8000e4e:	601a      	str	r2, [r3, #0]
          break;
 8000e50:	e04d      	b.n	8000eee <XMC_DMA_CH_Init+0x3f2>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8000e52:	7afb      	ldrb	r3, [r7, #11]
 8000e54:	7afa      	ldrb	r2, [r7, #11]
 8000e56:	68f9      	ldr	r1, [r7, #12]
 8000e58:	2058      	movs	r0, #88	; 0x58
 8000e5a:	fb00 f202 	mul.w	r2, r0, r2
 8000e5e:	440a      	add	r2, r1
 8000e60:	3218      	adds	r2, #24
 8000e62:	6812      	ldr	r2, [r2, #0]
 8000e64:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000e68:	68f9      	ldr	r1, [r7, #12]
 8000e6a:	2058      	movs	r0, #88	; 0x58
 8000e6c:	fb00 f303 	mul.w	r3, r0, r3
 8000e70:	440b      	add	r3, r1
 8000e72:	3318      	adds	r3, #24
 8000e74:	601a      	str	r2, [r3, #0]
          break;
 8000e76:	e03a      	b.n	8000eee <XMC_DMA_CH_Init+0x3f2>
 8000e78:	50014000 	.word	0x50014000

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8000e7c:	7afb      	ldrb	r3, [r7, #11]
 8000e7e:	7afa      	ldrb	r2, [r7, #11]
 8000e80:	68f9      	ldr	r1, [r7, #12]
 8000e82:	2058      	movs	r0, #88	; 0x58
 8000e84:	fb00 f202 	mul.w	r2, r0, r2
 8000e88:	440a      	add	r2, r1
 8000e8a:	3240      	adds	r2, #64	; 0x40
 8000e8c:	6812      	ldr	r2, [r2, #0]
 8000e8e:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8000e92:	68f9      	ldr	r1, [r7, #12]
 8000e94:	2058      	movs	r0, #88	; 0x58
 8000e96:	fb00 f303 	mul.w	r3, r0, r3
 8000e9a:	440b      	add	r3, r1
 8000e9c:	3340      	adds	r3, #64	; 0x40
 8000e9e:	601a      	str	r2, [r3, #0]
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8000ea0:	7afb      	ldrb	r3, [r7, #11]
 8000ea2:	7afa      	ldrb	r2, [r7, #11]
 8000ea4:	68f9      	ldr	r1, [r7, #12]
 8000ea6:	2058      	movs	r0, #88	; 0x58
 8000ea8:	fb00 f202 	mul.w	r2, r0, r2
 8000eac:	440a      	add	r2, r1
 8000eae:	3218      	adds	r2, #24
 8000eb0:	6812      	ldr	r2, [r2, #0]
 8000eb2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000eb6:	68f9      	ldr	r1, [r7, #12]
 8000eb8:	2058      	movs	r0, #88	; 0x58
 8000eba:	fb00 f303 	mul.w	r3, r0, r3
 8000ebe:	440b      	add	r3, r1
 8000ec0:	3318      	adds	r3, #24
 8000ec2:	601a      	str	r2, [r3, #0]
          break;
 8000ec4:	e013      	b.n	8000eee <XMC_DMA_CH_Init+0x3f2>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)((uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk |
 8000ec6:	7afb      	ldrb	r3, [r7, #11]
 8000ec8:	7afa      	ldrb	r2, [r7, #11]
 8000eca:	68f9      	ldr	r1, [r7, #12]
 8000ecc:	2058      	movs	r0, #88	; 0x58
 8000ece:	fb00 f202 	mul.w	r2, r0, r2
 8000ed2:	440a      	add	r2, r1
 8000ed4:	3218      	adds	r2, #24
 8000ed6:	6812      	ldr	r2, [r2, #0]
 8000ed8:	f042 52c0 	orr.w	r2, r2, #402653184	; 0x18000000
 8000edc:	68f9      	ldr	r1, [r7, #12]
 8000ede:	2058      	movs	r0, #88	; 0x58
 8000ee0:	fb00 f303 	mul.w	r3, r0, r3
 8000ee4:	440b      	add	r3, r1
 8000ee6:	3318      	adds	r3, #24
 8000ee8:	601a      	str	r2, [r3, #0]
                                              (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk);
          break;
 8000eea:	e000      	b.n	8000eee <XMC_DMA_CH_Init+0x3f2>

        default:
          break;
 8000eec:	bf00      	nop
      }

      status = XMC_DMA_CH_STATUS_OK;
 8000eee:	2300      	movs	r3, #0
 8000ef0:	75fb      	strb	r3, [r7, #23]
 8000ef2:	e004      	b.n	8000efe <XMC_DMA_CH_Init+0x402>

    }
    else
    {
      status = XMC_DMA_CH_STATUS_BUSY;
 8000ef4:	2302      	movs	r3, #2
 8000ef6:	75fb      	strb	r3, [r7, #23]
 8000ef8:	e001      	b.n	8000efe <XMC_DMA_CH_Init+0x402>
    }
  }
  else
  {
    status = XMC_DMA_CH_STATUS_ERROR;
 8000efa:	2301      	movs	r3, #1
 8000efc:	75fb      	strb	r3, [r7, #23]
  }

  return status;
 8000efe:	7dfb      	ldrb	r3, [r7, #23]
}
 8000f00:	4618      	mov	r0, r3
 8000f02:	3718      	adds	r7, #24
 8000f04:	46bd      	mov	sp, r7
 8000f06:	bd80      	pop	{r7, pc}

08000f08 <XMC_DMA_CH_EnableEvent>:
  return (bool)(dma->CH[channel].CFGL & (uint32_t)GPDMA0_CH_CFGL_CH_SUSP_Msk);
}

/* Enable GPDMA event */
void XMC_DMA_CH_EnableEvent(XMC_DMA_t *const dma, const uint8_t channel, const uint32_t event)
{
 8000f08:	b480      	push	{r7}
 8000f0a:	b087      	sub	sp, #28
 8000f0c:	af00      	add	r7, sp, #0
 8000f0e:	60f8      	str	r0, [r7, #12]
 8000f10:	460b      	mov	r3, r1
 8000f12:	607a      	str	r2, [r7, #4]
 8000f14:	72fb      	strb	r3, [r7, #11]
  uint32_t event_idx;

  for (event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
 8000f16:	2300      	movs	r3, #0
 8000f18:	617b      	str	r3, [r7, #20]
 8000f1a:	e014      	b.n	8000f46 <XMC_DMA_CH_EnableEvent+0x3e>
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8000f1c:	697b      	ldr	r3, [r7, #20]
 8000f1e:	687a      	ldr	r2, [r7, #4]
 8000f20:	fa22 f303 	lsr.w	r3, r2, r3
 8000f24:	f003 0301 	and.w	r3, r3, #1
 8000f28:	2b00      	cmp	r3, #0
 8000f2a:	d009      	beq.n	8000f40 <XMC_DMA_CH_EnableEvent+0x38>
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8000f2c:	697b      	ldr	r3, [r7, #20]
 8000f2e:	005a      	lsls	r2, r3, #1
 8000f30:	7afb      	ldrb	r3, [r7, #11]
 8000f32:	f240 1101 	movw	r1, #257	; 0x101
 8000f36:	4099      	lsls	r1, r3
 8000f38:	68fb      	ldr	r3, [r7, #12]
 8000f3a:	32c4      	adds	r2, #196	; 0xc4
 8000f3c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
/* Enable GPDMA event */
void XMC_DMA_CH_EnableEvent(XMC_DMA_t *const dma, const uint8_t channel, const uint32_t event)
{
  uint32_t event_idx;

  for (event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
 8000f40:	697b      	ldr	r3, [r7, #20]
 8000f42:	3301      	adds	r3, #1
 8000f44:	617b      	str	r3, [r7, #20]
 8000f46:	697b      	ldr	r3, [r7, #20]
 8000f48:	2b04      	cmp	r3, #4
 8000f4a:	d9e7      	bls.n	8000f1c <XMC_DMA_CH_EnableEvent+0x14>
    if (event & ((uint32_t)0x1UL << event_idx))
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
    }
  }
}
 8000f4c:	371c      	adds	r7, #28
 8000f4e:	46bd      	mov	sp, r7
 8000f50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f54:	4770      	bx	lr
 8000f56:	bf00      	nop

08000f58 <XMC_DMA_CH_ClearEventStatus>:
  }
}

/* Clear GPDMA event */
void XMC_DMA_CH_ClearEventStatus(XMC_DMA_t *const dma, const uint8_t channel, const uint32_t event)
{
 8000f58:	b480      	push	{r7}
 8000f5a:	b087      	sub	sp, #28
 8000f5c:	af00      	add	r7, sp, #0
 8000f5e:	60f8      	str	r0, [r7, #12]
 8000f60:	460b      	mov	r3, r1
 8000f62:	607a      	str	r2, [r7, #4]
 8000f64:	72fb      	strb	r3, [r7, #11]
  uint32_t event_idx;

  for (event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
 8000f66:	2300      	movs	r3, #0
 8000f68:	617b      	str	r3, [r7, #20]
 8000f6a:	e013      	b.n	8000f94 <XMC_DMA_CH_ClearEventStatus+0x3c>
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
 8000f6c:	697b      	ldr	r3, [r7, #20]
 8000f6e:	687a      	ldr	r2, [r7, #4]
 8000f70:	fa22 f303 	lsr.w	r3, r2, r3
 8000f74:	f003 0301 	and.w	r3, r3, #1
 8000f78:	2b00      	cmp	r3, #0
 8000f7a:	d008      	beq.n	8000f8e <XMC_DMA_CH_ClearEventStatus+0x36>
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8000f7c:	697b      	ldr	r3, [r7, #20]
 8000f7e:	005a      	lsls	r2, r3, #1
 8000f80:	7afb      	ldrb	r3, [r7, #11]
 8000f82:	2101      	movs	r1, #1
 8000f84:	4099      	lsls	r1, r3
 8000f86:	68fb      	ldr	r3, [r7, #12]
 8000f88:	32ce      	adds	r2, #206	; 0xce
 8000f8a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
/* Clear GPDMA event */
void XMC_DMA_CH_ClearEventStatus(XMC_DMA_t *const dma, const uint8_t channel, const uint32_t event)
{
  uint32_t event_idx;

  for (event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
 8000f8e:	697b      	ldr	r3, [r7, #20]
 8000f90:	3301      	adds	r3, #1
 8000f92:	617b      	str	r3, [r7, #20]
 8000f94:	697b      	ldr	r3, [r7, #20]
 8000f96:	2b04      	cmp	r3, #4
 8000f98:	d9e8      	bls.n	8000f6c <XMC_DMA_CH_ClearEventStatus+0x14>
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
    }
  }

}
 8000f9a:	371c      	adds	r7, #28
 8000f9c:	46bd      	mov	sp, r7
 8000f9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000fa2:	4770      	bx	lr

08000fa4 <XMC_DMA_CH_SetEventHandler>:
  dma->CH[channel].CTLL &= (uint32_t)~(GPDMA0_CH_CTLL_LLP_SRC_EN_Msk | GPDMA0_CH_CTLL_LLP_DST_EN_Msk);
}

/* Set event handler */
void XMC_DMA_CH_SetEventHandler(XMC_DMA_t *const dma, const uint8_t channel, XMC_DMA_CH_EVENT_HANDLER_t event_handler)
{
 8000fa4:	b480      	push	{r7}
 8000fa6:	b085      	sub	sp, #20
 8000fa8:	af00      	add	r7, sp, #0
 8000faa:	60f8      	str	r0, [r7, #12]
 8000fac:	460b      	mov	r3, r1
 8000fae:	607a      	str	r2, [r7, #4]
 8000fb0:	72fb      	strb	r3, [r7, #11]
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8000fb2:	68fb      	ldr	r3, [r7, #12]
 8000fb4:	4a09      	ldr	r2, [pc, #36]	; (8000fdc <XMC_DMA_CH_SetEventHandler+0x38>)
 8000fb6:	4293      	cmp	r3, r2
 8000fb8:	d105      	bne.n	8000fc6 <XMC_DMA_CH_SetEventHandler+0x22>
  {
#else
  XMC_UNUSED_ARG(dma);
#endif
    dma0_event_handlers[channel] = event_handler;
 8000fba:	7afb      	ldrb	r3, [r7, #11]
 8000fbc:	4908      	ldr	r1, [pc, #32]	; (8000fe0 <XMC_DMA_CH_SetEventHandler+0x3c>)
 8000fbe:	687a      	ldr	r2, [r7, #4]
 8000fc0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8000fc4:	e004      	b.n	8000fd0 <XMC_DMA_CH_SetEventHandler+0x2c>
#if defined(GPDMA1)
  }
  else
  {
    dma1_event_handlers[channel] = event_handler;
 8000fc6:	7afb      	ldrb	r3, [r7, #11]
 8000fc8:	4906      	ldr	r1, [pc, #24]	; (8000fe4 <XMC_DMA_CH_SetEventHandler+0x40>)
 8000fca:	687a      	ldr	r2, [r7, #4]
 8000fcc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
#endif
}
 8000fd0:	3714      	adds	r7, #20
 8000fd2:	46bd      	mov	sp, r7
 8000fd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000fd8:	4770      	bx	lr
 8000fda:	bf00      	nop
 8000fdc:	50014000 	.word	0x50014000
 8000fe0:	1ffe8854 	.word	0x1ffe8854
 8000fe4:	1ffe8874 	.word	0x1ffe8874

08000fe8 <XMC_DMA_IRQHandler>:
  XMC_DMA_ClearRequestLine(dma, (uint8_t)line);
}

/* Default DMA IRQ handler */
void XMC_DMA_IRQHandler(XMC_DMA_t *const dma)
{
 8000fe8:	b580      	push	{r7, lr}
 8000fea:	b088      	sub	sp, #32
 8000fec:	af00      	add	r7, sp, #0
 8000fee:	6078      	str	r0, [r7, #4]
  uint32_t mask;
  XMC_DMA_CH_EVENT_HANDLER_t *dma_event_handlers;
  XMC_DMA_CH_EVENT_HANDLER_t event_handler;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8000ff0:	687b      	ldr	r3, [r7, #4]
 8000ff2:	4a82      	ldr	r2, [pc, #520]	; (80011fc <XMC_DMA_IRQHandler+0x214>)
 8000ff4:	4293      	cmp	r3, r2
 8000ff6:	d102      	bne.n	8000ffe <XMC_DMA_IRQHandler+0x16>
  {
#endif
    dma_event_handlers = dma0_event_handlers;
 8000ff8:	4b81      	ldr	r3, [pc, #516]	; (8001200 <XMC_DMA_IRQHandler+0x218>)
 8000ffa:	61bb      	str	r3, [r7, #24]
 8000ffc:	e001      	b.n	8001002 <XMC_DMA_IRQHandler+0x1a>
#if defined(GPDMA1)
  }
  else
  {
    dma_event_handlers = dma1_event_handlers;
 8000ffe:	4b81      	ldr	r3, [pc, #516]	; (8001204 <XMC_DMA_IRQHandler+0x21c>)
 8001000:	61bb      	str	r3, [r7, #24]
  }
#endif

  event = XMC_DMA_GetEventStatus(dma);
 8001002:	6878      	ldr	r0, [r7, #4]
 8001004:	f7ff fc22 	bl	800084c <XMC_DMA_GetEventStatus>
 8001008:	6178      	str	r0, [r7, #20]
  channel = 0;
 800100a:	2300      	movs	r3, #0
 800100c:	61fb      	str	r3, [r7, #28]

  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
 800100e:	697b      	ldr	r3, [r7, #20]
 8001010:	f003 0310 	and.w	r3, r3, #16
 8001014:	2b00      	cmp	r3, #0
 8001016:	d02b      	beq.n	8001070 <XMC_DMA_IRQHandler+0x88>
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
 8001018:	6878      	ldr	r0, [r7, #4]
 800101a:	f7ff fc5d 	bl	80008d8 <XMC_DMA_GetChannelsErrorStatus>
 800101e:	6178      	str	r0, [r7, #20]
    while (event != 0)
 8001020:	e021      	b.n	8001066 <XMC_DMA_IRQHandler+0x7e>
    {
      mask = (uint32_t)1U << channel;
 8001022:	2201      	movs	r2, #1
 8001024:	69fb      	ldr	r3, [r7, #28]
 8001026:	fa02 f303 	lsl.w	r3, r2, r3
 800102a:	613b      	str	r3, [r7, #16]
      if ((event & mask) != 0)
 800102c:	697a      	ldr	r2, [r7, #20]
 800102e:	693b      	ldr	r3, [r7, #16]
 8001030:	4013      	ands	r3, r2
 8001032:	2b00      	cmp	r3, #0
 8001034:	d014      	beq.n	8001060 <XMC_DMA_IRQHandler+0x78>
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_ERROR);
 8001036:	69fb      	ldr	r3, [r7, #28]
 8001038:	b2db      	uxtb	r3, r3
 800103a:	6878      	ldr	r0, [r7, #4]
 800103c:	4619      	mov	r1, r3
 800103e:	2210      	movs	r2, #16
 8001040:	f7ff ff8a 	bl	8000f58 <XMC_DMA_CH_ClearEventStatus>

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8001044:	69fb      	ldr	r3, [r7, #28]
 8001046:	009b      	lsls	r3, r3, #2
 8001048:	69ba      	ldr	r2, [r7, #24]
 800104a:	4413      	add	r3, r2
 800104c:	681b      	ldr	r3, [r3, #0]
 800104e:	60fb      	str	r3, [r7, #12]
        if (event_handler != NULL)
 8001050:	68fb      	ldr	r3, [r7, #12]
 8001052:	2b00      	cmp	r3, #0
 8001054:	d003      	beq.n	800105e <XMC_DMA_IRQHandler+0x76>
        {
          event_handler(XMC_DMA_CH_EVENT_ERROR);
 8001056:	68fb      	ldr	r3, [r7, #12]
 8001058:	2010      	movs	r0, #16
 800105a:	4798      	blx	r3
        }

        break;
 800105c:	e007      	b.n	800106e <XMC_DMA_IRQHandler+0x86>
 800105e:	e006      	b.n	800106e <XMC_DMA_IRQHandler+0x86>
      }
      ++channel;
 8001060:	69fb      	ldr	r3, [r7, #28]
 8001062:	3301      	adds	r3, #1
 8001064:	61fb      	str	r3, [r7, #28]
  channel = 0;

  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
 8001066:	697b      	ldr	r3, [r7, #20]
 8001068:	2b00      	cmp	r3, #0
 800106a:	d1da      	bne.n	8001022 <XMC_DMA_IRQHandler+0x3a>
 800106c:	e0c3      	b.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
 800106e:	e0c2      	b.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
 8001070:	697b      	ldr	r3, [r7, #20]
 8001072:	f003 0301 	and.w	r3, r3, #1
 8001076:	2b00      	cmp	r3, #0
 8001078:	d02b      	beq.n	80010d2 <XMC_DMA_IRQHandler+0xea>
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
 800107a:	6878      	ldr	r0, [r7, #4]
 800107c:	f7ff fbf4 	bl	8000868 <XMC_DMA_GetChannelsTransferCompleteStatus>
 8001080:	6178      	str	r0, [r7, #20]
    while (event != 0)
 8001082:	e021      	b.n	80010c8 <XMC_DMA_IRQHandler+0xe0>
    {
      mask = (uint32_t)1U << channel;
 8001084:	2201      	movs	r2, #1
 8001086:	69fb      	ldr	r3, [r7, #28]
 8001088:	fa02 f303 	lsl.w	r3, r2, r3
 800108c:	613b      	str	r3, [r7, #16]
      if (event & mask)
 800108e:	697a      	ldr	r2, [r7, #20]
 8001090:	693b      	ldr	r3, [r7, #16]
 8001092:	4013      	ands	r3, r2
 8001094:	2b00      	cmp	r3, #0
 8001096:	d014      	beq.n	80010c2 <XMC_DMA_IRQHandler+0xda>
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)((uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE |
 8001098:	69fb      	ldr	r3, [r7, #28]
 800109a:	b2db      	uxtb	r3, r3
 800109c:	6878      	ldr	r0, [r7, #4]
 800109e:	4619      	mov	r1, r3
 80010a0:	220f      	movs	r2, #15
 80010a2:	f7ff ff59 	bl	8000f58 <XMC_DMA_CH_ClearEventStatus>
                                    (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                    (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                    (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 80010a6:	69fb      	ldr	r3, [r7, #28]
 80010a8:	009b      	lsls	r3, r3, #2
 80010aa:	69ba      	ldr	r2, [r7, #24]
 80010ac:	4413      	add	r3, r2
 80010ae:	681b      	ldr	r3, [r3, #0]
 80010b0:	60fb      	str	r3, [r7, #12]
        if (event_handler != NULL)
 80010b2:	68fb      	ldr	r3, [r7, #12]
 80010b4:	2b00      	cmp	r3, #0
 80010b6:	d003      	beq.n	80010c0 <XMC_DMA_IRQHandler+0xd8>
        {
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 80010b8:	68fb      	ldr	r3, [r7, #12]
 80010ba:	2001      	movs	r0, #1
 80010bc:	4798      	blx	r3
        }

        break;
 80010be:	e007      	b.n	80010d0 <XMC_DMA_IRQHandler+0xe8>
 80010c0:	e006      	b.n	80010d0 <XMC_DMA_IRQHandler+0xe8>
      }
      ++channel;
 80010c2:	69fb      	ldr	r3, [r7, #28]
 80010c4:	3301      	adds	r3, #1
 80010c6:	61fb      	str	r3, [r7, #28]
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
 80010c8:	697b      	ldr	r3, [r7, #20]
 80010ca:	2b00      	cmp	r3, #0
 80010cc:	d1da      	bne.n	8001084 <XMC_DMA_IRQHandler+0x9c>
 80010ce:	e092      	b.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
 80010d0:	e091      	b.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
 80010d2:	697b      	ldr	r3, [r7, #20]
 80010d4:	f003 0302 	and.w	r3, r3, #2
 80010d8:	2b00      	cmp	r3, #0
 80010da:	d02b      	beq.n	8001134 <XMC_DMA_IRQHandler+0x14c>
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
 80010dc:	6878      	ldr	r0, [r7, #4]
 80010de:	f7ff fbd1 	bl	8000884 <XMC_DMA_GetChannelsBlockCompleteStatus>
 80010e2:	6178      	str	r0, [r7, #20]
    while (event != 0)
 80010e4:	e021      	b.n	800112a <XMC_DMA_IRQHandler+0x142>
    {
      mask = (uint32_t)1U << channel;
 80010e6:	2201      	movs	r2, #1
 80010e8:	69fb      	ldr	r3, [r7, #28]
 80010ea:	fa02 f303 	lsl.w	r3, r2, r3
 80010ee:	613b      	str	r3, [r7, #16]
      if (event & mask)
 80010f0:	697a      	ldr	r2, [r7, #20]
 80010f2:	693b      	ldr	r3, [r7, #16]
 80010f4:	4013      	ands	r3, r2
 80010f6:	2b00      	cmp	r3, #0
 80010f8:	d014      	beq.n	8001124 <XMC_DMA_IRQHandler+0x13c>
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)((uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
 80010fa:	69fb      	ldr	r3, [r7, #28]
 80010fc:	b2db      	uxtb	r3, r3
 80010fe:	6878      	ldr	r0, [r7, #4]
 8001100:	4619      	mov	r1, r3
 8001102:	220e      	movs	r2, #14
 8001104:	f7ff ff28 	bl	8000f58 <XMC_DMA_CH_ClearEventStatus>
                                    (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                    (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8001108:	69fb      	ldr	r3, [r7, #28]
 800110a:	009b      	lsls	r3, r3, #2
 800110c:	69ba      	ldr	r2, [r7, #24]
 800110e:	4413      	add	r3, r2
 8001110:	681b      	ldr	r3, [r3, #0]
 8001112:	60fb      	str	r3, [r7, #12]
        if (event_handler != NULL)
 8001114:	68fb      	ldr	r3, [r7, #12]
 8001116:	2b00      	cmp	r3, #0
 8001118:	d003      	beq.n	8001122 <XMC_DMA_IRQHandler+0x13a>
        {
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
 800111a:	68fb      	ldr	r3, [r7, #12]
 800111c:	2002      	movs	r0, #2
 800111e:	4798      	blx	r3
        }

        break;
 8001120:	e007      	b.n	8001132 <XMC_DMA_IRQHandler+0x14a>
 8001122:	e006      	b.n	8001132 <XMC_DMA_IRQHandler+0x14a>
      }
      ++channel;
 8001124:	69fb      	ldr	r3, [r7, #28]
 8001126:	3301      	adds	r3, #1
 8001128:	61fb      	str	r3, [r7, #28]
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
 800112a:	697b      	ldr	r3, [r7, #20]
 800112c:	2b00      	cmp	r3, #0
 800112e:	d1da      	bne.n	80010e6 <XMC_DMA_IRQHandler+0xfe>
 8001130:	e061      	b.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
 8001132:	e060      	b.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 8001134:	697b      	ldr	r3, [r7, #20]
 8001136:	f003 0304 	and.w	r3, r3, #4
 800113a:	2b00      	cmp	r3, #0
 800113c:	d02b      	beq.n	8001196 <XMC_DMA_IRQHandler+0x1ae>
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
 800113e:	6878      	ldr	r0, [r7, #4]
 8001140:	f7ff fbae 	bl	80008a0 <XMC_DMA_GetChannelsSourceTransactionCompleteStatus>
 8001144:	6178      	str	r0, [r7, #20]
    while (event != 0)
 8001146:	e021      	b.n	800118c <XMC_DMA_IRQHandler+0x1a4>
    {
      mask = (uint32_t)1U << channel;
 8001148:	2201      	movs	r2, #1
 800114a:	69fb      	ldr	r3, [r7, #28]
 800114c:	fa02 f303 	lsl.w	r3, r2, r3
 8001150:	613b      	str	r3, [r7, #16]
      if (event & mask)
 8001152:	697a      	ldr	r2, [r7, #20]
 8001154:	693b      	ldr	r3, [r7, #16]
 8001156:	4013      	ands	r3, r2
 8001158:	2b00      	cmp	r3, #0
 800115a:	d014      	beq.n	8001186 <XMC_DMA_IRQHandler+0x19e>
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 800115c:	69fb      	ldr	r3, [r7, #28]
 800115e:	b2db      	uxtb	r3, r3
 8001160:	6878      	ldr	r0, [r7, #4]
 8001162:	4619      	mov	r1, r3
 8001164:	2204      	movs	r2, #4
 8001166:	f7ff fef7 	bl	8000f58 <XMC_DMA_CH_ClearEventStatus>

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 800116a:	69fb      	ldr	r3, [r7, #28]
 800116c:	009b      	lsls	r3, r3, #2
 800116e:	69ba      	ldr	r2, [r7, #24]
 8001170:	4413      	add	r3, r2
 8001172:	681b      	ldr	r3, [r3, #0]
 8001174:	60fb      	str	r3, [r7, #12]
        if (event_handler != NULL)
 8001176:	68fb      	ldr	r3, [r7, #12]
 8001178:	2b00      	cmp	r3, #0
 800117a:	d003      	beq.n	8001184 <XMC_DMA_IRQHandler+0x19c>
        {
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 800117c:	68fb      	ldr	r3, [r7, #12]
 800117e:	2004      	movs	r0, #4
 8001180:	4798      	blx	r3
        }

        break;
 8001182:	e007      	b.n	8001194 <XMC_DMA_IRQHandler+0x1ac>
 8001184:	e006      	b.n	8001194 <XMC_DMA_IRQHandler+0x1ac>
      }
      ++channel;
 8001186:	69fb      	ldr	r3, [r7, #28]
 8001188:	3301      	adds	r3, #1
 800118a:	61fb      	str	r3, [r7, #28]
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
 800118c:	697b      	ldr	r3, [r7, #20]
 800118e:	2b00      	cmp	r3, #0
 8001190:	d1da      	bne.n	8001148 <XMC_DMA_IRQHandler+0x160>
 8001192:	e030      	b.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
 8001194:	e02f      	b.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 8001196:	697b      	ldr	r3, [r7, #20]
 8001198:	f003 0308 	and.w	r3, r3, #8
 800119c:	2b00      	cmp	r3, #0
 800119e:	d02a      	beq.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
 80011a0:	6878      	ldr	r0, [r7, #4]
 80011a2:	f7ff fb8b 	bl	80008bc <XMC_DMA_GetChannelsDestinationTransactionCompleteStatus>
 80011a6:	6178      	str	r0, [r7, #20]
    while (event != 0)
 80011a8:	e021      	b.n	80011ee <XMC_DMA_IRQHandler+0x206>
    {
      mask = (uint32_t)1U << channel;
 80011aa:	2201      	movs	r2, #1
 80011ac:	69fb      	ldr	r3, [r7, #28]
 80011ae:	fa02 f303 	lsl.w	r3, r2, r3
 80011b2:	613b      	str	r3, [r7, #16]
      if (event & mask)
 80011b4:	697a      	ldr	r2, [r7, #20]
 80011b6:	693b      	ldr	r3, [r7, #16]
 80011b8:	4013      	ands	r3, r2
 80011ba:	2b00      	cmp	r3, #0
 80011bc:	d014      	beq.n	80011e8 <XMC_DMA_IRQHandler+0x200>
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 80011be:	69fb      	ldr	r3, [r7, #28]
 80011c0:	b2db      	uxtb	r3, r3
 80011c2:	6878      	ldr	r0, [r7, #4]
 80011c4:	4619      	mov	r1, r3
 80011c6:	2208      	movs	r2, #8
 80011c8:	f7ff fec6 	bl	8000f58 <XMC_DMA_CH_ClearEventStatus>

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 80011cc:	69fb      	ldr	r3, [r7, #28]
 80011ce:	009b      	lsls	r3, r3, #2
 80011d0:	69ba      	ldr	r2, [r7, #24]
 80011d2:	4413      	add	r3, r2
 80011d4:	681b      	ldr	r3, [r3, #0]
 80011d6:	60fb      	str	r3, [r7, #12]
        if (event_handler != NULL)
 80011d8:	68fb      	ldr	r3, [r7, #12]
 80011da:	2b00      	cmp	r3, #0
 80011dc:	d003      	beq.n	80011e6 <XMC_DMA_IRQHandler+0x1fe>
        {
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 80011de:	68fb      	ldr	r3, [r7, #12]
 80011e0:	2008      	movs	r0, #8
 80011e2:	4798      	blx	r3
        }

        break;
 80011e4:	e007      	b.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
 80011e6:	e006      	b.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
      }
      ++channel;
 80011e8:	69fb      	ldr	r3, [r7, #28]
 80011ea:	3301      	adds	r3, #1
 80011ec:	61fb      	str	r3, [r7, #28]
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
 80011ee:	697b      	ldr	r3, [r7, #20]
 80011f0:	2b00      	cmp	r3, #0
 80011f2:	d1da      	bne.n	80011aa <XMC_DMA_IRQHandler+0x1c2>
 80011f4:	e7ff      	b.n	80011f6 <XMC_DMA_IRQHandler+0x20e>
  else
  {
    /* no active interrupt was found? */
  }

}
 80011f6:	3720      	adds	r7, #32
 80011f8:	46bd      	mov	sp, r7
 80011fa:	bd80      	pop	{r7, pc}
 80011fc:	50014000 	.word	0x50014000
 8001200:	1ffe8854 	.word	0x1ffe8854
 8001204:	1ffe8874 	.word	0x1ffe8874

08001208 <_init>:
  }
}

/* Init */
void _init(void)
{}
 8001208:	b480      	push	{r7}
 800120a:	af00      	add	r7, sp, #0
 800120c:	46bd      	mov	sp, r7
 800120e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001212:	4770      	bx	lr

08001214 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8001214:	b480      	push	{r7}
 8001216:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001218:	4b04      	ldr	r3, [pc, #16]	; (800122c <__NVIC_GetPriorityGrouping+0x18>)
 800121a:	68db      	ldr	r3, [r3, #12]
 800121c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8001220:	0a1b      	lsrs	r3, r3, #8
}
 8001222:	4618      	mov	r0, r3
 8001224:	46bd      	mov	sp, r7
 8001226:	f85d 7b04 	ldr.w	r7, [sp], #4
 800122a:	4770      	bx	lr
 800122c:	e000ed00 	.word	0xe000ed00

08001230 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001230:	b480      	push	{r7}
 8001232:	b083      	sub	sp, #12
 8001234:	af00      	add	r7, sp, #0
 8001236:	4603      	mov	r3, r0
 8001238:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800123a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800123e:	2b00      	cmp	r3, #0
 8001240:	db0b      	blt.n	800125a <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001242:	4908      	ldr	r1, [pc, #32]	; (8001264 <__NVIC_EnableIRQ+0x34>)
 8001244:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001248:	095b      	lsrs	r3, r3, #5
 800124a:	79fa      	ldrb	r2, [r7, #7]
 800124c:	f002 021f 	and.w	r2, r2, #31
 8001250:	2001      	movs	r0, #1
 8001252:	fa00 f202 	lsl.w	r2, r0, r2
 8001256:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 800125a:	370c      	adds	r7, #12
 800125c:	46bd      	mov	sp, r7
 800125e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001262:	4770      	bx	lr
 8001264:	e000e100 	.word	0xe000e100

08001268 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001268:	b480      	push	{r7}
 800126a:	b083      	sub	sp, #12
 800126c:	af00      	add	r7, sp, #0
 800126e:	4603      	mov	r3, r0
 8001270:	6039      	str	r1, [r7, #0]
 8001272:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001274:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001278:	2b00      	cmp	r3, #0
 800127a:	db0a      	blt.n	8001292 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800127c:	490d      	ldr	r1, [pc, #52]	; (80012b4 <__NVIC_SetPriority+0x4c>)
 800127e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001282:	683a      	ldr	r2, [r7, #0]
 8001284:	b2d2      	uxtb	r2, r2
 8001286:	0092      	lsls	r2, r2, #2
 8001288:	b2d2      	uxtb	r2, r2
 800128a:	440b      	add	r3, r1
 800128c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
 8001290:	e00a      	b.n	80012a8 <__NVIC_SetPriority+0x40>
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001292:	4909      	ldr	r1, [pc, #36]	; (80012b8 <__NVIC_SetPriority+0x50>)
 8001294:	79fb      	ldrb	r3, [r7, #7]
 8001296:	f003 030f 	and.w	r3, r3, #15
 800129a:	3b04      	subs	r3, #4
 800129c:	683a      	ldr	r2, [r7, #0]
 800129e:	b2d2      	uxtb	r2, r2
 80012a0:	0092      	lsls	r2, r2, #2
 80012a2:	b2d2      	uxtb	r2, r2
 80012a4:	440b      	add	r3, r1
 80012a6:	761a      	strb	r2, [r3, #24]
  }
}
 80012a8:	370c      	adds	r7, #12
 80012aa:	46bd      	mov	sp, r7
 80012ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80012b0:	4770      	bx	lr
 80012b2:	bf00      	nop
 80012b4:	e000e100 	.word	0xe000e100
 80012b8:	e000ed00 	.word	0xe000ed00

080012bc <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80012bc:	b480      	push	{r7}
 80012be:	b089      	sub	sp, #36	; 0x24
 80012c0:	af00      	add	r7, sp, #0
 80012c2:	60f8      	str	r0, [r7, #12]
 80012c4:	60b9      	str	r1, [r7, #8]
 80012c6:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80012c8:	68fb      	ldr	r3, [r7, #12]
 80012ca:	f003 0307 	and.w	r3, r3, #7
 80012ce:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80012d0:	69fb      	ldr	r3, [r7, #28]
 80012d2:	f1c3 0307 	rsb	r3, r3, #7
 80012d6:	2b06      	cmp	r3, #6
 80012d8:	bf28      	it	cs
 80012da:	2306      	movcs	r3, #6
 80012dc:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80012de:	69fb      	ldr	r3, [r7, #28]
 80012e0:	3306      	adds	r3, #6
 80012e2:	2b06      	cmp	r3, #6
 80012e4:	d902      	bls.n	80012ec <NVIC_EncodePriority+0x30>
 80012e6:	69fb      	ldr	r3, [r7, #28]
 80012e8:	3b01      	subs	r3, #1
 80012ea:	e000      	b.n	80012ee <NVIC_EncodePriority+0x32>
 80012ec:	2300      	movs	r3, #0
 80012ee:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80012f0:	69bb      	ldr	r3, [r7, #24]
 80012f2:	2201      	movs	r2, #1
 80012f4:	fa02 f303 	lsl.w	r3, r2, r3
 80012f8:	1e5a      	subs	r2, r3, #1
 80012fa:	68bb      	ldr	r3, [r7, #8]
 80012fc:	401a      	ands	r2, r3
 80012fe:	697b      	ldr	r3, [r7, #20]
 8001300:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001302:	697b      	ldr	r3, [r7, #20]
 8001304:	2101      	movs	r1, #1
 8001306:	fa01 f303 	lsl.w	r3, r1, r3
 800130a:	1e59      	subs	r1, r3, #1
 800130c:	687b      	ldr	r3, [r7, #4]
 800130e:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8001310:	4313      	orrs	r3, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
}
 8001312:	4618      	mov	r0, r3
 8001314:	3724      	adds	r7, #36	; 0x24
 8001316:	46bd      	mov	sp, r7
 8001318:	f85d 7b04 	ldr.w	r7, [sp], #4
 800131c:	4770      	bx	lr
 800131e:	bf00      	nop

08001320 <GLOBAL_DMA_Init>:
  return version;
}

/* GLOBAL_DMA initialization function */
GLOBAL_DMA_STATUS_t GLOBAL_DMA_Init(GLOBAL_DMA_t *const obj)
{
 8001320:	b590      	push	{r4, r7, lr}
 8001322:	b083      	sub	sp, #12
 8001324:	af00      	add	r7, sp, #0
 8001326:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DMA_GLOBAL_Init: NULL DMA_GLOBAL_t object", (obj != NULL));

  if (obj->initialized == false)
 8001328:	687b      	ldr	r3, [r7, #4]
 800132a:	7a1b      	ldrb	r3, [r3, #8]
 800132c:	f083 0301 	eor.w	r3, r3, #1
 8001330:	b2db      	uxtb	r3, r3
 8001332:	2b00      	cmp	r3, #0
 8001334:	d024      	beq.n	8001380 <GLOBAL_DMA_Init+0x60>
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);
 8001336:	687b      	ldr	r3, [r7, #4]
 8001338:	681b      	ldr	r3, [r3, #0]
 800133a:	4618      	mov	r0, r3
 800133c:	f7ff fada 	bl	80008f4 <XMC_DMA_Init>

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 8001340:	687b      	ldr	r3, [r7, #4]
 8001342:	7a5c      	ldrb	r4, [r3, #9]
 8001344:	f7ff ff66 	bl	8001214 <__NVIC_GetPriorityGrouping>
 8001348:	4601      	mov	r1, r0
                                                        obj->config->priority,
 800134a:	687b      	ldr	r3, [r7, #4]
 800134c:	685b      	ldr	r3, [r3, #4]
 800134e:	781b      	ldrb	r3, [r3, #0]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 8001350:	461a      	mov	r2, r3
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
 8001352:	687b      	ldr	r3, [r7, #4]
 8001354:	685b      	ldr	r3, [r3, #4]
 8001356:	785b      	ldrb	r3, [r3, #1]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 8001358:	4608      	mov	r0, r1
 800135a:	4611      	mov	r1, r2
 800135c:	461a      	mov	r2, r3
 800135e:	f7ff ffad 	bl	80012bc <NVIC_EncodePriority>
 8001362:	4602      	mov	r2, r0
 8001364:	b263      	sxtb	r3, r4
 8001366:	4618      	mov	r0, r3
 8001368:	4611      	mov	r1, r2
 800136a:	f7ff ff7d 	bl	8001268 <__NVIC_SetPriority>
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
    NVIC_EnableIRQ(obj->irq_node);
 800136e:	687b      	ldr	r3, [r7, #4]
 8001370:	7a5b      	ldrb	r3, [r3, #9]
 8001372:	b25b      	sxtb	r3, r3
 8001374:	4618      	mov	r0, r3
 8001376:	f7ff ff5b 	bl	8001230 <__NVIC_EnableIRQ>
    obj->initialized = true;
 800137a:	687b      	ldr	r3, [r7, #4]
 800137c:	2201      	movs	r2, #1
 800137e:	721a      	strb	r2, [r3, #8]
  }

  return GLOBAL_DMA_STATUS_SUCCESS;
 8001380:	2300      	movs	r3, #0
}
 8001382:	4618      	mov	r0, r3
 8001384:	370c      	adds	r7, #12
 8001386:	46bd      	mov	sp, r7
 8001388:	bd90      	pop	{r4, r7, pc}
 800138a:	bf00      	nop

0800138c <GPDMA0_0_IRQHandler>:
  .initialized = (bool)0U, /* Is DMA initialized yet? */
  .irq_node = (IRQn_Type)110U /* Allotted DMA IRQ node */
};

void GPDMA0_0_IRQHandler(void)
{
 800138c:	b580      	push	{r7, lr}
 800138e:	af00      	add	r7, sp, #0
  XMC_DMA_IRQHandler(XMC_DMA0);
 8001390:	4801      	ldr	r0, [pc, #4]	; (8001398 <GPDMA0_0_IRQHandler+0xc>)
 8001392:	f7ff fe29 	bl	8000fe8 <XMC_DMA_IRQHandler>
}
 8001396:	bd80      	pop	{r7, pc}
 8001398:	50014000 	.word	0x50014000

0800139c <GPDMA1_0_IRQHandler>:

#ifdef XMC_DMA1
void GPDMA1_0_IRQHandler(void)
{
 800139c:	b580      	push	{r7, lr}
 800139e:	af00      	add	r7, sp, #0
  XMC_DMA_IRQHandler(XMC_DMA1);
 80013a0:	4801      	ldr	r0, [pc, #4]	; (80013a8 <GPDMA1_0_IRQHandler+0xc>)
 80013a2:	f7ff fe21 	bl	8000fe8 <XMC_DMA_IRQHandler>
}
 80013a6:	bd80      	pop	{r7, pc}
 80013a8:	50018000 	.word	0x50018000

080013ac <DMA_CH_Init>:
  return version;
}

/* DMA_CH initialization function */
DMA_CH_STATUS_t DMA_CH_Init(DMA_CH_t *const obj)
{
 80013ac:	b580      	push	{r7, lr}
 80013ae:	b084      	sub	sp, #16
 80013b0:	af00      	add	r7, sp, #0
 80013b2:	6078      	str	r0, [r7, #4]
  DMA_CH_STATUS_t status;

  XMC_ASSERT("DMA_CH_Init: NULL DMA_CH_t object", (obj != NULL));

  /* This cannot possibly fail! */
  GLOBAL_DMA_Init(obj->dma_global);
 80013b4:	687b      	ldr	r3, [r7, #4]
 80013b6:	681b      	ldr	r3, [r3, #0]
 80013b8:	4618      	mov	r0, r3
 80013ba:	f7ff ffb1 	bl	8001320 <GLOBAL_DMA_Init>

  if (XMC_DMA_CH_Init(obj->dma_global->dma, obj->ch_num, &obj->config->ch_config) == XMC_DMA_CH_STATUS_OK)
 80013be:	687b      	ldr	r3, [r7, #4]
 80013c0:	681b      	ldr	r3, [r3, #0]
 80013c2:	6819      	ldr	r1, [r3, #0]
 80013c4:	687b      	ldr	r3, [r7, #4]
 80013c6:	7b1a      	ldrb	r2, [r3, #12]
 80013c8:	687b      	ldr	r3, [r7, #4]
 80013ca:	685b      	ldr	r3, [r3, #4]
 80013cc:	4608      	mov	r0, r1
 80013ce:	4611      	mov	r1, r2
 80013d0:	461a      	mov	r2, r3
 80013d2:	f7ff fb93 	bl	8000afc <XMC_DMA_CH_Init>
 80013d6:	4603      	mov	r3, r0
 80013d8:	2b00      	cmp	r3, #0
 80013da:	d125      	bne.n	8001428 <DMA_CH_Init+0x7c>
  {
	if(obj->config->events)
 80013dc:	687b      	ldr	r3, [r7, #4]
 80013de:	685b      	ldr	r3, [r3, #4]
 80013e0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80013e2:	2b00      	cmp	r3, #0
 80013e4:	d019      	beq.n	800141a <DMA_CH_Init+0x6e>
	{
		XMC_DMA_CH_EnableEvent(obj->dma_global->dma, obj->ch_num, obj->config->events);
 80013e6:	687b      	ldr	r3, [r7, #4]
 80013e8:	681b      	ldr	r3, [r3, #0]
 80013ea:	6819      	ldr	r1, [r3, #0]
 80013ec:	687b      	ldr	r3, [r7, #4]
 80013ee:	7b1a      	ldrb	r2, [r3, #12]
 80013f0:	687b      	ldr	r3, [r7, #4]
 80013f2:	685b      	ldr	r3, [r3, #4]
 80013f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80013f6:	4608      	mov	r0, r1
 80013f8:	4611      	mov	r1, r2
 80013fa:	461a      	mov	r2, r3
 80013fc:	f7ff fd84 	bl	8000f08 <XMC_DMA_CH_EnableEvent>
		XMC_DMA_CH_SetEventHandler(obj->dma_global->dma, obj->ch_num, obj->config->callback);
 8001400:	687b      	ldr	r3, [r7, #4]
 8001402:	681b      	ldr	r3, [r3, #0]
 8001404:	6819      	ldr	r1, [r3, #0]
 8001406:	687b      	ldr	r3, [r7, #4]
 8001408:	7b1a      	ldrb	r2, [r3, #12]
 800140a:	687b      	ldr	r3, [r7, #4]
 800140c:	685b      	ldr	r3, [r3, #4]
 800140e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001410:	4608      	mov	r0, r1
 8001412:	4611      	mov	r1, r2
 8001414:	461a      	mov	r2, r3
 8001416:	f7ff fdc5 	bl	8000fa4 <XMC_DMA_CH_SetEventHandler>
	}
    obj->reload(obj);
 800141a:	687b      	ldr	r3, [r7, #4]
 800141c:	689b      	ldr	r3, [r3, #8]
 800141e:	6878      	ldr	r0, [r7, #4]
 8001420:	4798      	blx	r3
    status = DMA_CH_STATUS_SUCCESS;
 8001422:	2300      	movs	r3, #0
 8001424:	73fb      	strb	r3, [r7, #15]
 8001426:	e001      	b.n	800142c <DMA_CH_Init+0x80>
  }
  else
  {
    status = DMA_CH_STATUS_FAILURE;
 8001428:	2301      	movs	r3, #1
 800142a:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 800142c:	7bfb      	ldrb	r3, [r7, #15]
}
 800142e:	4618      	mov	r0, r3
 8001430:	3710      	adds	r7, #16
 8001432:	46bd      	mov	sp, r7
 8001434:	bd80      	pop	{r7, pc}
 8001436:	bf00      	nop

08001438 <XMC_DMA_CH_SetSourceAddress>:
 *
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
 8001438:	b480      	push	{r7}
 800143a:	b085      	sub	sp, #20
 800143c:	af00      	add	r7, sp, #0
 800143e:	60f8      	str	r0, [r7, #12]
 8001440:	460b      	mov	r3, r1
 8001442:	607a      	str	r2, [r7, #4]
 8001444:	72fb      	strb	r3, [r7, #11]
  dma->CH[channel].SAR = addr;
 8001446:	7afb      	ldrb	r3, [r7, #11]
 8001448:	68fa      	ldr	r2, [r7, #12]
 800144a:	2158      	movs	r1, #88	; 0x58
 800144c:	fb01 f303 	mul.w	r3, r1, r3
 8001450:	4413      	add	r3, r2
 8001452:	687a      	ldr	r2, [r7, #4]
 8001454:	601a      	str	r2, [r3, #0]
}
 8001456:	3714      	adds	r7, #20
 8001458:	46bd      	mov	sp, r7
 800145a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800145e:	4770      	bx	lr

08001460 <XMC_DMA_CH_SetDestinationAddress>:
 *
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
 8001460:	b480      	push	{r7}
 8001462:	b085      	sub	sp, #20
 8001464:	af00      	add	r7, sp, #0
 8001466:	60f8      	str	r0, [r7, #12]
 8001468:	460b      	mov	r3, r1
 800146a:	607a      	str	r2, [r7, #4]
 800146c:	72fb      	strb	r3, [r7, #11]
  dma->CH[channel].DAR = addr;
 800146e:	7afb      	ldrb	r3, [r7, #11]
 8001470:	68fa      	ldr	r2, [r7, #12]
 8001472:	2158      	movs	r1, #88	; 0x58
 8001474:	fb01 f303 	mul.w	r3, r1, r3
 8001478:	4413      	add	r3, r2
 800147a:	3308      	adds	r3, #8
 800147c:	687a      	ldr	r2, [r7, #4]
 800147e:	601a      	str	r2, [r3, #0]
}
 8001480:	3714      	adds	r7, #20
 8001482:	46bd      	mov	sp, r7
 8001484:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001488:	4770      	bx	lr
 800148a:	bf00      	nop

0800148c <XMC_DMA_CH_SetBlockSize>:
 * The function may be called after enabling the DMA channel. Please
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
 800148c:	b480      	push	{r7}
 800148e:	b085      	sub	sp, #20
 8001490:	af00      	add	r7, sp, #0
 8001492:	60f8      	str	r0, [r7, #12]
 8001494:	460b      	mov	r3, r1
 8001496:	607a      	str	r2, [r7, #4]
 8001498:	72fb      	strb	r3, [r7, #11]
  dma->CH[channel].CTLH = block_size;
 800149a:	7afb      	ldrb	r3, [r7, #11]
 800149c:	68fa      	ldr	r2, [r7, #12]
 800149e:	2158      	movs	r1, #88	; 0x58
 80014a0:	fb01 f303 	mul.w	r3, r1, r3
 80014a4:	4413      	add	r3, r2
 80014a6:	3318      	adds	r3, #24
 80014a8:	687a      	ldr	r2, [r7, #4]
 80014aa:	605a      	str	r2, [r3, #4]
}
 80014ac:	3714      	adds	r7, #20
 80014ae:	46bd      	mov	sp, r7
 80014b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80014b4:	4770      	bx	lr
 80014b6:	bf00      	nop

080014b8 <DMA_CH_0_reload>:
extern uint32_t* src_ptr; /* Source address symbol */

extern uint32_t* dst_ptr; /* Destination address symbol */

void DMA_CH_0_reload(DMA_CH_t *obj)
{
 80014b8:	b580      	push	{r7, lr}
 80014ba:	b082      	sub	sp, #8
 80014bc:	af00      	add	r7, sp, #0
 80014be:	6078      	str	r0, [r7, #4]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 1024);
 80014c0:	687b      	ldr	r3, [r7, #4]
 80014c2:	681b      	ldr	r3, [r3, #0]
 80014c4:	681a      	ldr	r2, [r3, #0]
 80014c6:	687b      	ldr	r3, [r7, #4]
 80014c8:	7b1b      	ldrb	r3, [r3, #12]
 80014ca:	4610      	mov	r0, r2
 80014cc:	4619      	mov	r1, r3
 80014ce:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80014d2:	f7ff ffdb 	bl	800148c <XMC_DMA_CH_SetBlockSize>
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)src_ptr);
 80014d6:	687b      	ldr	r3, [r7, #4]
 80014d8:	681b      	ldr	r3, [r3, #0]
 80014da:	6819      	ldr	r1, [r3, #0]
 80014dc:	687b      	ldr	r3, [r7, #4]
 80014de:	7b1a      	ldrb	r2, [r3, #12]
 80014e0:	4b0a      	ldr	r3, [pc, #40]	; (800150c <DMA_CH_0_reload+0x54>)
 80014e2:	681b      	ldr	r3, [r3, #0]
 80014e4:	4608      	mov	r0, r1
 80014e6:	4611      	mov	r1, r2
 80014e8:	461a      	mov	r2, r3
 80014ea:	f7ff ffa5 	bl	8001438 <XMC_DMA_CH_SetSourceAddress>
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)dst_ptr);
 80014ee:	687b      	ldr	r3, [r7, #4]
 80014f0:	681b      	ldr	r3, [r3, #0]
 80014f2:	6819      	ldr	r1, [r3, #0]
 80014f4:	687b      	ldr	r3, [r7, #4]
 80014f6:	7b1a      	ldrb	r2, [r3, #12]
 80014f8:	4b05      	ldr	r3, [pc, #20]	; (8001510 <DMA_CH_0_reload+0x58>)
 80014fa:	681b      	ldr	r3, [r3, #0]
 80014fc:	4608      	mov	r0, r1
 80014fe:	4611      	mov	r1, r2
 8001500:	461a      	mov	r2, r3
 8001502:	f7ff ffad 	bl	8001460 <XMC_DMA_CH_SetDestinationAddress>
}
 8001506:	3708      	adds	r7, #8
 8001508:	46bd      	mov	sp, r7
 800150a:	bd80      	pop	{r7, pc}
 800150c:	1ffe884c 	.word	0x1ffe884c
 8001510:	1ffe8850 	.word	0x1ffe8850

08001514 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001514:	b480      	push	{r7}
 8001516:	b085      	sub	sp, #20
 8001518:	af00      	add	r7, sp, #0
 800151a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800151c:	687b      	ldr	r3, [r7, #4]
 800151e:	f003 0307 	and.w	r3, r3, #7
 8001522:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001524:	4b0c      	ldr	r3, [pc, #48]	; (8001558 <__NVIC_SetPriorityGrouping+0x44>)
 8001526:	68db      	ldr	r3, [r3, #12]
 8001528:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800152a:	68ba      	ldr	r2, [r7, #8]
 800152c:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8001530:	4013      	ands	r3, r2
 8001532:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001534:	68fb      	ldr	r3, [r7, #12]
 8001536:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001538:	68bb      	ldr	r3, [r7, #8]
 800153a:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800153c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8001540:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001544:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 8001546:	4a04      	ldr	r2, [pc, #16]	; (8001558 <__NVIC_SetPriorityGrouping+0x44>)
 8001548:	68bb      	ldr	r3, [r7, #8]
 800154a:	60d3      	str	r3, [r2, #12]
}
 800154c:	3714      	adds	r7, #20
 800154e:	46bd      	mov	sp, r7
 8001550:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001554:	4770      	bx	lr
 8001556:	bf00      	nop
 8001558:	e000ed00 	.word	0xe000ed00

0800155c <SystemCoreSetup>:
  .initialized = false
};	


void SystemCoreSetup(void)
{
 800155c:	b580      	push	{r7, lr}
 800155e:	b082      	sub	sp, #8
 8001560:	af00      	add	r7, sp, #0
  uint32_t temp;

  NVIC_SetPriorityGrouping(1U);
 8001562:	2001      	movs	r0, #1
 8001564:	f7ff ffd6 	bl	8001514 <__NVIC_SetPriorityGrouping>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001568:	b672      	cpsid	i
	
  /* relocate vector table */
  __disable_irq();

#if !defined(__TASKING__)
  SCB->VTOR = (uint32_t)(&__Vectors);
 800156a:	4b21      	ldr	r3, [pc, #132]	; (80015f0 <SystemCoreSetup+0x94>)
 800156c:	4a21      	ldr	r2, [pc, #132]	; (80015f4 <SystemCoreSetup+0x98>)
 800156e:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8001570:	f3bf 8f4f 	dsb	sy
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001574:	b662      	cpsie	i

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8001576:	4a1e      	ldr	r2, [pc, #120]	; (80015f0 <SystemCoreSetup+0x94>)
 8001578:	4b1d      	ldr	r3, [pc, #116]	; (80015f0 <SystemCoreSetup+0x94>)
 800157a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800157e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8001582:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 8001586:	4b1c      	ldr	r3, [pc, #112]	; (80015f8 <SystemCoreSetup+0x9c>)
 8001588:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800158c:	3314      	adds	r3, #20
 800158e:	681b      	ldr	r3, [r3, #0]
 8001590:	607b      	str	r3, [r7, #4]
  temp &= ~FLASH_FCON_WSPFLASH_Msk;
 8001592:	687b      	ldr	r3, [r7, #4]
 8001594:	f023 030f 	bic.w	r3, r3, #15
 8001598:	607b      	str	r3, [r7, #4]
  temp |= PMU_FLASH_WS;
 800159a:	687b      	ldr	r3, [r7, #4]
 800159c:	f043 0304 	orr.w	r3, r3, #4
 80015a0:	607b      	str	r3, [r7, #4]
  FLASH0->FCON = temp;
 80015a2:	4b15      	ldr	r3, [pc, #84]	; (80015f8 <SystemCoreSetup+0x9c>)
 80015a4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80015a8:	3314      	adds	r3, #20
 80015aa:	687a      	ldr	r2, [r7, #4]
 80015ac:	601a      	str	r2, [r3, #0]


  /* Disable divide by zero trap */
  SCB->CCR &= ~SCB_CCR_DIV_0_TRP_Msk; 
 80015ae:	4a10      	ldr	r2, [pc, #64]	; (80015f0 <SystemCoreSetup+0x94>)
 80015b0:	4b0f      	ldr	r3, [pc, #60]	; (80015f0 <SystemCoreSetup+0x94>)
 80015b2:	695b      	ldr	r3, [r3, #20]
 80015b4:	f023 0310 	bic.w	r3, r3, #16
 80015b8:	6153      	str	r3, [r2, #20]

  /* Disable unaligned memory access trap */
  SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk; 
 80015ba:	4a0d      	ldr	r2, [pc, #52]	; (80015f0 <SystemCoreSetup+0x94>)
 80015bc:	4b0c      	ldr	r3, [pc, #48]	; (80015f0 <SystemCoreSetup+0x94>)
 80015be:	695b      	ldr	r3, [r3, #20]
 80015c0:	f023 0308 	bic.w	r3, r3, #8
 80015c4:	6153      	str	r3, [r2, #20]

  /* Disable memory management fault */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 80015c6:	4a0a      	ldr	r2, [pc, #40]	; (80015f0 <SystemCoreSetup+0x94>)
 80015c8:	4b09      	ldr	r3, [pc, #36]	; (80015f0 <SystemCoreSetup+0x94>)
 80015ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80015cc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80015d0:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable bus fault */
  SCB->SHCSR &= ~SCB_SHCSR_BUSFAULTENA_Msk;
 80015d2:	4a07      	ldr	r2, [pc, #28]	; (80015f0 <SystemCoreSetup+0x94>)
 80015d4:	4b06      	ldr	r3, [pc, #24]	; (80015f0 <SystemCoreSetup+0x94>)
 80015d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80015d8:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 80015dc:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable usage fault */
  SCB->SHCSR &= ~SCB_SHCSR_USGFAULTENA_Msk;
 80015de:	4a04      	ldr	r2, [pc, #16]	; (80015f0 <SystemCoreSetup+0x94>)
 80015e0:	4b03      	ldr	r3, [pc, #12]	; (80015f0 <SystemCoreSetup+0x94>)
 80015e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80015e4:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80015e8:	6253      	str	r3, [r2, #36]	; 0x24
}
 80015ea:	3708      	adds	r7, #8
 80015ec:	46bd      	mov	sp, r7
 80015ee:	bd80      	pop	{r7, pc}
 80015f0:	e000ed00 	.word	0xe000ed00
 80015f4:	08000000 	.word	0x08000000
 80015f8:	58001000 	.word	0x58001000

080015fc <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
__WEAK DAVE_STATUS_t DAVE_Init(void)
{
 80015fc:	b580      	push	{r7, lr}
 80015fe:	b082      	sub	sp, #8
 8001600:	af00      	add	r7, sp, #0
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
 8001602:	2300      	movs	r3, #0
 8001604:	71fb      	strb	r3, [r7, #7]
  if (init_status == DAVE_STATUS_SUCCESS)
 8001606:	79fb      	ldrb	r3, [r7, #7]
 8001608:	2b00      	cmp	r3, #0
 800160a:	d104      	bne.n	8001616 <DAVE_Init+0x1a>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_0 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_0); 
 800160c:	4804      	ldr	r0, [pc, #16]	; (8001620 <DAVE_Init+0x24>)
 800160e:	f7ff fecd 	bl	80013ac <DMA_CH_Init>
 8001612:	4603      	mov	r3, r0
 8001614:	71fb      	strb	r3, [r7, #7]
   }  
  return init_status;
 8001616:	79fb      	ldrb	r3, [r7, #7]
} /**  End of function DAVE_Init */
 8001618:	4618      	mov	r0, r3
 800161a:	3708      	adds	r7, #8
 800161c:	46bd      	mov	sp, r7
 800161e:	bd80      	pop	{r7, pc}
 8001620:	1ffe883c 	.word	0x1ffe883c

08001624 <systick_start>:
uint32_t t2;
uint32_t calib_time;
uint32_t delta;

__STATIC_INLINE uint32_t systick_start(void)
{
 8001624:	b480      	push	{r7}
 8001626:	af00      	add	r7, sp, #0
	SysTick->LOAD = SysTick_LOAD_RELOAD_Msk -1;
 8001628:	4b08      	ldr	r3, [pc, #32]	; (800164c <systick_start+0x28>)
 800162a:	4a09      	ldr	r2, [pc, #36]	; (8001650 <systick_start+0x2c>)
 800162c:	605a      	str	r2, [r3, #4]
	SysTick->VAL = 0;
 800162e:	4b07      	ldr	r3, [pc, #28]	; (800164c <systick_start+0x28>)
 8001630:	2200      	movs	r2, #0
 8001632:	609a      	str	r2, [r3, #8]
	SysTick->CTRL =SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
 8001634:	4b05      	ldr	r3, [pc, #20]	; (800164c <systick_start+0x28>)
 8001636:	2205      	movs	r2, #5
 8001638:	601a      	str	r2, [r3, #0]
	__NOP();
 800163a:	bf00      	nop
	return ((uint32_t)SysTick->VAL);
 800163c:	4b03      	ldr	r3, [pc, #12]	; (800164c <systick_start+0x28>)
 800163e:	689b      	ldr	r3, [r3, #8]
}
 8001640:	4618      	mov	r0, r3
 8001642:	46bd      	mov	sp, r7
 8001644:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001648:	4770      	bx	lr
 800164a:	bf00      	nop
 800164c:	e000e010 	.word	0xe000e010
 8001650:	00fffffe 	.word	0x00fffffe

08001654 <systick_stop>:

__STATIC_INLINE uint32_t systick_stop(void)
{
 8001654:	b480      	push	{r7}
 8001656:	af00      	add	r7, sp, #0
	SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 8001658:	4a06      	ldr	r2, [pc, #24]	; (8001674 <systick_stop+0x20>)
 800165a:	4b06      	ldr	r3, [pc, #24]	; (8001674 <systick_stop+0x20>)
 800165c:	681b      	ldr	r3, [r3, #0]
 800165e:	f023 0301 	bic.w	r3, r3, #1
 8001662:	6013      	str	r3, [r2, #0]
	return ((uint32_t)SysTick->VAL);
 8001664:	4b03      	ldr	r3, [pc, #12]	; (8001674 <systick_stop+0x20>)
 8001666:	689b      	ldr	r3, [r3, #8]
}
 8001668:	4618      	mov	r0, r3
 800166a:	46bd      	mov	sp, r7
 800166c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001670:	4770      	bx	lr
 8001672:	bf00      	nop
 8001674:	e000e010 	.word	0xe000e010

08001678 <main>:
 * invoking the APP initialization dispatcher routine - DAVE_Init() and hosting the place-holder for user application
 * code.
 */

int main(void)
{
 8001678:	b580      	push	{r7, lr}
 800167a:	b082      	sub	sp, #8
 800167c:	af00      	add	r7, sp, #0
  DAVE_STATUS_t status;

  status = DAVE_Init();           /* Initialization of DAVE APPs  */
 800167e:	f7ff ffbd 	bl	80015fc <DAVE_Init>
 8001682:	4603      	mov	r3, r0
 8001684:	71fb      	strb	r3, [r7, #7]

  if (status != DAVE_STATUS_SUCCESS)
 8001686:	79fb      	ldrb	r3, [r7, #7]
 8001688:	2b00      	cmp	r3, #0
 800168a:	d000      	beq.n	800168e <main+0x16>
    XMC_DEBUG("DAVE APPs initialization failed\n");

    while(1U)
    {

    }
 800168c:	e7fe      	b.n	800168c <main+0x14>
  }

  /* Placeholder for user application code. The while loop below can be replaced with user application code. */
 t1 = systick_start();
 800168e:	f7ff ffc9 	bl	8001624 <systick_start>
 8001692:	4602      	mov	r2, r0
 8001694:	4b16      	ldr	r3, [pc, #88]	; (80016f0 <main+0x78>)
 8001696:	601a      	str	r2, [r3, #0]
 t2 = systick_stop();
 8001698:	f7ff ffdc 	bl	8001654 <systick_stop>
 800169c:	4602      	mov	r2, r0
 800169e:	4b15      	ldr	r3, [pc, #84]	; (80016f4 <main+0x7c>)
 80016a0:	601a      	str	r2, [r3, #0]
 calib_time = t1 -t2;
 80016a2:	4b13      	ldr	r3, [pc, #76]	; (80016f0 <main+0x78>)
 80016a4:	681a      	ldr	r2, [r3, #0]
 80016a6:	4b13      	ldr	r3, [pc, #76]	; (80016f4 <main+0x7c>)
 80016a8:	681b      	ldr	r3, [r3, #0]
 80016aa:	1ad3      	subs	r3, r2, r3
 80016ac:	4a12      	ldr	r2, [pc, #72]	; (80016f8 <main+0x80>)
 80016ae:	6013      	str	r3, [r2, #0]


 t1 = systick_start();
 80016b0:	f7ff ffb8 	bl	8001624 <systick_start>
 80016b4:	4602      	mov	r2, r0
 80016b6:	4b0e      	ldr	r3, [pc, #56]	; (80016f0 <main+0x78>)
 80016b8:	601a      	str	r2, [r3, #0]

 //without DMA , with CPU 33071
 memcpy(dst_ptr,src_ptr,sizeof(src_data));
 80016ba:	4b10      	ldr	r3, [pc, #64]	; (80016fc <main+0x84>)
 80016bc:	681a      	ldr	r2, [r3, #0]
 80016be:	4b10      	ldr	r3, [pc, #64]	; (8001700 <main+0x88>)
 80016c0:	681b      	ldr	r3, [r3, #0]
 80016c2:	4610      	mov	r0, r2
 80016c4:	4619      	mov	r1, r3
 80016c6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80016ca:	f000 f843 	bl	8001754 <memcpy>

 t2 = systick_stop();
 80016ce:	f7ff ffc1 	bl	8001654 <systick_stop>
 80016d2:	4602      	mov	r2, r0
 80016d4:	4b07      	ldr	r3, [pc, #28]	; (80016f4 <main+0x7c>)
 80016d6:	601a      	str	r2, [r3, #0]
 delta = t1 - t2 -calib_time;
 80016d8:	4b05      	ldr	r3, [pc, #20]	; (80016f0 <main+0x78>)
 80016da:	681a      	ldr	r2, [r3, #0]
 80016dc:	4b05      	ldr	r3, [pc, #20]	; (80016f4 <main+0x7c>)
 80016de:	681b      	ldr	r3, [r3, #0]
 80016e0:	1ad2      	subs	r2, r2, r3
 80016e2:	4b05      	ldr	r3, [pc, #20]	; (80016f8 <main+0x80>)
 80016e4:	681b      	ldr	r3, [r3, #0]
 80016e6:	1ad3      	subs	r3, r2, r3
 80016e8:	4a06      	ldr	r2, [pc, #24]	; (8001704 <main+0x8c>)
 80016ea:	6013      	str	r3, [r2, #0]
  while(1U)
  {

  }
 80016ec:	e7fe      	b.n	80016ec <main+0x74>
 80016ee:	bf00      	nop
 80016f0:	1ffe888c 	.word	0x1ffe888c
 80016f4:	1ffe8884 	.word	0x1ffe8884
 80016f8:	1ffe8888 	.word	0x1ffe8888
 80016fc:	1ffe8850 	.word	0x1ffe8850
 8001700:	1ffe884c 	.word	0x1ffe884c
 8001704:	1ffe8890 	.word	0x1ffe8890

08001708 <__libc_init_array>:
 8001708:	b570      	push	{r4, r5, r6, lr}
 800170a:	4b0e      	ldr	r3, [pc, #56]	; (8001744 <__libc_init_array+0x3c>)
 800170c:	4c0e      	ldr	r4, [pc, #56]	; (8001748 <__libc_init_array+0x40>)
 800170e:	1ae4      	subs	r4, r4, r3
 8001710:	10a4      	asrs	r4, r4, #2
 8001712:	2500      	movs	r5, #0
 8001714:	461e      	mov	r6, r3
 8001716:	42a5      	cmp	r5, r4
 8001718:	d004      	beq.n	8001724 <__libc_init_array+0x1c>
 800171a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800171e:	4798      	blx	r3
 8001720:	3501      	adds	r5, #1
 8001722:	e7f8      	b.n	8001716 <__libc_init_array+0xe>
 8001724:	f7ff fd70 	bl	8001208 <_init>
 8001728:	4c08      	ldr	r4, [pc, #32]	; (800174c <__libc_init_array+0x44>)
 800172a:	4b09      	ldr	r3, [pc, #36]	; (8001750 <__libc_init_array+0x48>)
 800172c:	1ae4      	subs	r4, r4, r3
 800172e:	10a4      	asrs	r4, r4, #2
 8001730:	2500      	movs	r5, #0
 8001732:	461e      	mov	r6, r3
 8001734:	42a5      	cmp	r5, r4
 8001736:	d004      	beq.n	8001742 <__libc_init_array+0x3a>
 8001738:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800173c:	4798      	blx	r3
 800173e:	3501      	adds	r5, #1
 8001740:	e7f8      	b.n	8001734 <__libc_init_array+0x2c>
 8001742:	bd70      	pop	{r4, r5, r6, pc}
 8001744:	1ffe8854 	.word	0x1ffe8854
 8001748:	1ffe8854 	.word	0x1ffe8854
 800174c:	1ffe8854 	.word	0x1ffe8854
 8001750:	1ffe8854 	.word	0x1ffe8854

08001754 <memcpy>:
 8001754:	b510      	push	{r4, lr}
 8001756:	1e43      	subs	r3, r0, #1
 8001758:	440a      	add	r2, r1
 800175a:	4291      	cmp	r1, r2
 800175c:	d004      	beq.n	8001768 <memcpy+0x14>
 800175e:	f811 4b01 	ldrb.w	r4, [r1], #1
 8001762:	f803 4f01 	strb.w	r4, [r3, #1]!
 8001766:	e7f8      	b.n	800175a <memcpy+0x6>
 8001768:	bd10      	pop	{r4, pc}
	...

0800176c <src_data>:
 800176c:	0000 0000 0001 0000 0002 0000 0003 0000     ................
 800177c:	0004 0000 0005 0000 0006 0000 0007 0000     ................
 800178c:	0008 0000 0009 0000 000a 0000 000b 0000     ................
 800179c:	000c 0000 000d 0000 000e 0000 000f 0000     ................
 80017ac:	0010 0000 0011 0000 0012 0000 0013 0000     ................
 80017bc:	0014 0000 0015 0000 0016 0000 0017 0000     ................
 80017cc:	0018 0000 0019 0000 001a 0000 001b 0000     ................
 80017dc:	001c 0000 001d 0000 001e 0000 001f 0000     ................
 80017ec:	0020 0000 0021 0000 0022 0000 0023 0000      ...!..."...#...
 80017fc:	0024 0000 0025 0000 0026 0000 0027 0000     $...%...&...'...
 800180c:	0028 0000 0029 0000 002a 0000 002b 0000     (...)...*...+...
 800181c:	002c 0000 002d 0000 002e 0000 002f 0000     ,...-......./...
 800182c:	0030 0000 0031 0000 0032 0000 0033 0000     0...1...2...3...
 800183c:	0034 0000 0035 0000 0036 0000 0037 0000     4...5...6...7...
 800184c:	0038 0000 0039 0000 003a 0000 003b 0000     8...9...:...;...
 800185c:	003c 0000 003d 0000 003e 0000 003f 0000     <...=...>...?...
 800186c:	0040 0000 0041 0000 0042 0000 0043 0000     @...A...B...C...
 800187c:	0044 0000 0045 0000 0046 0000 0047 0000     D...E...F...G...
 800188c:	0048 0000 0049 0000 004a 0000 004b 0000     H...I...J...K...
 800189c:	004c 0000 004d 0000 004e 0000 004f 0000     L...M...N...O...
 80018ac:	0050 0000 0051 0000 0052 0000 0053 0000     P...Q...R...S...
 80018bc:	0054 0000 0055 0000 0056 0000 0057 0000     T...U...V...W...
 80018cc:	0058 0000 0059 0000 005a 0000 005b 0000     X...Y...Z...[...
 80018dc:	005c 0000 005d 0000 005e 0000 005f 0000     \...]...^..._...
 80018ec:	0060 0000 0061 0000 0062 0000 0063 0000     `...a...b...c...
 80018fc:	0064 0000 0065 0000 0066 0000 0067 0000     d...e...f...g...
 800190c:	0068 0000 0069 0000 006a 0000 006b 0000     h...i...j...k...
 800191c:	006c 0000 006d 0000 006e 0000 006f 0000     l...m...n...o...
 800192c:	0070 0000 0071 0000 0072 0000 0073 0000     p...q...r...s...
 800193c:	0074 0000 0075 0000 0076 0000 0077 0000     t...u...v...w...
 800194c:	0078 0000 0079 0000 007a 0000 007b 0000     x...y...z...{...
 800195c:	007c 0000 007d 0000 007e 0000 007f 0000     |...}...~.......
 800196c:	0080 0000 0081 0000 0082 0000 0083 0000     ................
 800197c:	0084 0000 0085 0000 0086 0000 0087 0000     ................
 800198c:	0088 0000 0089 0000 008a 0000 008b 0000     ................
 800199c:	008c 0000 008d 0000 008e 0000 008f 0000     ................
 80019ac:	0090 0000 0091 0000 0092 0000 0093 0000     ................
 80019bc:	0094 0000 0095 0000 0096 0000 0097 0000     ................
 80019cc:	0098 0000 0099 0000 009a 0000 009b 0000     ................
 80019dc:	009c 0000 009d 0000 009e 0000 009f 0000     ................
 80019ec:	00a0 0000 00a1 0000 00a2 0000 00a3 0000     ................
 80019fc:	00a4 0000 00a5 0000 00a6 0000 00a7 0000     ................
 8001a0c:	00a8 0000 00a9 0000 00aa 0000 00ab 0000     ................
 8001a1c:	00ac 0000 00ad 0000 00ae 0000 00af 0000     ................
 8001a2c:	00b0 0000 00b1 0000 00b2 0000 00b3 0000     ................
 8001a3c:	00b4 0000 00b5 0000 00b6 0000 00b7 0000     ................
 8001a4c:	00b8 0000 00b9 0000 00ba 0000 00bb 0000     ................
 8001a5c:	00bc 0000 00bd 0000 00be 0000 00bf 0000     ................
 8001a6c:	00c0 0000 00c1 0000 00c2 0000 00c3 0000     ................
 8001a7c:	00c4 0000 00c5 0000 00c6 0000 00c7 0000     ................
 8001a8c:	00c8 0000 00c9 0000 00ca 0000 00cb 0000     ................
 8001a9c:	00cc 0000 00cd 0000 00ce 0000 00cf 0000     ................
 8001aac:	00d0 0000 00d1 0000 00d2 0000 00d3 0000     ................
 8001abc:	00d4 0000 00d5 0000 00d6 0000 00d7 0000     ................
 8001acc:	00d8 0000 00d9 0000 00da 0000 00db 0000     ................
 8001adc:	00dc 0000 00dd 0000 00de 0000 00df 0000     ................
 8001aec:	00e0 0000 00e1 0000 00e2 0000 00e3 0000     ................
 8001afc:	00e4 0000 00e5 0000 00e6 0000 00e7 0000     ................
 8001b0c:	00e8 0000 00e9 0000 00ea 0000 00eb 0000     ................
 8001b1c:	00ec 0000 00ed 0000 00ee 0000 00ef 0000     ................
 8001b2c:	00f0 0000 00f1 0000 00f2 0000 00f3 0000     ................
 8001b3c:	00f4 0000 00f5 0000 00f6 0000 00f7 0000     ................
 8001b4c:	00f8 0000 00f9 0000 00fa 0000 00fb 0000     ................
 8001b5c:	00fc 0000 00fd 0000 00fe 0000 00ff 0000     ................
 8001b6c:	0100 0000 0101 0000 0102 0000 0103 0000     ................
 8001b7c:	0104 0000 0105 0000 0106 0000 0107 0000     ................
 8001b8c:	0108 0000 0109 0000 010a 0000 010b 0000     ................
 8001b9c:	010c 0000 010d 0000 010e 0000 010f 0000     ................
 8001bac:	0110 0000 0111 0000 0112 0000 0113 0000     ................
 8001bbc:	0114 0000 0115 0000 0116 0000 0117 0000     ................
 8001bcc:	0118 0000 0119 0000 011a 0000 011b 0000     ................
 8001bdc:	011c 0000 011d 0000 011e 0000 011f 0000     ................
 8001bec:	0120 0000 0121 0000 0122 0000 0123 0000      ...!..."...#...
 8001bfc:	0124 0000 0125 0000 0126 0000 0127 0000     $...%...&...'...
 8001c0c:	0128 0000 0129 0000 012a 0000 012b 0000     (...)...*...+...
 8001c1c:	012c 0000 012d 0000 012e 0000 012f 0000     ,...-......./...
 8001c2c:	0130 0000 0131 0000 0132 0000 0133 0000     0...1...2...3...
 8001c3c:	0134 0000 0135 0000 0136 0000 0137 0000     4...5...6...7...
 8001c4c:	0138 0000 0139 0000 013a 0000 013b 0000     8...9...:...;...
 8001c5c:	013c 0000 013d 0000 013e 0000 013f 0000     <...=...>...?...
 8001c6c:	0140 0000 0141 0000 0142 0000 0143 0000     @...A...B...C...
 8001c7c:	0144 0000 0145 0000 0146 0000 0147 0000     D...E...F...G...
 8001c8c:	0148 0000 0149 0000 014a 0000 014b 0000     H...I...J...K...
 8001c9c:	014c 0000 014d 0000 014e 0000 014f 0000     L...M...N...O...
 8001cac:	0150 0000 0151 0000 0152 0000 0153 0000     P...Q...R...S...
 8001cbc:	0154 0000 0155 0000 0156 0000 0157 0000     T...U...V...W...
 8001ccc:	0158 0000 0159 0000 015a 0000 015b 0000     X...Y...Z...[...
 8001cdc:	015c 0000 015d 0000 015e 0000 015f 0000     \...]...^..._...
 8001cec:	0160 0000 0161 0000 0162 0000 0163 0000     `...a...b...c...
 8001cfc:	0164 0000 0165 0000 0166 0000 0167 0000     d...e...f...g...
 8001d0c:	0168 0000 0169 0000 016a 0000 016b 0000     h...i...j...k...
 8001d1c:	016c 0000 016d 0000 016e 0000 016f 0000     l...m...n...o...
 8001d2c:	0170 0000 0171 0000 0172 0000 0173 0000     p...q...r...s...
 8001d3c:	0174 0000 0175 0000 0176 0000 0177 0000     t...u...v...w...
 8001d4c:	0178 0000 0179 0000 017a 0000 017b 0000     x...y...z...{...
 8001d5c:	017c 0000 017d 0000 017e 0000 017f 0000     |...}...~.......
 8001d6c:	0180 0000 0181 0000 0182 0000 0183 0000     ................
 8001d7c:	0184 0000 0185 0000 0186 0000 0187 0000     ................
 8001d8c:	0188 0000 0189 0000 018a 0000 018b 0000     ................
 8001d9c:	018c 0000 018d 0000 018e 0000 018f 0000     ................
 8001dac:	0190 0000 0191 0000 0192 0000 0193 0000     ................
 8001dbc:	0194 0000 0195 0000 0196 0000 0197 0000     ................
 8001dcc:	0198 0000 0199 0000 019a 0000 019b 0000     ................
 8001ddc:	019c 0000 019d 0000 019e 0000 019f 0000     ................
 8001dec:	01a0 0000 01a1 0000 01a2 0000 01a3 0000     ................
 8001dfc:	01a4 0000 01a5 0000 01a6 0000 01a7 0000     ................
 8001e0c:	01a8 0000 01a9 0000 01aa 0000 01ab 0000     ................
 8001e1c:	01ac 0000 01ad 0000 01ae 0000 01af 0000     ................
 8001e2c:	01b0 0000 01b1 0000 01b2 0000 01b3 0000     ................
 8001e3c:	01b4 0000 01b5 0000 01b6 0000 01b7 0000     ................
 8001e4c:	01b8 0000 01b9 0000 01ba 0000 01bb 0000     ................
 8001e5c:	01bc 0000 01bd 0000 01be 0000 01bf 0000     ................
 8001e6c:	01c0 0000 01c1 0000 01c2 0000 01c3 0000     ................
 8001e7c:	01c4 0000 01c5 0000 01c6 0000 01c7 0000     ................
 8001e8c:	01c8 0000 01c9 0000 01ca 0000 01cb 0000     ................
 8001e9c:	01cc 0000 01cd 0000 01ce 0000 01cf 0000     ................
 8001eac:	01d0 0000 01d1 0000 01d2 0000 01d3 0000     ................
 8001ebc:	01d4 0000 01d5 0000 01d6 0000 01d7 0000     ................
 8001ecc:	01d8 0000 01d9 0000 01da 0000 01db 0000     ................
 8001edc:	01dc 0000 01dd 0000 01de 0000 01df 0000     ................
 8001eec:	01e0 0000 01e1 0000 01e2 0000 01e3 0000     ................
 8001efc:	01e4 0000 01e5 0000 01e6 0000 01e7 0000     ................
 8001f0c:	01e8 0000 01e9 0000 01ea 0000 01eb 0000     ................
 8001f1c:	01ec 0000 01ed 0000 01ee 0000 01ef 0000     ................
 8001f2c:	01f0 0000 01f1 0000 01f2 0000 01f3 0000     ................
 8001f3c:	01f4 0000 01f5 0000 01f6 0000 01f7 0000     ................
 8001f4c:	01f8 0000 01f9 0000 01fa 0000 01fb 0000     ................
 8001f5c:	01fc 0000 01fd 0000 01fe 0000 01ff 0000     ................
 8001f6c:	0200 0000 0201 0000 0202 0000 0203 0000     ................
 8001f7c:	0204 0000 0205 0000 0206 0000 0207 0000     ................
 8001f8c:	0208 0000 0209 0000 020a 0000 020b 0000     ................
 8001f9c:	020c 0000 020d 0000 020e 0000 020f 0000     ................
 8001fac:	0210 0000 0211 0000 0212 0000 0213 0000     ................
 8001fbc:	0214 0000 0215 0000 0216 0000 0217 0000     ................
 8001fcc:	0218 0000 0219 0000 021a 0000 021b 0000     ................
 8001fdc:	021c 0000 021d 0000 021e 0000 021f 0000     ................
 8001fec:	0220 0000 0221 0000 0222 0000 0223 0000      ...!..."...#...
 8001ffc:	0224 0000 0225 0000 0226 0000 0227 0000     $...%...&...'...
 800200c:	0228 0000 0229 0000 022a 0000 022b 0000     (...)...*...+...
 800201c:	022c 0000 022d 0000 022e 0000 022f 0000     ,...-......./...
 800202c:	0230 0000 0231 0000 0232 0000 0233 0000     0...1...2...3...
 800203c:	0234 0000 0235 0000 0236 0000 0237 0000     4...5...6...7...
 800204c:	0238 0000 0239 0000 023a 0000 023b 0000     8...9...:...;...
 800205c:	023c 0000 023d 0000 023e 0000 023f 0000     <...=...>...?...
 800206c:	0240 0000 0241 0000 0242 0000 0243 0000     @...A...B...C...
 800207c:	0244 0000 0245 0000 0246 0000 0247 0000     D...E...F...G...
 800208c:	0248 0000 0249 0000 024a 0000 024b 0000     H...I...J...K...
 800209c:	024c 0000 024d 0000 024e 0000 024f 0000     L...M...N...O...
 80020ac:	0250 0000 0251 0000 0252 0000 0253 0000     P...Q...R...S...
 80020bc:	0254 0000 0255 0000 0256 0000 0257 0000     T...U...V...W...
 80020cc:	0258 0000 0259 0000 025a 0000 025b 0000     X...Y...Z...[...
 80020dc:	025c 0000 025d 0000 025e 0000 025f 0000     \...]...^..._...
 80020ec:	0260 0000 0261 0000 0262 0000 0263 0000     `...a...b...c...
 80020fc:	0264 0000 0265 0000 0266 0000 0267 0000     d...e...f...g...
 800210c:	0268 0000 0269 0000 026a 0000 026b 0000     h...i...j...k...
 800211c:	026c 0000 026d 0000 026e 0000 026f 0000     l...m...n...o...
 800212c:	0270 0000 0271 0000 0272 0000 0273 0000     p...q...r...s...
 800213c:	0274 0000 0275 0000 0276 0000 0277 0000     t...u...v...w...
 800214c:	0278 0000 0279 0000 027a 0000 027b 0000     x...y...z...{...
 800215c:	027c 0000 027d 0000 027e 0000 027f 0000     |...}...~.......
 800216c:	0280 0000 0281 0000 0282 0000 0283 0000     ................
 800217c:	0284 0000 0285 0000 0286 0000 0287 0000     ................
 800218c:	0288 0000 0289 0000 028a 0000 028b 0000     ................
 800219c:	028c 0000 028d 0000 028e 0000 028f 0000     ................
 80021ac:	0290 0000 0291 0000 0292 0000 0293 0000     ................
 80021bc:	0294 0000 0295 0000 0296 0000 0297 0000     ................
 80021cc:	0298 0000 0299 0000 029a 0000 029b 0000     ................
 80021dc:	029c 0000 029d 0000 029e 0000 029f 0000     ................
 80021ec:	02a0 0000 02a1 0000 02a2 0000 02a3 0000     ................
 80021fc:	02a4 0000 02a5 0000 02a6 0000 02a7 0000     ................
 800220c:	02a8 0000 02a9 0000 02aa 0000 02ab 0000     ................
 800221c:	02ac 0000 02ad 0000 02ae 0000 02af 0000     ................
 800222c:	02b0 0000 02b1 0000 02b2 0000 02b3 0000     ................
 800223c:	02b4 0000 02b5 0000 02b6 0000 02b7 0000     ................
 800224c:	02b8 0000 02b9 0000 02ba 0000 02bb 0000     ................
 800225c:	02bc 0000 02bd 0000 02be 0000 02bf 0000     ................
 800226c:	02c0 0000 02c1 0000 02c2 0000 02c3 0000     ................
 800227c:	02c4 0000 02c5 0000 02c6 0000 02c7 0000     ................
 800228c:	02c8 0000 02c9 0000 02ca 0000 02cb 0000     ................
 800229c:	02cc 0000 02cd 0000 02ce 0000 02cf 0000     ................
 80022ac:	02d0 0000 02d1 0000 02d2 0000 02d3 0000     ................
 80022bc:	02d4 0000 02d5 0000 02d6 0000 02d7 0000     ................
 80022cc:	02d8 0000 02d9 0000 02da 0000 02db 0000     ................
 80022dc:	02dc 0000 02dd 0000 02de 0000 02df 0000     ................
 80022ec:	02e0 0000 02e1 0000 02e2 0000 02e3 0000     ................
 80022fc:	02e4 0000 02e5 0000 02e6 0000 02e7 0000     ................
 800230c:	02e8 0000 02e9 0000 02ea 0000 02eb 0000     ................
 800231c:	02ec 0000 02ed 0000 02ee 0000 02ef 0000     ................
 800232c:	02f0 0000 02f1 0000 02f2 0000 02f3 0000     ................
 800233c:	02f4 0000 02f5 0000 02f6 0000 02f7 0000     ................
 800234c:	02f8 0000 02f9 0000 02fa 0000 02fb 0000     ................
 800235c:	02fc 0000 02fd 0000 02fe 0000 02ff 0000     ................
 800236c:	0300 0000 0301 0000 0302 0000 0303 0000     ................
 800237c:	0304 0000 0305 0000 0306 0000 0307 0000     ................
 800238c:	0308 0000 0309 0000 030a 0000 030b 0000     ................
 800239c:	030c 0000 030d 0000 030e 0000 030f 0000     ................
 80023ac:	0310 0000 0311 0000 0312 0000 0313 0000     ................
 80023bc:	0314 0000 0315 0000 0316 0000 0317 0000     ................
 80023cc:	0318 0000 0319 0000 031a 0000 031b 0000     ................
 80023dc:	031c 0000 031d 0000 031e 0000 031f 0000     ................
 80023ec:	0320 0000 0321 0000 0322 0000 0323 0000      ...!..."...#...
 80023fc:	0324 0000 0325 0000 0326 0000 0327 0000     $...%...&...'...
 800240c:	0328 0000 0329 0000 032a 0000 032b 0000     (...)...*...+...
 800241c:	032c 0000 032d 0000 032e 0000 032f 0000     ,...-......./...
 800242c:	0330 0000 0331 0000 0332 0000 0333 0000     0...1...2...3...
 800243c:	0334 0000 0335 0000 0336 0000 0337 0000     4...5...6...7...
 800244c:	0338 0000 0339 0000 033a 0000 033b 0000     8...9...:...;...
 800245c:	033c 0000 033d 0000 033e 0000 033f 0000     <...=...>...?...
 800246c:	0340 0000 0341 0000 0342 0000 0343 0000     @...A...B...C...
 800247c:	0344 0000 0345 0000 0346 0000 0347 0000     D...E...F...G...
 800248c:	0348 0000 0349 0000 034a 0000 034b 0000     H...I...J...K...
 800249c:	034c 0000 034d 0000 034e 0000 034f 0000     L...M...N...O...
 80024ac:	0350 0000 0351 0000 0352 0000 0353 0000     P...Q...R...S...
 80024bc:	0354 0000 0355 0000 0356 0000 0357 0000     T...U...V...W...
 80024cc:	0358 0000 0359 0000 035a 0000 035b 0000     X...Y...Z...[...
 80024dc:	035c 0000 035d 0000 035e 0000 035f 0000     \...]...^..._...
 80024ec:	0360 0000 0361 0000 0362 0000 0363 0000     `...a...b...c...
 80024fc:	0364 0000 0365 0000 0366 0000 0367 0000     d...e...f...g...
 800250c:	0368 0000 0369 0000 036a 0000 036b 0000     h...i...j...k...
 800251c:	036c 0000 036d 0000 036e 0000 036f 0000     l...m...n...o...
 800252c:	0370 0000 0371 0000 0372 0000 0373 0000     p...q...r...s...
 800253c:	0374 0000 0375 0000 0376 0000 0377 0000     t...u...v...w...
 800254c:	0378 0000 0379 0000 037a 0000 037b 0000     x...y...z...{...
 800255c:	037c 0000 037d 0000 037e 0000 037f 0000     |...}...~.......
 800256c:	0380 0000 0381 0000 0382 0000 0383 0000     ................
 800257c:	0384 0000 0385 0000 0386 0000 0387 0000     ................
 800258c:	0388 0000 0389 0000 038a 0000 038b 0000     ................
 800259c:	038c 0000 038d 0000 038e 0000 038f 0000     ................
 80025ac:	0390 0000 0391 0000 0392 0000 0393 0000     ................
 80025bc:	0394 0000 0395 0000 0396 0000 0397 0000     ................
 80025cc:	0398 0000 0399 0000 039a 0000 039b 0000     ................
 80025dc:	039c 0000 039d 0000 039e 0000 039f 0000     ................
 80025ec:	03a0 0000 03a1 0000 03a2 0000 03a3 0000     ................
 80025fc:	03a4 0000 03a5 0000 03a6 0000 03a7 0000     ................
 800260c:	03a8 0000 03a9 0000 03aa 0000 03ab 0000     ................
 800261c:	03ac 0000 03ad 0000 03ae 0000 03af 0000     ................
 800262c:	03b0 0000 03b1 0000 03b2 0000 03b3 0000     ................
 800263c:	03b4 0000 03b5 0000 03b6 0000 03b7 0000     ................
 800264c:	03b8 0000 03b9 0000 03ba 0000 03bb 0000     ................
 800265c:	03bc 0000 03bd 0000 03be 0000 03bf 0000     ................
 800266c:	03c0 0000 03c1 0000 03c2 0000 03c3 0000     ................
 800267c:	03c4 0000 03c5 0000 03c6 0000 03c7 0000     ................
 800268c:	03c8 0000 03c9 0000 03ca 0000 03cb 0000     ................
 800269c:	03cc 0000 03cd 0000 03ce 0000 03cf 0000     ................
 80026ac:	03d0 0000 03d1 0000 03d2 0000 03d3 0000     ................
 80026bc:	03d4 0000 03d5 0000 03d6 0000 03d7 0000     ................
 80026cc:	03d8 0000 03d9 0000 03da 0000 03db 0000     ................
 80026dc:	03dc 0000 03dd 0000 03de 0000 03df 0000     ................
 80026ec:	03e0 0000 03e1 0000 03e2 0000 03e3 0000     ................
 80026fc:	03e4 0000 03e5 0000 03e6 0000 03e7 0000     ................
 800270c:	03e8 0000 03e9 0000 03ea 0000 03eb 0000     ................
 800271c:	03ec 0000 03ed 0000 03ee 0000 03ef 0000     ................
 800272c:	03f0 0000 03f1 0000 03f2 0000 03f3 0000     ................
 800273c:	03f4 0000 03f5 0000 03f6 0000 03f7 0000     ................
 800274c:	03f8 0000 03f9 0000 03fa 0000 03fb 0000     ................
 800275c:	03fc 0000 03fd 0000 03fe 0000 03ff 0000     ................
